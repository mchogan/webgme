//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "addOn.js.ejs": "/*globals define*/\n/*jshint node:true, browser:true*/\n\n/**\n * Generated by AddOnGenerator <%= version %> from webgme on <%= date %>.\n */\n\ndefine([\n    'addon/AddOnBase'\n], function (AddOnBase) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of <%= addOnId %>.\n     * @class\n     * @augments {AddOnBase}\n     * @classdesc This class represents the addOn <%= addOnId %>.\n     * @constructor\n     */\n    var <%= addOnId %> = function (mainLogger, gmeConfig) {\n        // Call base class' constructor.\n        AddOnBase.call(this, mainLogger, gmeConfig);\n    };\n\n    // Prototypal inheritance from AddOnBase.\n    <%= addOnId %>.prototype = Object.create(AddOnBase.prototype);\n    <%= addOnId %>.prototype.constructor = <%= addOnId %>;\n\n    /**\n     * Gets the name of the <%= addOnId %>.\n     * @returns {string} The name of the AddOn.\n     * @public\n     */\n    <%= addOnId %>.prototype.getName = function () {\n        return '<%= addOnName %>';\n    };\n\n    /**\n     * Gets the semantic version (semver.org) of the <%= addOnId %>.\n     * @returns {string} The version of the AddOn.\n     * @public\n     */\n    <%= addOnId %>.prototype.getVersion = function () {\n        return '0.1.0';\n    };<% if (description) {%>\n\n    /**\n     * Gets the description of the <%= addOnId %>.\n     * @returns {string} The description of the AddOn.\n     * @public\n     */\n    <%= addOnId %>.prototype.getDescription = function () {\n        return '<%= description %>';\n    };<%}%>\n\n    /**\n     * This is invoked each time changes in the branch of the project are done. AddOns are allowed to make changes on\n     * an update, but should not persist by themselves. (The AddOnManager will persist after each addOn has had its way\n     * ordered by the usedAddOn registry in the rootNode).\n     * Before each invocation a new updateResult is created which should be returned in the callback. There is no need\n     * for the AddOn to report if it made changes or not, the monitor/manager will always persist and if there are no\n     * changed objects - it won't commit to the storage.\n     * @param {object} rootNode\n     * @param {object} commitObj\n     * @param {function(Error, AddOnUpdateResult)} callback\n     */\n    <%= addOnId %>.prototype.update = function (rootNode, commitObj, callback) {\n        var newName = commitObj.updater.toString();\n        this.logger.info('<%= addOnId %> in update at commitHash', commitObj._id);\n\n        if (this.core.getAttribute(rootNode, 'name') !== newName) {\n            this.logger.info('<%= addOnId %> changing name of root to committer(s): ', newName);\n            this.core.setAttribute(rootNode, 'name', newName);\n            this.addCommitMessage('Changed rootNode name to \"' + newName + '\"');\n        }\n\n        callback(null, this.updateResult);\n    };\n\n    /**\n     * Called once when the addOn is started for the first time.\n     * @param {object} rootNode\n     * @param {object} commitObj\n     * @param {function(Error, AddOnUpdateResult} callback\n     */\n    <%= addOnId %>.prototype.initialize = function (rootNode, commitObj, callback) {\n        this.logger.info('<%= addOnId %> got initialized at commitHash', commitObj._id);\n\n        this.update(rootNode, commitObj, callback);\n    };\n\n    return <%= addOnId %>;\n});\n"
}});