{
  "version": 3,
  "file": "dist/webgme.classes.build.js",
  "sources": [
    "node_modules/requirejs/require.js",
    "src/common/util/assert.js",
    "src/common/EventDispatcher.js",
    "src/common/util/guid.js",
    "src/common/util/sha1.js",
    "src/common/util/zssha1.js",
    "src/common/util/canon.js",
    "src/common/util/asmcryptosha1.js",
    "src/common/util/key.js",
    "src/common/core/future.js",
    "src/common/core/tasync.js",
    "src/common/core/coretree.js",
    "src/common/core/corerel.js",
    "src/common/core/setcore.js",
    "src/common/core/guidcore.js",
    "src/common/core/nullpointercore.js",
    "src/common/core/coreunwrap.js",
    "src/common/core/descriptorcore.js",
    "src/common/core/coretype.js",
    "src/common/core/constraintcore.js",
    "src/common/util/jjv.js",
    "src/common/core/metacore.js",
    "src/common/core/corediff.js",
    "src/common/core/coretreeloader.js",
    "src/common/core/core.js",
    "src/common/storage/client.js",
    "src/common/storage/failsafe.js",
    "src/common/storage/hashcheck.js",
    "src/common/storage/cache.js",
    "src/common/storage/commit.js",
    "src/common/storage/log.js",
    "src/common/storage/clientstorage.js",
    "src/common/LogManager.js",
    "src/common/util/url.js",
    "src/common/core/users/meta.js",
    "src/common/core/users/tojson.js",
    "src/common/core/users/dump.js",
    "src/common/core/users/dumpmore.js",
    "src/common/core/users/import.js",
    "src/common/core/users/copyimport.js",
    "src/common/core/users/serialization.js",
    "src/client/js/client.js",
    "src/middleware/blob/BlobConfig.js",
    "src/middleware/blob/BlobMetadata.js",
    "src/middleware/blob/Artifact.js",
    "node_modules/superagent/superagent.js",
    "src/middleware/blob/BlobClient.js",
    "src/plugin/PluginConfig.js",
    "src/plugin/PluginNodeDescription.js",
    "src/plugin/PluginMessage.js",
    "src/plugin/PluginResult.js",
    "src/plugin/PluginBase.js",
    "src/plugin/PluginContext.js",
    "src/plugin/PluginManagerBase.js",
    "utils/build/empty/empty.js",
    "src/client/js/Utils/InterpreterManager.js",
    "utils/build/webgme.classes/webgme.classes.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvhEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA,ADuBA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA,AD4DA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA,ADyHA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACriCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA,ADmDA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9uBA,AD+uBA;AC9uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACh7BA,ADi7BA;ACh7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACx2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxVA,ADyVA;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA,ADwDA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA,ADyFA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtwBA,ADuwBA;ACtwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzrBA,AD0rBA;ACzrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACheA,ADieA;ACheA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC51EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA,ADiDA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACh6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA,ADuDA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvNA,ADwNA;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA,ADmBA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA,AD+CA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACneA,ADoeA;ACneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7fA,AD8fA;AC7fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/zBA,ADg0BA;AC/zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjmHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA,ADgFA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClRA,ADmRA;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACx7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA,AD8CA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5LA,AD6LA;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvSA;AACA;AACA;AACA;ACHA,ADIA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 2.1.11 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n//Not using strict: uneven strict support in browsers, #392, and causes\n//problems with requirejs.exec()/transpiler plugins that may not be strict.\n/*jslint regexp: true, nomen: true, sloppy: true */\n/*global window, navigator, document, importScripts, setTimeout, opera */\n\nvar requirejs, require, define;\n(function (global) {\n    var req, s, head, baseElement, dataMain, src,\n        interactiveScript, currentlyAddingScript, mainScript, subPath,\n        version = '2.1.11',\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\n        jsSuffixRegExp = /\\.js$/,\n        currDirRegExp = /^\\.\\//,\n        op = Object.prototype,\n        ostring = op.toString,\n        hasOwn = op.hasOwnProperty,\n        ap = Array.prototype,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),\n        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is 'loading', 'loaded', execution,\n        // then 'complete'. The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = '_',\n        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n        contexts = {},\n        cfg = {},\n        globalDefQueue = [],\n        useInteractive = false;\n\n    function isFunction(it) {\n        return ostring.call(it) === '[object Function]';\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === '[object Array]';\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function for iterating over an array backwards. If the func\n     * returns a true value, it will break out of the loop.\n     */\n    function eachReverse(ary, func) {\n        if (ary) {\n            var i;\n            for (i = ary.length - 1; i > -1; i -= 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    function getOwn(obj, prop) {\n        return hasProp(obj, prop) && obj[prop];\n    }\n\n    /**\n     * Cycles over properties in an object and calls a function for each\n     * property value. If the function returns a truthy value, then the\n     * iteration is stopped.\n     */\n    function eachProp(obj, func) {\n        var prop;\n        for (prop in obj) {\n            if (hasProp(obj, prop)) {\n                if (func(obj[prop], prop)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     */\n    function mixin(target, source, force, deepStringMixin) {\n        if (source) {\n            eachProp(source, function (value, prop) {\n                if (force || !hasProp(target, prop)) {\n                    if (deepStringMixin && typeof value === 'object' && value &&\n                        !isArray(value) && !isFunction(value) &&\n                        !(value instanceof RegExp)) {\n\n                        if (!target[prop]) {\n                            target[prop] = {};\n                        }\n                        mixin(target[prop], value, force, deepStringMixin);\n                    } else {\n                        target[prop] = value;\n                    }\n                }\n            });\n        }\n        return target;\n    }\n\n    //Similar to Function.prototype.bind, but the 'this' object is specified\n    //first, since it is easier to read/figure out what 'this' will be.\n    function bind(obj, fn) {\n        return function () {\n            return fn.apply(obj, arguments);\n        };\n    }\n\n    function scripts() {\n        return document.getElementsByTagName('script');\n    }\n\n    function defaultOnError(err) {\n        throw err;\n    }\n\n    //Allow getting a global that is expressed in\n    //dot notation, like 'a.b.c'.\n    function getGlobal(value) {\n        if (!value) {\n            return value;\n        }\n        var g = global;\n        each(value.split('.'), function (part) {\n            g = g[part];\n        });\n        return g;\n    }\n\n    /**\n     * Constructs an error with a pointer to an URL with more information.\n     * @param {String} id the error ID that maps to an ID on a web page.\n     * @param {String} message human readable error.\n     * @param {Error} [err] the original error, if there is one.\n     *\n     * @returns {Error}\n     */\n    function makeError(id, msg, err, requireModules) {\n        var e = new Error(msg + '\\nhttp://requirejs.org/docs/errors.html#' + id);\n        e.requireType = id;\n        e.requireModules = requireModules;\n        if (err) {\n            e.originalError = err;\n        }\n        return e;\n    }\n\n    if (typeof define !== 'undefined') {\n        //If a define is already in play via another AMD loader,\n        //do not overwrite.\n        return;\n    }\n\n    if (typeof requirejs !== 'undefined') {\n        if (isFunction(requirejs)) {\n            //Do not overwrite and existing requirejs instance.\n            return;\n        }\n        cfg = requirejs;\n        requirejs = undefined;\n    }\n\n    //Allow for a require config object\n    if (typeof require !== 'undefined' && !isFunction(require)) {\n        //assume it is a config object.\n        cfg = require;\n        require = undefined;\n    }\n\n    function newContext(contextName) {\n        var inCheckLoaded, Module, context, handlers,\n            checkLoadedTimeoutId,\n            config = {\n                //Defaults. Do not set a default for map\n                //config to speed up normalize(), which\n                //will run faster if there is no default.\n                waitSeconds: 7,\n                baseUrl: './',\n                paths: {},\n                bundles: {},\n                pkgs: {},\n                shim: {},\n                config: {}\n            },\n            registry = {},\n            //registry of just enabled modules, to speed\n            //cycle breaking code when lots of modules\n            //are registered, but not activated.\n            enabledRegistry = {},\n            undefEvents = {},\n            defQueue = [],\n            defined = {},\n            urlFetched = {},\n            bundlesMap = {},\n            requireCounter = 1,\n            unnormalizedCounter = 1;\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part, length = ary.length;\n            for (i = 0; i < length; i++) {\n                part = ary[i];\n                if (part === '.') {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                        //End of the line. Keep at least one non-dot\n                        //path segment at the front so it can be mapped\n                        //correctly to disk. Otherwise, there is likely\n                        //no path mapping for a path starting with '..'.\n                        //This can still fail, but catches the most reasonable\n                        //uses of ..\n                        break;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @param {Boolean} applyMap apply the map config to the value. Should\n         * only be done if this normalization is for a dependency ID.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName, applyMap) {\n            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,\n                foundMap, foundI, foundStarMap, starI,\n                baseParts = baseName && baseName.split('/'),\n                normalizedBaseParts = baseParts,\n                map = config.map,\n                starMap = map && map['*'];\n\n            //Adjust any relative paths.\n            if (name && name.charAt(0) === '.') {\n                //If have a base name, try to normalize against it,\n                //otherwise, assume it is a top-level require that will\n                //be relative to baseUrl in the end.\n                if (baseName) {\n                    //Convert baseName to array, and lop off the last part,\n                    //so that . matches that 'directory' and not name of the baseName's\n                    //module. For instance, baseName of 'one/two/three', maps to\n                    //'one/two/three.js', but we want the directory, 'one/two' for\n                    //this normalization.\n                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                    name = name.split('/');\n                    lastIndex = name.length - 1;\n\n                    // If wanting node ID compatibility, strip .js from end\n                    // of IDs. Have to do this here, and not in nameToUrl\n                    // because node allows either .js or non .js to map\n                    // to same file.\n                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                        name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                    }\n\n                    name = normalizedBaseParts.concat(name);\n                    trimDots(name);\n                    name = name.join('/');\n                } else if (name.indexOf('./') === 0) {\n                    // No baseName, so this is ID is resolved relative\n                    // to baseUrl, pull off the leading dot.\n                    name = name.substring(2);\n                }\n            }\n\n            //Apply map config if available.\n            if (applyMap && map && (baseParts || starMap)) {\n                nameParts = name.split('/');\n\n                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {\n                    nameSegment = nameParts.slice(0, i).join('/');\n\n                    if (baseParts) {\n                        //Find the longest baseName segment match in the config.\n                        //So, do joins on the biggest to smallest lengths of baseParts.\n                        for (j = baseParts.length; j > 0; j -= 1) {\n                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));\n\n                            //baseName segment has config, find if it has one for\n                            //this name.\n                            if (mapValue) {\n                                mapValue = getOwn(mapValue, nameSegment);\n                                if (mapValue) {\n                                    //Match, update name to the new value.\n                                    foundMap = mapValue;\n                                    foundI = i;\n                                    break outerLoop;\n                                }\n                            }\n                        }\n                    }\n\n                    //Check for a star map match, but just hold on to it,\n                    //if there is a shorter segment match later in a matching\n                    //config, then favor over this star map.\n                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {\n                        foundStarMap = getOwn(starMap, nameSegment);\n                        starI = i;\n                    }\n                }\n\n                if (!foundMap && foundStarMap) {\n                    foundMap = foundStarMap;\n                    foundI = starI;\n                }\n\n                if (foundMap) {\n                    nameParts.splice(0, foundI, foundMap);\n                    name = nameParts.join('/');\n                }\n            }\n\n            // If the name points to a package's name, use\n            // the package main instead.\n            pkgMain = getOwn(config.pkgs, name);\n\n            return pkgMain ? pkgMain : name;\n        }\n\n        function removeScript(name) {\n            if (isBrowser) {\n                each(scripts(), function (scriptNode) {\n                    if (scriptNode.getAttribute('data-requiremodule') === name &&\n                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {\n                        scriptNode.parentNode.removeChild(scriptNode);\n                        return true;\n                    }\n                });\n            }\n        }\n\n        function hasPathFallback(id) {\n            var pathConfig = getOwn(config.paths, id);\n            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {\n                //Pop off the first array value, since it failed, and\n                //retry\n                pathConfig.shift();\n                context.require.undef(id);\n                context.require([id]);\n                return true;\n            }\n        }\n\n        //Turns a plugin!resource to [plugin, resource]\n        //with the plugin being undefined if the name\n        //did not have a plugin prefix.\n        function splitPrefix(name) {\n            var prefix,\n                index = name ? name.indexOf('!') : -1;\n            if (index > -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n            return [prefix, name];\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         * @param {Boolean} isNormalized: is the ID already normalized.\n         * This is true if this call is done for a define() module ID.\n         * @param {Boolean} applyMap: apply the map config to the ID.\n         * Should only be true if this map is for a dependency.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\n            var url, pluginModule, suffix, nameParts,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                isDefine = true,\n                normalizedName = '';\n\n            //If no name, then it means it is a require call, generate an\n            //internal name.\n            if (!name) {\n                isDefine = false;\n                name = '_@r' + (requireCounter += 1);\n            }\n\n            nameParts = splitPrefix(name);\n            prefix = nameParts[0];\n            name = nameParts[1];\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName, applyMap);\n                pluginModule = getOwn(defined, prefix);\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    if (pluginModule && pluginModule.normalize) {\n                        //Plugin is loaded, use its normalize method.\n                        normalizedName = pluginModule.normalize(name, function (name) {\n                            return normalize(name, parentName, applyMap);\n                        });\n                    } else {\n                        normalizedName = normalize(name, parentName, applyMap);\n                    }\n                } else {\n                    //A regular module.\n                    normalizedName = normalize(name, parentName, applyMap);\n\n                    //Normalized name may be a plugin ID due to map config\n                    //application in normalize. The map config values must\n                    //already be normalized, so do not need to redo that part.\n                    nameParts = splitPrefix(normalizedName);\n                    prefix = nameParts[0];\n                    normalizedName = nameParts[1];\n                    isNormalized = true;\n\n                    url = context.nameToUrl(normalizedName);\n                }\n            }\n\n            //If the id is a plugin id that cannot be determined if it needs\n            //normalization, stamp it with a unique ID so two matching relative\n            //ids that may conflict can be separate.\n            suffix = prefix && !pluginModule && !isNormalized ?\n                     '_unnormalized' + (unnormalizedCounter += 1) :\n                     '';\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                unnormalized: !!suffix,\n                url: url,\n                originalName: originalName,\n                isDefine: isDefine,\n                id: (prefix ?\n                        prefix + '!' + normalizedName :\n                        normalizedName) + suffix\n            };\n        }\n\n        function getModule(depMap) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (!mod) {\n                mod = registry[id] = new context.Module(depMap);\n            }\n\n            return mod;\n        }\n\n        function on(depMap, name, fn) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (hasProp(defined, id) &&\n                    (!mod || mod.defineEmitComplete)) {\n                if (name === 'defined') {\n                    fn(defined[id]);\n                }\n            } else {\n                mod = getModule(depMap);\n                if (mod.error && name === 'error') {\n                    fn(mod.error);\n                } else {\n                    mod.on(name, fn);\n                }\n            }\n        }\n\n        function onError(err, errback) {\n            var ids = err.requireModules,\n                notified = false;\n\n            if (errback) {\n                errback(err);\n            } else {\n                each(ids, function (id) {\n                    var mod = getOwn(registry, id);\n                    if (mod) {\n                        //Set error on module, so it skips timeout checks.\n                        mod.error = err;\n                        if (mod.events.error) {\n                            notified = true;\n                            mod.emit('error', err);\n                        }\n                    }\n                });\n\n                if (!notified) {\n                    req.onError(err);\n                }\n            }\n        }\n\n        /**\n         * Internal method to transfer globalQueue items to this context's\n         * defQueue.\n         */\n        function takeGlobalQueue() {\n            //Push all the globalDefQueue items into the context's defQueue\n            if (globalDefQueue.length) {\n                //Array splice in the values since the context code has a\n                //local var ref to defQueue, so cannot just reassign the one\n                //on context.\n                apsp.apply(defQueue,\n                           [defQueue.length, 0].concat(globalDefQueue));\n                globalDefQueue = [];\n            }\n        }\n\n        handlers = {\n            'require': function (mod) {\n                if (mod.require) {\n                    return mod.require;\n                } else {\n                    return (mod.require = context.makeRequire(mod.map));\n                }\n            },\n            'exports': function (mod) {\n                mod.usingExports = true;\n                if (mod.map.isDefine) {\n                    if (mod.exports) {\n                        return (defined[mod.map.id] = mod.exports);\n                    } else {\n                        return (mod.exports = defined[mod.map.id] = {});\n                    }\n                }\n            },\n            'module': function (mod) {\n                if (mod.module) {\n                    return mod.module;\n                } else {\n                    return (mod.module = {\n                        id: mod.map.id,\n                        uri: mod.map.url,\n                        config: function () {\n                            return  getOwn(config.config, mod.map.id) || {};\n                        },\n                        exports: mod.exports || (mod.exports = {})\n                    });\n                }\n            }\n        };\n\n        function cleanRegistry(id) {\n            //Clean up machinery used for waiting modules.\n            delete registry[id];\n            delete enabledRegistry[id];\n        }\n\n        function breakCycle(mod, traced, processed) {\n            var id = mod.map.id;\n\n            if (mod.error) {\n                mod.emit('error', mod.error);\n            } else {\n                traced[id] = true;\n                each(mod.depMaps, function (depMap, i) {\n                    var depId = depMap.id,\n                        dep = getOwn(registry, depId);\n\n                    //Only force things that have not completed\n                    //being defined, so still in the registry,\n                    //and only if it has not been matched up\n                    //in the module already.\n                    if (dep && !mod.depMatched[i] && !processed[depId]) {\n                        if (getOwn(traced, depId)) {\n                            mod.defineDep(i, defined[depId]);\n                            mod.check(); //pass false?\n                        } else {\n                            breakCycle(dep, traced, processed);\n                        }\n                    }\n                });\n                processed[id] = true;\n            }\n        }\n\n        function checkLoaded() {\n            var err, usingPathFallback,\n                waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = [],\n                reqCalls = [],\n                stillLoading = false,\n                needCycleCheck = true;\n\n            //Do not bother if this call was a result of a cycle break.\n            if (inCheckLoaded) {\n                return;\n            }\n\n            inCheckLoaded = true;\n\n            //Figure out the state of all the modules.\n            eachProp(enabledRegistry, function (mod) {\n                var map = mod.map,\n                    modId = map.id;\n\n                //Skip things that are not enabled or in error state.\n                if (!mod.enabled) {\n                    return;\n                }\n\n                if (!map.isDefine) {\n                    reqCalls.push(mod);\n                }\n\n                if (!mod.error) {\n                    //If the module should be executed, and it has not\n                    //been inited and time is up, remember it.\n                    if (!mod.inited && expired) {\n                        if (hasPathFallback(modId)) {\n                            usingPathFallback = true;\n                            stillLoading = true;\n                        } else {\n                            noLoads.push(modId);\n                            removeScript(modId);\n                        }\n                    } else if (!mod.inited && mod.fetched && map.isDefine) {\n                        stillLoading = true;\n                        if (!map.prefix) {\n                            //No reason to keep looking for unfinished\n                            //loading. If the only stillLoading is a\n                            //plugin resource though, keep going,\n                            //because it may be that a plugin resource\n                            //is waiting on a non-plugin cycle.\n                            return (needCycleCheck = false);\n                        }\n                    }\n                }\n            });\n\n            if (expired && noLoads.length) {\n                //If wait time expired, throw error of unloaded modules.\n                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);\n                err.contextName = context.contextName;\n                return onError(err);\n            }\n\n            //Not expired, check for a cycle.\n            if (needCycleCheck) {\n                each(reqCalls, function (mod) {\n                    breakCycle(mod, {}, {});\n                });\n            }\n\n            //If still waiting on loads, and the waiting load is something\n            //other than a plugin resource, or there are still outstanding\n            //scripts, then just try back later.\n            if ((!expired || usingPathFallback) && stillLoading) {\n                //Something is still waiting to load. Wait for it, but only\n                //if a timeout is not already in effect.\n                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {\n                    checkLoadedTimeoutId = setTimeout(function () {\n                        checkLoadedTimeoutId = 0;\n                        checkLoaded();\n                    }, 50);\n                }\n            }\n\n            inCheckLoaded = false;\n        }\n\n        Module = function (map) {\n            this.events = getOwn(undefEvents, map.id) || {};\n            this.map = map;\n            this.shim = getOwn(config.shim, map.id);\n            this.depExports = [];\n            this.depMaps = [];\n            this.depMatched = [];\n            this.pluginMaps = {};\n            this.depCount = 0;\n\n            /* this.exports this.factory\n               this.depMaps = [],\n               this.enabled, this.fetched\n            */\n        };\n\n        Module.prototype = {\n            init: function (depMaps, factory, errback, options) {\n                options = options || {};\n\n                //Do not do more inits if already done. Can happen if there\n                //are multiple define calls for the same module. That is not\n                //a normal, common case, but it is also not unexpected.\n                if (this.inited) {\n                    return;\n                }\n\n                this.factory = factory;\n\n                if (errback) {\n                    //Register for errors on this module.\n                    this.on('error', errback);\n                } else if (this.events.error) {\n                    //If no errback already, but there are error listeners\n                    //on this module, set up an errback to pass to the deps.\n                    errback = bind(this, function (err) {\n                        this.emit('error', err);\n                    });\n                }\n\n                //Do a copy of the dependency array, so that\n                //source inputs are not modified. For example\n                //\"shim\" deps are passed in here directly, and\n                //doing a direct modification of the depMaps array\n                //would affect that config.\n                this.depMaps = depMaps && depMaps.slice(0);\n\n                this.errback = errback;\n\n                //Indicate this module has be initialized\n                this.inited = true;\n\n                this.ignore = options.ignore;\n\n                //Could have option to init this module in enabled mode,\n                //or could have been previously marked as enabled. However,\n                //the dependencies are not known until init is called. So\n                //if enabled previously, now trigger dependencies as enabled.\n                if (options.enabled || this.enabled) {\n                    //Enable this module and dependencies.\n                    //Will call this.check()\n                    this.enable();\n                } else {\n                    this.check();\n                }\n            },\n\n            defineDep: function (i, depExports) {\n                //Because of cycles, defined callback for a given\n                //export can be called more than once.\n                if (!this.depMatched[i]) {\n                    this.depMatched[i] = true;\n                    this.depCount -= 1;\n                    this.depExports[i] = depExports;\n                }\n            },\n\n            fetch: function () {\n                if (this.fetched) {\n                    return;\n                }\n                this.fetched = true;\n\n                context.startTime = (new Date()).getTime();\n\n                var map = this.map;\n\n                //If the manager is for a plugin managed resource,\n                //ask the plugin to load it now.\n                if (this.shim) {\n                    context.makeRequire(this.map, {\n                        enableBuildCallback: true\n                    })(this.shim.deps || [], bind(this, function () {\n                        return map.prefix ? this.callPlugin() : this.load();\n                    }));\n                } else {\n                    //Regular dependency.\n                    return map.prefix ? this.callPlugin() : this.load();\n                }\n            },\n\n            load: function () {\n                var url = this.map.url;\n\n                //Regular dependency.\n                if (!urlFetched[url]) {\n                    urlFetched[url] = true;\n                    context.load(this.map.id, url);\n                }\n            },\n\n            /**\n             * Checks if the module is ready to define itself, and if so,\n             * define it.\n             */\n            check: function () {\n                if (!this.enabled || this.enabling) {\n                    return;\n                }\n\n                var err, cjsModule,\n                    id = this.map.id,\n                    depExports = this.depExports,\n                    exports = this.exports,\n                    factory = this.factory;\n\n                if (!this.inited) {\n                    this.fetch();\n                } else if (this.error) {\n                    this.emit('error', this.error);\n                } else if (!this.defining) {\n                    //The factory could trigger another require call\n                    //that would result in checking this module to\n                    //define itself again. If already in the process\n                    //of doing that, skip this work.\n                    this.defining = true;\n\n                    if (this.depCount < 1 && !this.defined) {\n                        if (isFunction(factory)) {\n                            //If there is an error listener, favor passing\n                            //to that instead of throwing an error. However,\n                            //only do it for define()'d  modules. require\n                            //errbacks should not be called for failures in\n                            //their callbacks (#699). However if a global\n                            //onError is set, use that.\n                            if ((this.events.error && this.map.isDefine) ||\n                                req.onError !== defaultOnError) {\n                                try {\n                                    exports = context.execCb(id, factory, depExports, exports);\n                                } catch (e) {\n                                    err = e;\n                                }\n                            } else {\n                                exports = context.execCb(id, factory, depExports, exports);\n                            }\n\n                            // Favor return value over exports. If node/cjs in play,\n                            // then will not have a return value anyway. Favor\n                            // module.exports assignment over exports object.\n                            if (this.map.isDefine && exports === undefined) {\n                                cjsModule = this.module;\n                                if (cjsModule) {\n                                    exports = cjsModule.exports;\n                                } else if (this.usingExports) {\n                                    //exports already set the defined value.\n                                    exports = this.exports;\n                                }\n                            }\n\n                            if (err) {\n                                err.requireMap = this.map;\n                                err.requireModules = this.map.isDefine ? [this.map.id] : null;\n                                err.requireType = this.map.isDefine ? 'define' : 'require';\n                                return onError((this.error = err));\n                            }\n\n                        } else {\n                            //Just a literal value\n                            exports = factory;\n                        }\n\n                        this.exports = exports;\n\n                        if (this.map.isDefine && !this.ignore) {\n                            defined[id] = exports;\n\n                            if (req.onResourceLoad) {\n                                req.onResourceLoad(context, this.map, this.depMaps);\n                            }\n                        }\n\n                        //Clean up\n                        cleanRegistry(id);\n\n                        this.defined = true;\n                    }\n\n                    //Finished the define stage. Allow calling check again\n                    //to allow define notifications below in the case of a\n                    //cycle.\n                    this.defining = false;\n\n                    if (this.defined && !this.defineEmitted) {\n                        this.defineEmitted = true;\n                        this.emit('defined', this.exports);\n                        this.defineEmitComplete = true;\n                    }\n\n                }\n            },\n\n            callPlugin: function () {\n                var map = this.map,\n                    id = map.id,\n                    //Map already normalized the prefix.\n                    pluginMap = makeModuleMap(map.prefix);\n\n                //Mark this as a dependency for this plugin, so it\n                //can be traced for cycles.\n                this.depMaps.push(pluginMap);\n\n                on(pluginMap, 'defined', bind(this, function (plugin) {\n                    var load, normalizedMap, normalizedMod,\n                        bundleId = getOwn(bundlesMap, this.map.id),\n                        name = this.map.name,\n                        parentName = this.map.parentMap ? this.map.parentMap.name : null,\n                        localRequire = context.makeRequire(map.parentMap, {\n                            enableBuildCallback: true\n                        });\n\n                    //If current map is not normalized, wait for that\n                    //normalized name to load instead of continuing.\n                    if (this.map.unnormalized) {\n                        //Normalize the ID if the plugin allows it.\n                        if (plugin.normalize) {\n                            name = plugin.normalize(name, function (name) {\n                                return normalize(name, parentName, true);\n                            }) || '';\n                        }\n\n                        //prefix and name should already be normalized, no need\n                        //for applying map config again either.\n                        normalizedMap = makeModuleMap(map.prefix + '!' + name,\n                                                      this.map.parentMap);\n                        on(normalizedMap,\n                            'defined', bind(this, function (value) {\n                                this.init([], function () { return value; }, null, {\n                                    enabled: true,\n                                    ignore: true\n                                });\n                            }));\n\n                        normalizedMod = getOwn(registry, normalizedMap.id);\n                        if (normalizedMod) {\n                            //Mark this as a dependency for this plugin, so it\n                            //can be traced for cycles.\n                            this.depMaps.push(normalizedMap);\n\n                            if (this.events.error) {\n                                normalizedMod.on('error', bind(this, function (err) {\n                                    this.emit('error', err);\n                                }));\n                            }\n                            normalizedMod.enable();\n                        }\n\n                        return;\n                    }\n\n                    //If a paths config, then just load that file instead to\n                    //resolve the plugin, as it is built into that paths layer.\n                    if (bundleId) {\n                        this.map.url = context.nameToUrl(bundleId);\n                        this.load();\n                        return;\n                    }\n\n                    load = bind(this, function (value) {\n                        this.init([], function () { return value; }, null, {\n                            enabled: true\n                        });\n                    });\n\n                    load.error = bind(this, function (err) {\n                        this.inited = true;\n                        this.error = err;\n                        err.requireModules = [id];\n\n                        //Remove temp unnormalized modules for this module,\n                        //since they will never be resolved otherwise now.\n                        eachProp(registry, function (mod) {\n                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {\n                                cleanRegistry(mod.map.id);\n                            }\n                        });\n\n                        onError(err);\n                    });\n\n                    //Allow plugins to load other code without having to know the\n                    //context or how to 'complete' the load.\n                    load.fromText = bind(this, function (text, textAlt) {\n                        /*jslint evil: true */\n                        var moduleName = map.name,\n                            moduleMap = makeModuleMap(moduleName),\n                            hasInteractive = useInteractive;\n\n                        //As of 2.1.0, support just passing the text, to reinforce\n                        //fromText only being called once per resource. Still\n                        //support old style of passing moduleName but discard\n                        //that moduleName in favor of the internal ref.\n                        if (textAlt) {\n                            text = textAlt;\n                        }\n\n                        //Turn off interactive script matching for IE for any define\n                        //calls in the text, then turn it back on at the end.\n                        if (hasInteractive) {\n                            useInteractive = false;\n                        }\n\n                        //Prime the system by creating a module instance for\n                        //it.\n                        getModule(moduleMap);\n\n                        //Transfer any config to this other module.\n                        if (hasProp(config.config, id)) {\n                            config.config[moduleName] = config.config[id];\n                        }\n\n                        try {\n                            req.exec(text);\n                        } catch (e) {\n                            return onError(makeError('fromtexteval',\n                                             'fromText eval for ' + id +\n                                            ' failed: ' + e,\n                                             e,\n                                             [id]));\n                        }\n\n                        if (hasInteractive) {\n                            useInteractive = true;\n                        }\n\n                        //Mark this as a dependency for the plugin\n                        //resource\n                        this.depMaps.push(moduleMap);\n\n                        //Support anonymous modules.\n                        context.completeLoad(moduleName);\n\n                        //Bind the value of that module to the value for this\n                        //resource ID.\n                        localRequire([moduleName], load);\n                    });\n\n                    //Use parentName here since the plugin's name is not reliable,\n                    //could be some weird string with no path that actually wants to\n                    //reference the parentName's path.\n                    plugin.load(map.name, localRequire, load, config);\n                }));\n\n                context.enable(pluginMap, this);\n                this.pluginMaps[pluginMap.id] = pluginMap;\n            },\n\n            enable: function () {\n                enabledRegistry[this.map.id] = this;\n                this.enabled = true;\n\n                //Set flag mentioning that the module is enabling,\n                //so that immediate calls to the defined callbacks\n                //for dependencies do not trigger inadvertent load\n                //with the depCount still being zero.\n                this.enabling = true;\n\n                //Enable each dependency\n                each(this.depMaps, bind(this, function (depMap, i) {\n                    var id, mod, handler;\n\n                    if (typeof depMap === 'string') {\n                        //Dependency needs to be converted to a depMap\n                        //and wired up to this module.\n                        depMap = makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false,\n                                               !this.skipMap);\n                        this.depMaps[i] = depMap;\n\n                        handler = getOwn(handlers, depMap.id);\n\n                        if (handler) {\n                            this.depExports[i] = handler(this);\n                            return;\n                        }\n\n                        this.depCount += 1;\n\n                        on(depMap, 'defined', bind(this, function (depExports) {\n                            this.defineDep(i, depExports);\n                            this.check();\n                        }));\n\n                        if (this.errback) {\n                            on(depMap, 'error', bind(this, this.errback));\n                        }\n                    }\n\n                    id = depMap.id;\n                    mod = registry[id];\n\n                    //Skip special modules like 'require', 'exports', 'module'\n                    //Also, don't call enable if it is already enabled,\n                    //important in circular dependency cases.\n                    if (!hasProp(handlers, id) && mod && !mod.enabled) {\n                        context.enable(depMap, this);\n                    }\n                }));\n\n                //Enable each plugin that is used in\n                //a dependency\n                eachProp(this.pluginMaps, bind(this, function (pluginMap) {\n                    var mod = getOwn(registry, pluginMap.id);\n                    if (mod && !mod.enabled) {\n                        context.enable(pluginMap, this);\n                    }\n                }));\n\n                this.enabling = false;\n\n                this.check();\n            },\n\n            on: function (name, cb) {\n                var cbs = this.events[name];\n                if (!cbs) {\n                    cbs = this.events[name] = [];\n                }\n                cbs.push(cb);\n            },\n\n            emit: function (name, evt) {\n                each(this.events[name], function (cb) {\n                    cb(evt);\n                });\n                if (name === 'error') {\n                    //Now that the error handler was triggered, remove\n                    //the listeners, since this broken Module instance\n                    //can stay around for a while in the registry.\n                    delete this.events[name];\n                }\n            }\n        };\n\n        function callGetModule(args) {\n            //Skip modules already defined.\n            if (!hasProp(defined, args[0])) {\n                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);\n            }\n        }\n\n        function removeListener(node, func, name, ieName) {\n            //Favor detachEvent because of IE9\n            //issue, see attachEvent/addEventListener comment elsewhere\n            //in this file.\n            if (node.detachEvent && !isOpera) {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                if (ieName) {\n                    node.detachEvent(ieName, func);\n                }\n            } else {\n                node.removeEventListener(name, func, false);\n            }\n        }\n\n        /**\n         * Given an event from a script node, get the requirejs info from it,\n         * and then removes the event listeners on the node.\n         * @param {Event} evt\n         * @returns {Object}\n         */\n        function getScriptData(evt) {\n            //Using currentTarget instead of target for Firefox 2.0's sake. Not\n            //all old browsers will be supported, but this one was easy enough\n            //to support and still makes sense.\n            var node = evt.currentTarget || evt.srcElement;\n\n            //Remove the listeners once here.\n            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');\n            removeListener(node, context.onScriptError, 'error');\n\n            return {\n                node: node,\n                id: node && node.getAttribute('data-requiremodule')\n            };\n        }\n\n        function intakeDefines() {\n            var args;\n\n            //Any defined modules in the global queue, intake them now.\n            takeGlobalQueue();\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));\n                } else {\n                    //args are id, deps, factory. Should be normalized by the\n                    //define() function.\n                    callGetModule(args);\n                }\n            }\n        }\n\n        context = {\n            config: config,\n            contextName: contextName,\n            registry: registry,\n            defined: defined,\n            urlFetched: urlFetched,\n            defQueue: defQueue,\n            Module: Module,\n            makeModuleMap: makeModuleMap,\n            nextTick: req.nextTick,\n            onError: onError,\n\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {\n                        cfg.baseUrl += '/';\n                    }\n                }\n\n                //Save off the paths since they require special processing,\n                //they are additive.\n                var shim = config.shim,\n                    objs = {\n                        paths: true,\n                        bundles: true,\n                        config: true,\n                        map: true\n                    };\n\n                eachProp(cfg, function (value, prop) {\n                    if (objs[prop]) {\n                        if (!config[prop]) {\n                            config[prop] = {};\n                        }\n                        mixin(config[prop], value, true, true);\n                    } else {\n                        config[prop] = value;\n                    }\n                });\n\n                //Reverse map the bundles\n                if (cfg.bundles) {\n                    eachProp(cfg.bundles, function (value, prop) {\n                        each(value, function (v) {\n                            if (v !== prop) {\n                                bundlesMap[v] = prop;\n                            }\n                        });\n                    });\n                }\n\n                //Merge shim\n                if (cfg.shim) {\n                    eachProp(cfg.shim, function (value, id) {\n                        //Normalize the structure\n                        if (isArray(value)) {\n                            value = {\n                                deps: value\n                            };\n                        }\n                        if ((value.exports || value.init) && !value.exportsFn) {\n                            value.exportsFn = context.makeShimExports(value);\n                        }\n                        shim[id] = value;\n                    });\n                    config.shim = shim;\n                }\n\n                //Adjust packages if necessary.\n                if (cfg.packages) {\n                    each(cfg.packages, function (pkgObj) {\n                        var location, name;\n\n                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\n\n                        name = pkgObj.name;\n                        location = pkgObj.location;\n                        if (location) {\n                            config.paths[name] = pkgObj.location;\n                        }\n\n                        //Save pointer to main module ID for pkg name.\n                        //Remove leading dot in main, so main paths are normalized,\n                        //and remove any trailing .js, since different package\n                        //envs have different conventions: some use a module name,\n                        //some use a file name.\n                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\n                                     .replace(currDirRegExp, '')\n                                     .replace(jsSuffixRegExp, '');\n                    });\n                }\n\n                //If there are any \"waiting to execute\" modules in the registry,\n                //update the maps for them, since their info, like URLs to load,\n                //may have changed.\n                eachProp(registry, function (mod, id) {\n                    //If module already has init called, since it is too\n                    //late to modify them, and ignore unnormalized ones\n                    //since they are transient.\n                    if (!mod.inited && !mod.map.unnormalized) {\n                        mod.map = makeModuleMap(id);\n                    }\n                });\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n            },\n\n            makeShimExports: function (value) {\n                function fn() {\n                    var ret;\n                    if (value.init) {\n                        ret = value.init.apply(global, arguments);\n                    }\n                    return ret || (value.exports && getGlobal(value.exports));\n                }\n                return fn;\n            },\n\n            makeRequire: function (relMap, options) {\n                options = options || {};\n\n                function localRequire(deps, callback, errback) {\n                    var id, map, requireMod;\n\n                    if (options.enableBuildCallback && callback && isFunction(callback)) {\n                        callback.__requireJsBuild = true;\n                    }\n\n                    if (typeof deps === 'string') {\n                        if (isFunction(callback)) {\n                            //Invalid call\n                            return onError(makeError('requireargs', 'Invalid require call'), errback);\n                        }\n\n                        //If require|exports|module are requested, get the\n                        //value for them from the special handlers. Caveat:\n                        //this only works while module is being defined.\n                        if (relMap && hasProp(handlers, deps)) {\n                            return handlers[deps](registry[relMap.id]);\n                        }\n\n                        //Synchronous access to one module. If require.get is\n                        //available (as in the Node adapter), prefer that.\n                        if (req.get) {\n                            return req.get(context, deps, relMap, localRequire);\n                        }\n\n                        //Normalize module name, if it contains . or ..\n                        map = makeModuleMap(deps, relMap, false, true);\n                        id = map.id;\n\n                        if (!hasProp(defined, id)) {\n                            return onError(makeError('notloaded', 'Module name \"' +\n                                        id +\n                                        '\" has not been loaded yet for context: ' +\n                                        contextName +\n                                        (relMap ? '' : '. Use require([])')));\n                        }\n                        return defined[id];\n                    }\n\n                    //Grab defines waiting in the global queue.\n                    intakeDefines();\n\n                    //Mark all the dependencies as needing to be loaded.\n                    context.nextTick(function () {\n                        //Some defines could have been added since the\n                        //require call, collect them.\n                        intakeDefines();\n\n                        requireMod = getModule(makeModuleMap(null, relMap));\n\n                        //Store if map config should be applied to this require\n                        //call for dependencies.\n                        requireMod.skipMap = options.skipMap;\n\n                        requireMod.init(deps, callback, errback, {\n                            enabled: true\n                        });\n\n                        checkLoaded();\n                    });\n\n                    return localRequire;\n                }\n\n                mixin(localRequire, {\n                    isBrowser: isBrowser,\n\n                    /**\n                     * Converts a module name + .extension into an URL path.\n                     * *Requires* the use of a module name. It does not support using\n                     * plain URLs like nameToUrl.\n                     */\n                    toUrl: function (moduleNamePlusExt) {\n                        var ext,\n                            index = moduleNamePlusExt.lastIndexOf('.'),\n                            segment = moduleNamePlusExt.split('/')[0],\n                            isRelative = segment === '.' || segment === '..';\n\n                        //Have a file extension alias, and it is not the\n                        //dots from a relative path.\n                        if (index !== -1 && (!isRelative || index > 1)) {\n                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                        }\n\n                        return context.nameToUrl(normalize(moduleNamePlusExt,\n                                                relMap && relMap.id, true), ext,  true);\n                    },\n\n                    defined: function (id) {\n                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);\n                    },\n\n                    specified: function (id) {\n                        id = makeModuleMap(id, relMap, false, true).id;\n                        return hasProp(defined, id) || hasProp(registry, id);\n                    }\n                });\n\n                //Only allow undef on top level require calls\n                if (!relMap) {\n                    localRequire.undef = function (id) {\n                        //Bind any waiting define() calls to this context,\n                        //fix for #408\n                        takeGlobalQueue();\n\n                        var map = makeModuleMap(id, relMap, true),\n                            mod = getOwn(registry, id);\n\n                        removeScript(id);\n\n                        delete defined[id];\n                        delete urlFetched[map.url];\n                        delete undefEvents[id];\n\n                        //Clean queued defines too. Go backwards\n                        //in array so that the splices do not\n                        //mess up the iteration.\n                        eachReverse(defQueue, function(args, i) {\n                            if(args[0] === id) {\n                                defQueue.splice(i, 1);\n                            }\n                        });\n\n                        if (mod) {\n                            //Hold on to listeners in case the\n                            //module will be attempted to be reloaded\n                            //using a different config.\n                            if (mod.events.defined) {\n                                undefEvents[id] = mod.events;\n                            }\n\n                            cleanRegistry(id);\n                        }\n                    };\n                }\n\n                return localRequire;\n            },\n\n            /**\n             * Called to enable a module if it is still in the registry\n             * awaiting enablement. A second arg, parent, the parent module,\n             * is passed in for context, when this method is overridden by\n             * the optimizer. Not shown here to keep code compact.\n             */\n            enable: function (depMap) {\n                var mod = getOwn(registry, depMap.id);\n                if (mod) {\n                    getModule(depMap).enable();\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var found, args, mod,\n                    shim = getOwn(config.shim, moduleName) || {},\n                    shExports = shim.exports;\n\n                takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        //If already found an anonymous module and bound it\n                        //to this name, then this is some other anon module\n                        //waiting for its completeLoad to fire.\n                        if (found) {\n                            break;\n                        }\n                        found = true;\n                    } else if (args[0] === moduleName) {\n                        //Found matching define call for this script!\n                        found = true;\n                    }\n\n                    callGetModule(args);\n                }\n\n                //Do this after the cycle of callGetModule in case the result\n                //of those calls/init calls changes the registry.\n                mod = getOwn(registry, moduleName);\n\n                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {\n                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {\n                        if (hasPathFallback(moduleName)) {\n                            return;\n                        } else {\n                            return onError(makeError('nodefine',\n                                             'No define call for ' + moduleName,\n                                             null,\n                                             [moduleName]));\n                        }\n                    } else {\n                        //A script that does not call define(), so just simulate\n                        //the call for it.\n                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);\n                    }\n                }\n\n                checkLoaded();\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             * Note that it **does not** call normalize on the moduleName,\n             * it is assumed to have already been normalized. This is an\n             * internal API, not a public one. Use toUrl for the public API.\n             */\n            nameToUrl: function (moduleName, ext, skipExt) {\n                var paths, syms, i, parentModule, url,\n                    parentPath, bundleId,\n                    pkgMain = getOwn(config.pkgs, moduleName);\n\n                if (pkgMain) {\n                    moduleName = pkgMain;\n                }\n\n                bundleId = getOwn(bundlesMap, moduleName);\n\n                if (bundleId) {\n                    return context.nameToUrl(bundleId, ext, skipExt);\n                }\n\n                //If a colon is in the URL, it indicates a protocol is used and it is just\n                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)\n                //or ends with .js, then assume the user meant to use an url and not a module id.\n                //The slash is important for protocol-less URLs as well as full paths.\n                if (req.jsExtRegExp.test(moduleName)) {\n                    //Just a plain path, not module name lookup, so just return it.\n                    //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                    //an extension, this method probably needs to be reworked.\n                    url = moduleName + (ext || '');\n                } else {\n                    //A module that needs to be converted to a path.\n                    paths = config.paths;\n\n                    syms = moduleName.split('/');\n                    //For each module name segment, see if there is a path\n                    //registered for it. Start with most specific name\n                    //and work up from it.\n                    for (i = syms.length; i > 0; i -= 1) {\n                        parentModule = syms.slice(0, i).join('/');\n\n                        parentPath = getOwn(paths, parentModule);\n                        if (parentPath) {\n                            //If an array, it means there are a few choices,\n                            //Choose the one that is desired\n                            if (isArray(parentPath)) {\n                                parentPath = parentPath[0];\n                            }\n                            syms.splice(0, i, parentPath);\n                            break;\n                        }\n                    }\n\n                    //Join the path parts together, then figure out if baseUrl is needed.\n                    url = syms.join('/');\n                    url += (ext || (/^data\\:|\\?/.test(url) || skipExt ? '' : '.js'));\n                    url = (url.charAt(0) === '/' || url.match(/^[\\w\\+\\.\\-]+:/) ? '' : config.baseUrl) + url;\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\n                                         config.urlArgs) : url;\n            },\n\n            //Delegates to req.load. Broken out as a separate function to\n            //allow overriding in the optimizer.\n            load: function (id, url) {\n                req.load(context, id, url);\n            },\n\n            /**\n             * Executes a module callback function. Broken out as a separate function\n             * solely to allow the build system to sequence the files in the built\n             * layer in the right sequence.\n             *\n             * @private\n             */\n            execCb: function (name, callback, args, exports) {\n                return callback.apply(exports, args);\n            },\n\n            /**\n             * callback for script loads, used to check status of loading.\n             *\n             * @param {Event} evt the event from the browser for the script\n             * that was loaded.\n             */\n            onScriptLoad: function (evt) {\n                //Using currentTarget instead of target for Firefox 2.0's sake. Not\n                //all old browsers will be supported, but this one was easy enough\n                //to support and still makes sense.\n                if (evt.type === 'load' ||\n                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {\n                    //Reset interactive script so a script node is not held onto for\n                    //to long.\n                    interactiveScript = null;\n\n                    //Pull out the name of the module and the context.\n                    var data = getScriptData(evt);\n                    context.completeLoad(data.id);\n                }\n            },\n\n            /**\n             * Callback for script errors.\n             */\n            onScriptError: function (evt) {\n                var data = getScriptData(evt);\n                if (!hasPathFallback(data.id)) {\n                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));\n                }\n            }\n        };\n\n        context.require = context.makeRequire();\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = getOwn(contexts, contextName);\n        if (!context) {\n            context = contexts[contextName] = req.s.newContext(contextName);\n        }\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback, errback);\n    };\n\n    /**\n     * Support require.config() to make it easier to cooperate with other\n     * AMD loaders on globally agreed names.\n     */\n    req.config = function (config) {\n        return req(config);\n    };\n\n    /**\n     * Execute something after the current tick\n     * of the event loop. Override for other envs\n     * that have a better solution than setTimeout.\n     * @param  {Function} fn function to execute later.\n     */\n    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n        setTimeout(fn, 4);\n    } : function (fn) { fn(); };\n\n    /**\n     * Export require as a global, but only if it does not already exist.\n     */\n    if (!require) {\n        require = req;\n    }\n\n    req.version = version;\n\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    req.isBrowser = isBrowser;\n    s = req.s = {\n        contexts: contexts,\n        newContext: newContext\n    };\n\n    //Create default context.\n    req({});\n\n    //Exports some context-sensitive methods on global require.\n    each([\n        'toUrl',\n        'undef',\n        'defined',\n        'specified'\n    ], function (prop) {\n        //Reference from contexts instead of early binding to default context,\n        //so that during builds, the latest instance of the default context\n        //with its config gets used.\n        req[prop] = function () {\n            var ctx = contexts[defContextName];\n            return ctx.require[prop].apply(ctx, arguments);\n        };\n    });\n\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName('head')[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName('base')[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = defaultOnError;\n\n    /**\n     * Creates the node for the load command. Only used in browser envs.\n     */\n    req.createNode = function (config, moduleName, url) {\n        var node = config.xhtml ?\n                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :\n                document.createElement('script');\n        node.type = config.scriptType || 'text/javascript';\n        node.charset = 'utf-8';\n        node.async = true;\n        return node;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var config = (context && context.config) || {},\n            node;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            node = req.createNode(config, moduleName, url);\n\n            node.setAttribute('data-requirecontext', context.contextName);\n            node.setAttribute('data-requiremodule', moduleName);\n\n            //Set up load listener. Test attachEvent first because IE9 has\n            //a subtle issue in its addEventListener and script onload firings\n            //that do not match the behavior of all other browsers with\n            //addEventListener support, which fire the onload event for a\n            //script right after the script execution. See:\n            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n            //UNFORTUNATELY Opera implements attachEvent but does not follow the script\n            //script execution mode.\n            if (node.attachEvent &&\n                    //Check if node.attachEvent is artificially added by custom script or\n                    //natively supported by browser\n                    //read https://github.com/jrburke/requirejs/issues/187\n                    //if we can NOT find [native code] then it must NOT natively supported.\n                    //in IE8, node.attachEvent does not have toString()\n                    //Note the test for \"[native code\" with no closing brace, see:\n                    //https://github.com/jrburke/requirejs/issues/273\n                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n                    !isOpera) {\n                //Probably IE. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous define call to a name.\n                //However, IE reports the script as being in 'interactive'\n                //readyState at the time of the define call.\n                useInteractive = true;\n\n                node.attachEvent('onreadystatechange', context.onScriptLoad);\n                //It would be great to add an error handler here to catch\n                //404s in IE9+. However, onreadystatechange will fire before\n                //the error handler, so that does not help. If addEventListener\n                //is used, then IE will fire error before load, but we cannot\n                //use that pathway given the connect.microsoft.com issue\n                //mentioned above about not doing the 'script execute,\n                //then fire the script load event listener before execute\n                //next script' that other browsers do.\n                //Best hope: IE10 fixes the issues,\n                //and then destroys all installs of IE 6-9.\n                //node.attachEvent('onerror', context.onScriptError);\n            } else {\n                node.addEventListener('load', context.onScriptLoad, false);\n                node.addEventListener('error', context.onScriptError, false);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous define\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n\n            return node;\n        } else if (isWebWorker) {\n            try {\n                //In a web worker, use importScripts. This is not a very\n                //efficient use of importScripts, importScripts will block until\n                //its script is downloaded and evaluated. However, if web workers\n                //are in play, the expectation that a build has been done so that\n                //only one script needs to be loaded anyway. This may need to be\n                //reevaluated if other use cases become common.\n                importScripts(url);\n\n                //Account for anonymous modules\n                context.completeLoad(moduleName);\n            } catch (e) {\n                context.onError(makeError('importscripts',\n                                'importScripts failed for ' +\n                                    moduleName + ' at ' + url,\n                                e,\n                                [moduleName]));\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        eachReverse(scripts(), function (script) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        });\n        return interactiveScript;\n    }\n\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\n    if (isBrowser && !cfg.skipDataMain) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        eachReverse(scripts(), function (script) {\n            //Set the 'head' where we can append children by\n            //using the script's parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load. If it is there, the path to data main becomes the\n            //baseUrl, if it is not already set.\n            dataMain = script.getAttribute('data-main');\n            if (dataMain) {\n                //Preserve dataMain in case it is a path (i.e. contains '?')\n                mainScript = dataMain;\n\n                //Set final baseUrl if there is not already an explicit one.\n                if (!cfg.baseUrl) {\n                    //Pull off the directory of data-main for use as the\n                    //baseUrl.\n                    src = mainScript.split('/');\n                    mainScript = src.pop();\n                    subPath = src.length ? src.join('/')  + '/' : './';\n\n                    cfg.baseUrl = subPath;\n                }\n\n                //Strip off any trailing .js since mainScript is now\n                //like a module name.\n                mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n                 //If mainScript is still a path, fall back to dataMain\n                if (req.jsExtRegExp.test(mainScript)) {\n                    mainScript = dataMain;\n                }\n\n                //Put the data-main script in the files to load.\n                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n                return true;\n            }\n        });\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument's\n     * name.\n     */\n    define = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous modules\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps && isFunction(callback)) {\n            deps = [];\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, '')\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute('data-requiremodule');\n                }\n                context = contexts[node.getAttribute('data-requirecontext')];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n\n\n    /**\n     * Executes the text. Normally just uses eval, but can be modified\n     * to use a better, environment-specific call. Only used for transpiling\n     * loader plugins, not for plain JS modules.\n     * @param {String} text the text to execute/evaluate.\n     */\n    req.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n}(this));\n\ndefine(\"node_modules/requirejs/require\", function(){});\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('util/assert',[],function () {\r\n\t\"use strict\";\r\n\r\n\tvar assert = function (cond, msg) {\r\n\t\tif( !cond ) {\r\n\t\t\tvar error = new Error(msg || \"ASSERT failed\");\r\n\r\n\t\t\tconsole.log(\"Throwing\", error.stack);\r\n\t\t\tconsole.log();\r\n\t\t\t\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t};\r\n\r\n\treturn assert;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Robert Kereskenyi\r\n */\r\n\"use strict\";\r\n\r\n/*\r\n * -------- EVENT DIASPATCHER -------\r\n */\r\n\r\ndefine('eventDispatcher',[], function () {\r\n    var EventDispatcher = function () {\r\n        this._eventList = {};\r\n    };\r\n\r\n    EventDispatcher.prototype = {\r\n        _eventList: null,\r\n        _getEvent: function (eventName, create) {\r\n            // Check if Array of Event Handlers has been created\r\n            if (!this._eventList[eventName]) {\r\n\r\n                // Check if the calling method wants to create the Array\r\n                // if not created. This reduces unneeded memory usage.\r\n                if (!create) {\r\n                    return null;\r\n                }\r\n\r\n                // Create the Array of Event Handlers\r\n                this._eventList[eventName] = [];\r\n                // new Array\r\n            }\r\n\r\n            // return the Array of Event Handlers already added\r\n            return this._eventList[eventName];\r\n        },\r\n        addEventListener: function (eventName, handler) {\r\n            // Get the Array of Event Handlers\r\n            var evt = this._getEvent(eventName, true);\r\n\r\n            // Add the new Event Handler to the Array\r\n            evt.push(handler);\r\n        },\r\n        removeEventListener: function (eventName, handler) {\r\n            // Get the Array of Event Handlers\r\n            var evt = this._getEvent(eventName);\r\n\r\n            if (!evt) {\r\n                return;\r\n            }\r\n\r\n            // Helper Method - an Array.indexOf equivalent\r\n            var getArrayIndex = function (array, item) {\r\n                for (var i = 0; i < array.length; i++) {\r\n                    if (array[i] === item) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            };\r\n\r\n            // Get the Array index of the Event Handler\r\n            var index = getArrayIndex(evt, handler);\r\n\r\n            if (index > -1) {\r\n                // Remove Event Handler from Array\r\n                evt.splice(index, 1);\r\n            }\r\n        },\r\n        removeAllEventListeners: function (eventName) {\r\n            // Get the Array of Event Handlers\r\n            var evt = this._getEvent(eventName);\r\n\r\n            if (!evt) {\r\n                return;\r\n            }\r\n\r\n            evt.splice(0, evt.length);\r\n        },\r\n        dispatchEvent: function (eventName, eventArgs) {\r\n            // Get a function that will call all the Event Handlers internally\r\n            var handler = this._getEventHandler(eventName);\r\n            if (handler) {\r\n                // call the handler function\r\n                // Pass in \"sender\" and \"eventArgs\" parameters\r\n                handler(this, eventArgs);\r\n            }\r\n        },\r\n        _getEventHandler: function (eventName) {\r\n            // Get Event Handler Array for this Event\r\n            var evt = this._getEvent(eventName, false);\r\n            if (!evt || evt.length === 0) {\r\n                return null;\r\n            }\r\n\r\n            // Create the Handler method that will use currying to\r\n            // call all the Events Handlers internally\r\n            var h = function (sender, args) {\r\n                for (var i = 0; i < evt.length; i++) {\r\n                    evt[i](sender, args);\r\n                }\r\n            };\r\n\r\n            // Return this new Handler method\r\n            return h;\r\n        }\r\n    };\r\n\r\n    return EventDispatcher;\r\n});\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('util/guid',[],function () {\r\n\t\"use strict\";\r\n\r\n\tvar guid = function () {\r\n\t\tvar S4 = function () {\r\n                return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n            };\r\n\r\n            //return GUID\r\n            return (S4() + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + \"-\" + S4() + S4() + S4());\r\n\t};\r\n\r\n\treturn guid;\r\n});\n",
    "//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/\r\ndefine('util/sha1',[],function() {\r\nreturn function(l){function p(b,a){return b<<a|b>>>32-a}l+=\"\";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i=\"\";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};\r\n});\r\n\n",
    "define('util/zssha1',[],function(){\r\n    function SHA1() {\r\n\r\n        this.pp = function (b, a) {\r\n            return b << a | b >>> 32 - a\r\n        };\r\n\r\n        this.oo = function (l, a, k, b, c) {\r\n            try{\r\n                return l.charCodeAt(a * 64 + k * 4 + b) << c\r\n            } catch(e){}\r\n        };\r\n\r\n        this.getHash = function(l) {\r\n\r\n            l += \"\";\r\n            for (var n = Math, c = [1518500249, 1859775393, 2400959708, 3395469782, 1732584193, 4023233417, 2562383102, 271733878, 3285377520, 4294967295], s = n.ceil(l.length / 4) + 2, q = n.ceil(s / 16), g = [], a = 0, h = [], j, d, e, f, m, i, b, k; a < q; a++) {\r\n                g[a] = [];\r\n                for (k = 0; k < 16; k++) {\r\n                    g[a][k] = this.oo(l, a, k, 0, 24) | this.oo(l, a, k, 1, 16) | this.oo(l, a, k, 2, 8) | this.oo(l, a, k, 3, 0)\r\n                }\r\n            }\r\n            i = l.length * 8 - 8;\r\n            a = q - 1;\r\n            g[a][14] = i / (c[9] + 1);\r\n            g[a][14] = n.floor(g[a][14]);\r\n            g[a][15] = i & c[9];\r\n            for (a = 0; a < q; a++) {\r\n                for (b = 0; b < 16; b++)h[b] = g[a][b];\r\n                for (b = 16; b < 80; b++)h[b] = this.pp(h[b - 3] ^ h[b - 8] ^ h[b - 14] ^ h[b - 16], 1);\r\n                j = c[4];\r\n                d = c[5];\r\n                e = c[6];\r\n                f = c[7];\r\n                m = c[8];\r\n                for (b = 0; b < 80; b++) {\r\n                    var r = n.floor(b / 20), t = this.pp(j, 5) + (r < 1 ? d & e ^ ~d & f : r == 2 ? d & e ^ d & f ^ e & f : d ^ e ^ f) + m + c[r] + h[b] & c[9];\r\n                    m = f;\r\n                    f = e;\r\n                    e = this.pp(d, 30);\r\n                    d = j;\r\n                    j = t\r\n                }\r\n                c[4] += j;\r\n                c[5] += d;\r\n                c[6] += e;\r\n                c[7] += f;\r\n                c[8] += m\r\n            }\r\n            i = \"\";\r\n            for (z = 4; z < 9; z++)\r\n                for (a = 7; a >= 0; a--)\r\n                    i += ((c[z] & c[9]) >>> a * 4 & 15).toString(16);\r\n            return i\r\n        };\r\n    }\r\n\r\n    return SHA1;\r\n});\r\n\n",
    "/* 2012 David Chambers <dc@hashify.me>  */\r\ndefine('util/canon',[], function() {\r\n    var CANON = {},\r\n        keys, map, nativeMap, pad,\r\n        __slice = [].slice,\r\n        __hasProp = {}.hasOwnProperty;\r\n\r\n\r\n    CANON.stringify = (function() {\r\n        var canonicalize;\r\n        canonicalize = function(value) {\r\n            var pair, _ref;\r\n            switch (Object.prototype.toString.call(value)) {\r\n                case '[object Array]':\r\n                    return ['Array'].concat(__slice.call(map(value, canonicalize)));\r\n                case '[object Date]':\r\n                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);\r\n                case '[object Function]':\r\n                    throw new TypeError('functions cannot be serialized');\r\n                    break;\r\n                case '[object Number]':\r\n                    if (isFinite(value)) {\r\n                        return value;\r\n                    } else {\r\n                        return ['Number', \"\" + value];\r\n                    }\r\n                    break;\r\n                case '[object Object]':\r\n                    pair = function(key) {\r\n                        return [key, canonicalize(value[key])];\r\n                    };\r\n                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));\r\n                case '[object RegExp]':\r\n                    return ['RegExp', \"\" + value];\r\n                case '[object Undefined]':\r\n                    return ['Undefined'];\r\n                default:\r\n                    return value;\r\n            }\r\n        };\r\n        return function(value) {\r\n            return JSON.stringify(canonicalize(value));\r\n        };\r\n    })();\r\n\r\n    CANON.parse = (function() {\r\n        var canonicalize;\r\n        canonicalize = function(value) {\r\n            var element, elements, idx, object, what, _i, _ref;\r\n            if (Object.prototype.toString.call(value) !== '[object Array]') {\r\n                return value;\r\n            }\r\n            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];\r\n            element = elements[0];\r\n            switch (what) {\r\n                case 'Array':\r\n                    return map(elements, canonicalize);\r\n                case 'Date':\r\n                    return new Date(element);\r\n                case 'Number':\r\n                    return +element;\r\n                case 'Object':\r\n                    object = {};\r\n                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {\r\n                        object[elements[idx]] = canonicalize(elements[idx + 1]);\r\n                    }\r\n                    return object;\r\n                case 'RegExp':\r\n                    return (function(func, args, ctor) {\r\n                        ctor.prototype = func.prototype;\r\n                        var child = new ctor, result = func.apply(child, args);\r\n                        return Object(result) === result ? result : child;\r\n                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});\r\n                case 'Undefined':\r\n                    return void 0;\r\n                default:\r\n                    throw new Error('invalid input');\r\n            }\r\n        };\r\n        return function(string) {\r\n            return canonicalize(JSON.parse(string));\r\n        };\r\n    })();\r\n\r\n    nativeMap = Array.prototype.map;\r\n\r\n    map = function(array, iterator) {\r\n        var el, _i, _len, _results;\r\n        if (nativeMap && array.map === nativeMap) {\r\n            return array.map(iterator);\r\n        } else {\r\n            _results = [];\r\n            for (_i = 0, _len = array.length; _i < _len; _i++) {\r\n                el = array[_i];\r\n                _results.push(iterator(el));\r\n            }\r\n            return _results;\r\n        }\r\n    };\r\n\r\n    keys = Object.keys || function(object) {\r\n        var key, _results;\r\n        _results = [];\r\n        for (key in object) {\r\n            if (!__hasProp.call(object, key)) continue;\r\n            _results.push(key);\r\n        }\r\n        return _results;\r\n    };\r\n\r\n    pad = function(n, min) {\r\n        if (min == null) {\r\n            min = 2;\r\n        }\r\n        return (\"\" + (1000 + n)).substr(4 - min);\r\n    };\r\n\r\n    return CANON;\r\n\r\n});\r\n\n",
    "/*\r\n The MIT License (MIT)\r\n\r\n Copyright (c) 2013 Artem S Vybornov\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining a copy of\r\n this software and associated documentation files (the \"Software\"), to deal in\r\n the Software without restriction, including without limitation the rights to\r\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\n the Software, and to permit persons to whom the Software is furnished to do so,\r\n subject to the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be included in all\r\n copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\n FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\n IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n */\r\n// source: https://github.com/vibornoff/asmcrypto.js\r\n// build have been modified to contain only SHA1 algorithm and file is modified to be includable with requirejs\r\n// kecso\r\ndefine('util/asmcryptosha1',[],function(){\r\n    (function(exports, global) {\r\n        global[\"asmCrypto\"] = exports;\r\n        function IllegalStateError() {\r\n            var err = Error.apply(this, arguments);\r\n            this.message = err.message, this.stack = err.stack;\r\n        }\r\n        IllegalStateError.prototype = Object.create(Error.prototype, {\r\n            name: {\r\n                value: \"IllegalStateError\"\r\n            }\r\n        });\r\n        function IllegalArgumentError() {\r\n            var err = Error.apply(this, arguments);\r\n            this.message = err.message, this.stack = err.stack;\r\n        }\r\n        IllegalArgumentError.prototype = Object.create(Error.prototype, {\r\n            name: {\r\n                value: \"IllegalArgumentError\"\r\n            }\r\n        });\r\n        function SecurityError() {\r\n            var err = Error.apply(this, arguments);\r\n            this.message = err.message, this.stack = err.stack;\r\n        }\r\n        SecurityError.prototype = Object.create(Error.prototype, {\r\n            name: {\r\n                value: \"SecurityError\"\r\n            }\r\n        });\r\n        \"use strict\";\r\n        var FloatArray = global.Float64Array || global.Float32Array;\r\n        function string_to_bytes(str) {\r\n            var len = str.length, arr = new Uint8Array(len);\r\n            for (var i = 0; i < len; i++) {\r\n                var c = str.charCodeAt(i);\r\n                if (c >>> 8) throw new Error(\"Wide characters are not allowed\");\r\n                arr[i] = c;\r\n            }\r\n            return arr;\r\n        }\r\n        function hex_to_bytes(str) {\r\n            var arr = [], len = str.length, i;\r\n            if (len & 1) {\r\n                str = \"0\" + str;\r\n                len++;\r\n            }\r\n            for (i = 0; i < len; i += 2) {\r\n                arr.push(parseInt(str.substr(i, 2), 16));\r\n            }\r\n            return new Uint8Array(arr);\r\n        }\r\n        function base64_to_bytes(str) {\r\n            return string_to_bytes(atob(str));\r\n        }\r\n        function bytes_to_string(arr) {\r\n            var str = \"\";\r\n            for (var i = 0; i < arr.length; i++) str += String.fromCharCode(arr[i]);\r\n            return str;\r\n        }\r\n        function bytes_to_hex(arr) {\r\n            var str = \"\";\r\n            for (var i = 0; i < arr.length; i++) {\r\n                var h = (arr[i] & 255).toString(16);\r\n                if (h.length < 2) str += \"0\";\r\n                str += h;\r\n            }\r\n            return str;\r\n        }\r\n        function bytes_to_base64(arr) {\r\n            return btoa(bytes_to_string(arr));\r\n        }\r\n        function pow2_ceil(a) {\r\n            a -= 1;\r\n            a |= a >>> 1;\r\n            a |= a >>> 2;\r\n            a |= a >>> 4;\r\n            a |= a >>> 8;\r\n            a |= a >>> 16;\r\n            a += 1;\r\n            return a;\r\n        }\r\n        function is_number(a) {\r\n            return typeof a === \"number\";\r\n        }\r\n        function is_string(a) {\r\n            return typeof a === \"string\";\r\n        }\r\n        function is_buffer(a) {\r\n            return a instanceof ArrayBuffer;\r\n        }\r\n        function is_bytes(a) {\r\n            return a instanceof Uint8Array;\r\n        }\r\n        function is_typed_array(a) {\r\n            return a instanceof Int8Array || a instanceof Uint8Array || a instanceof Int16Array || a instanceof Uint16Array || a instanceof Int32Array || a instanceof Uint32Array || a instanceof Float32Array || a instanceof Float64Array;\r\n        }\r\n        function _heap_init(constructor, options) {\r\n            var heap = options.heap, size = heap ? heap.byteLength : options.heapSize || 65536;\r\n            if (size & 4095 || size <= 0) throw new Error(\"heap size must be a positive integer and a multiple of 4096\");\r\n            heap = heap || new constructor(new ArrayBuffer(size));\r\n            return heap;\r\n        }\r\n        function _heap_write(heap, hpos, data, dpos, dlen) {\r\n            var hlen = heap.length - hpos, wlen = hlen < dlen ? hlen : dlen;\r\n            heap.set(data.subarray(dpos, dpos + wlen), hpos);\r\n            return wlen;\r\n        }\r\n        function hash_reset() {\r\n            this.result = null;\r\n            this.pos = 0;\r\n            this.len = 0;\r\n            this.asm.reset();\r\n            return this;\r\n        }\r\n        function hash_process(data) {\r\n            if (this.result !== null) throw new IllegalStateError(\"state must be reset before processing new data\");\r\n            if (is_string(data)) data = string_to_bytes(data);\r\n            if (is_buffer(data)) data = new Uint8Array(data);\r\n            if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\r\n            var asm = this.asm, heap = this.heap, hpos = this.pos, hlen = this.len, dpos = 0, dlen = data.length, wlen = 0;\r\n            while (dlen > 0) {\r\n                wlen = _heap_write(heap, hpos + hlen, data, dpos, dlen);\r\n                hlen += wlen;\r\n                dpos += wlen;\r\n                dlen -= wlen;\r\n                wlen = asm.process(hpos, hlen);\r\n                hpos += wlen;\r\n                hlen -= wlen;\r\n                if (!hlen) hpos = 0;\r\n            }\r\n            this.pos = hpos;\r\n            this.len = hlen;\r\n            return this;\r\n        }\r\n        function hash_finish() {\r\n            if (this.result !== null) throw new IllegalStateError(\"state must be reset before processing new data\");\r\n            this.asm.finish(this.pos, this.len, 0);\r\n            this.result = new Uint8Array(this.HASH_SIZE);\r\n            this.result.set(this.heap.subarray(0, this.HASH_SIZE));\r\n            this.pos = 0;\r\n            this.len = 0;\r\n            return this;\r\n        }\r\n        function sha1_asm(stdlib, foreign, buffer) {\r\n            \"use asm\";\r\n            var H0 = 0, H1 = 0, H2 = 0, H3 = 0, H4 = 0, TOTAL = 0;\r\n            var I0 = 0, I1 = 0, I2 = 0, I3 = 0, I4 = 0, O0 = 0, O1 = 0, O2 = 0, O3 = 0, O4 = 0;\r\n            var HEAP = new stdlib.Uint8Array(buffer);\r\n            function _core(w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15) {\r\n                w0 = w0 | 0;\r\n                w1 = w1 | 0;\r\n                w2 = w2 | 0;\r\n                w3 = w3 | 0;\r\n                w4 = w4 | 0;\r\n                w5 = w5 | 0;\r\n                w6 = w6 | 0;\r\n                w7 = w7 | 0;\r\n                w8 = w8 | 0;\r\n                w9 = w9 | 0;\r\n                w10 = w10 | 0;\r\n                w11 = w11 | 0;\r\n                w12 = w12 | 0;\r\n                w13 = w13 | 0;\r\n                w14 = w14 | 0;\r\n                w15 = w15 | 0;\r\n                var a = 0, b = 0, c = 0, d = 0, e = 0, n = 0, t = 0, w16 = 0, w17 = 0, w18 = 0, w19 = 0, w20 = 0, w21 = 0, w22 = 0, w23 = 0, w24 = 0, w25 = 0, w26 = 0, w27 = 0, w28 = 0, w29 = 0, w30 = 0, w31 = 0, w32 = 0, w33 = 0, w34 = 0, w35 = 0, w36 = 0, w37 = 0, w38 = 0, w39 = 0, w40 = 0, w41 = 0, w42 = 0, w43 = 0, w44 = 0, w45 = 0, w46 = 0, w47 = 0, w48 = 0, w49 = 0, w50 = 0, w51 = 0, w52 = 0, w53 = 0, w54 = 0, w55 = 0, w56 = 0, w57 = 0, w58 = 0, w59 = 0, w60 = 0, w61 = 0, w62 = 0, w63 = 0, w64 = 0, w65 = 0, w66 = 0, w67 = 0, w68 = 0, w69 = 0, w70 = 0, w71 = 0, w72 = 0, w73 = 0, w74 = 0, w75 = 0, w76 = 0, w77 = 0, w78 = 0, w79 = 0;\r\n                a = H0;\r\n                b = H1;\r\n                c = H2;\r\n                d = H3;\r\n                e = H4;\r\n                t = w0 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w1 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w2 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w3 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w4 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w5 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w6 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w7 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w8 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w9 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w10 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w11 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w12 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w13 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w14 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                t = w15 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w13 ^ w8 ^ w2 ^ w0;\r\n                w16 = n << 1 | n >>> 31;\r\n                t = w16 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w14 ^ w9 ^ w3 ^ w1;\r\n                w17 = n << 1 | n >>> 31;\r\n                t = w17 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w15 ^ w10 ^ w4 ^ w2;\r\n                w18 = n << 1 | n >>> 31;\r\n                t = w18 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w16 ^ w11 ^ w5 ^ w3;\r\n                w19 = n << 1 | n >>> 31;\r\n                t = w19 + (a << 5 | a >>> 27) + e + (b & c | ~b & d) + 1518500249 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w17 ^ w12 ^ w6 ^ w4;\r\n                w20 = n << 1 | n >>> 31;\r\n                t = w20 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w18 ^ w13 ^ w7 ^ w5;\r\n                w21 = n << 1 | n >>> 31;\r\n                t = w21 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w19 ^ w14 ^ w8 ^ w6;\r\n                w22 = n << 1 | n >>> 31;\r\n                t = w22 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w20 ^ w15 ^ w9 ^ w7;\r\n                w23 = n << 1 | n >>> 31;\r\n                t = w23 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w21 ^ w16 ^ w10 ^ w8;\r\n                w24 = n << 1 | n >>> 31;\r\n                t = w24 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w22 ^ w17 ^ w11 ^ w9;\r\n                w25 = n << 1 | n >>> 31;\r\n                t = w25 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w23 ^ w18 ^ w12 ^ w10;\r\n                w26 = n << 1 | n >>> 31;\r\n                t = w26 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w24 ^ w19 ^ w13 ^ w11;\r\n                w27 = n << 1 | n >>> 31;\r\n                t = w27 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w25 ^ w20 ^ w14 ^ w12;\r\n                w28 = n << 1 | n >>> 31;\r\n                t = w28 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w26 ^ w21 ^ w15 ^ w13;\r\n                w29 = n << 1 | n >>> 31;\r\n                t = w29 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w27 ^ w22 ^ w16 ^ w14;\r\n                w30 = n << 1 | n >>> 31;\r\n                t = w30 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w28 ^ w23 ^ w17 ^ w15;\r\n                w31 = n << 1 | n >>> 31;\r\n                t = w31 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w29 ^ w24 ^ w18 ^ w16;\r\n                w32 = n << 1 | n >>> 31;\r\n                t = w32 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w30 ^ w25 ^ w19 ^ w17;\r\n                w33 = n << 1 | n >>> 31;\r\n                t = w33 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w31 ^ w26 ^ w20 ^ w18;\r\n                w34 = n << 1 | n >>> 31;\r\n                t = w34 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w32 ^ w27 ^ w21 ^ w19;\r\n                w35 = n << 1 | n >>> 31;\r\n                t = w35 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w33 ^ w28 ^ w22 ^ w20;\r\n                w36 = n << 1 | n >>> 31;\r\n                t = w36 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w34 ^ w29 ^ w23 ^ w21;\r\n                w37 = n << 1 | n >>> 31;\r\n                t = w37 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w35 ^ w30 ^ w24 ^ w22;\r\n                w38 = n << 1 | n >>> 31;\r\n                t = w38 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w36 ^ w31 ^ w25 ^ w23;\r\n                w39 = n << 1 | n >>> 31;\r\n                t = w39 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) + 1859775393 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w37 ^ w32 ^ w26 ^ w24;\r\n                w40 = n << 1 | n >>> 31;\r\n                t = w40 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w38 ^ w33 ^ w27 ^ w25;\r\n                w41 = n << 1 | n >>> 31;\r\n                t = w41 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w39 ^ w34 ^ w28 ^ w26;\r\n                w42 = n << 1 | n >>> 31;\r\n                t = w42 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w40 ^ w35 ^ w29 ^ w27;\r\n                w43 = n << 1 | n >>> 31;\r\n                t = w43 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w41 ^ w36 ^ w30 ^ w28;\r\n                w44 = n << 1 | n >>> 31;\r\n                t = w44 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w42 ^ w37 ^ w31 ^ w29;\r\n                w45 = n << 1 | n >>> 31;\r\n                t = w45 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w43 ^ w38 ^ w32 ^ w30;\r\n                w46 = n << 1 | n >>> 31;\r\n                t = w46 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w44 ^ w39 ^ w33 ^ w31;\r\n                w47 = n << 1 | n >>> 31;\r\n                t = w47 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w45 ^ w40 ^ w34 ^ w32;\r\n                w48 = n << 1 | n >>> 31;\r\n                t = w48 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w46 ^ w41 ^ w35 ^ w33;\r\n                w49 = n << 1 | n >>> 31;\r\n                t = w49 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w47 ^ w42 ^ w36 ^ w34;\r\n                w50 = n << 1 | n >>> 31;\r\n                t = w50 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w48 ^ w43 ^ w37 ^ w35;\r\n                w51 = n << 1 | n >>> 31;\r\n                t = w51 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w49 ^ w44 ^ w38 ^ w36;\r\n                w52 = n << 1 | n >>> 31;\r\n                t = w52 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w50 ^ w45 ^ w39 ^ w37;\r\n                w53 = n << 1 | n >>> 31;\r\n                t = w53 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w51 ^ w46 ^ w40 ^ w38;\r\n                w54 = n << 1 | n >>> 31;\r\n                t = w54 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w52 ^ w47 ^ w41 ^ w39;\r\n                w55 = n << 1 | n >>> 31;\r\n                t = w55 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w53 ^ w48 ^ w42 ^ w40;\r\n                w56 = n << 1 | n >>> 31;\r\n                t = w56 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w54 ^ w49 ^ w43 ^ w41;\r\n                w57 = n << 1 | n >>> 31;\r\n                t = w57 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w55 ^ w50 ^ w44 ^ w42;\r\n                w58 = n << 1 | n >>> 31;\r\n                t = w58 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w56 ^ w51 ^ w45 ^ w43;\r\n                w59 = n << 1 | n >>> 31;\r\n                t = w59 + (a << 5 | a >>> 27) + e + (b & c | b & d | c & d) - 1894007588 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w57 ^ w52 ^ w46 ^ w44;\r\n                w60 = n << 1 | n >>> 31;\r\n                t = w60 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w58 ^ w53 ^ w47 ^ w45;\r\n                w61 = n << 1 | n >>> 31;\r\n                t = w61 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w59 ^ w54 ^ w48 ^ w46;\r\n                w62 = n << 1 | n >>> 31;\r\n                t = w62 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w60 ^ w55 ^ w49 ^ w47;\r\n                w63 = n << 1 | n >>> 31;\r\n                t = w63 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w61 ^ w56 ^ w50 ^ w48;\r\n                w64 = n << 1 | n >>> 31;\r\n                t = w64 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w62 ^ w57 ^ w51 ^ w49;\r\n                w65 = n << 1 | n >>> 31;\r\n                t = w65 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w63 ^ w58 ^ w52 ^ w50;\r\n                w66 = n << 1 | n >>> 31;\r\n                t = w66 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w64 ^ w59 ^ w53 ^ w51;\r\n                w67 = n << 1 | n >>> 31;\r\n                t = w67 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w65 ^ w60 ^ w54 ^ w52;\r\n                w68 = n << 1 | n >>> 31;\r\n                t = w68 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w66 ^ w61 ^ w55 ^ w53;\r\n                w69 = n << 1 | n >>> 31;\r\n                t = w69 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w67 ^ w62 ^ w56 ^ w54;\r\n                w70 = n << 1 | n >>> 31;\r\n                t = w70 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w68 ^ w63 ^ w57 ^ w55;\r\n                w71 = n << 1 | n >>> 31;\r\n                t = w71 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w69 ^ w64 ^ w58 ^ w56;\r\n                w72 = n << 1 | n >>> 31;\r\n                t = w72 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w70 ^ w65 ^ w59 ^ w57;\r\n                w73 = n << 1 | n >>> 31;\r\n                t = w73 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w71 ^ w66 ^ w60 ^ w58;\r\n                w74 = n << 1 | n >>> 31;\r\n                t = w74 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w72 ^ w67 ^ w61 ^ w59;\r\n                w75 = n << 1 | n >>> 31;\r\n                t = w75 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w73 ^ w68 ^ w62 ^ w60;\r\n                w76 = n << 1 | n >>> 31;\r\n                t = w76 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w74 ^ w69 ^ w63 ^ w61;\r\n                w77 = n << 1 | n >>> 31;\r\n                t = w77 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w75 ^ w70 ^ w64 ^ w62;\r\n                w78 = n << 1 | n >>> 31;\r\n                t = w78 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                n = w76 ^ w71 ^ w65 ^ w63;\r\n                w79 = n << 1 | n >>> 31;\r\n                t = w79 + (a << 5 | a >>> 27) + e + (b ^ c ^ d) - 899497514 | 0;\r\n                e = d;\r\n                d = c;\r\n                c = b << 30 | b >>> 2;\r\n                b = a;\r\n                a = t;\r\n                H0 = H0 + a | 0;\r\n                H1 = H1 + b | 0;\r\n                H2 = H2 + c | 0;\r\n                H3 = H3 + d | 0;\r\n                H4 = H4 + e | 0;\r\n            }\r\n            function _core_heap(offset) {\r\n                offset = offset | 0;\r\n                _core(HEAP[offset | 0] << 24 | HEAP[offset | 1] << 16 | HEAP[offset | 2] << 8 | HEAP[offset | 3], HEAP[offset | 4] << 24 | HEAP[offset | 5] << 16 | HEAP[offset | 6] << 8 | HEAP[offset | 7], HEAP[offset | 8] << 24 | HEAP[offset | 9] << 16 | HEAP[offset | 10] << 8 | HEAP[offset | 11], HEAP[offset | 12] << 24 | HEAP[offset | 13] << 16 | HEAP[offset | 14] << 8 | HEAP[offset | 15], HEAP[offset | 16] << 24 | HEAP[offset | 17] << 16 | HEAP[offset | 18] << 8 | HEAP[offset | 19], HEAP[offset | 20] << 24 | HEAP[offset | 21] << 16 | HEAP[offset | 22] << 8 | HEAP[offset | 23], HEAP[offset | 24] << 24 | HEAP[offset | 25] << 16 | HEAP[offset | 26] << 8 | HEAP[offset | 27], HEAP[offset | 28] << 24 | HEAP[offset | 29] << 16 | HEAP[offset | 30] << 8 | HEAP[offset | 31], HEAP[offset | 32] << 24 | HEAP[offset | 33] << 16 | HEAP[offset | 34] << 8 | HEAP[offset | 35], HEAP[offset | 36] << 24 | HEAP[offset | 37] << 16 | HEAP[offset | 38] << 8 | HEAP[offset | 39], HEAP[offset | 40] << 24 | HEAP[offset | 41] << 16 | HEAP[offset | 42] << 8 | HEAP[offset | 43], HEAP[offset | 44] << 24 | HEAP[offset | 45] << 16 | HEAP[offset | 46] << 8 | HEAP[offset | 47], HEAP[offset | 48] << 24 | HEAP[offset | 49] << 16 | HEAP[offset | 50] << 8 | HEAP[offset | 51], HEAP[offset | 52] << 24 | HEAP[offset | 53] << 16 | HEAP[offset | 54] << 8 | HEAP[offset | 55], HEAP[offset | 56] << 24 | HEAP[offset | 57] << 16 | HEAP[offset | 58] << 8 | HEAP[offset | 59], HEAP[offset | 60] << 24 | HEAP[offset | 61] << 16 | HEAP[offset | 62] << 8 | HEAP[offset | 63]);\r\n            }\r\n            function _state_to_heap(output) {\r\n                output = output | 0;\r\n                HEAP[output | 0] = H0 >>> 24;\r\n                HEAP[output | 1] = H0 >>> 16 & 255;\r\n                HEAP[output | 2] = H0 >>> 8 & 255;\r\n                HEAP[output | 3] = H0 & 255;\r\n                HEAP[output | 4] = H1 >>> 24;\r\n                HEAP[output | 5] = H1 >>> 16 & 255;\r\n                HEAP[output | 6] = H1 >>> 8 & 255;\r\n                HEAP[output | 7] = H1 & 255;\r\n                HEAP[output | 8] = H2 >>> 24;\r\n                HEAP[output | 9] = H2 >>> 16 & 255;\r\n                HEAP[output | 10] = H2 >>> 8 & 255;\r\n                HEAP[output | 11] = H2 & 255;\r\n                HEAP[output | 12] = H3 >>> 24;\r\n                HEAP[output | 13] = H3 >>> 16 & 255;\r\n                HEAP[output | 14] = H3 >>> 8 & 255;\r\n                HEAP[output | 15] = H3 & 255;\r\n                HEAP[output | 16] = H4 >>> 24;\r\n                HEAP[output | 17] = H4 >>> 16 & 255;\r\n                HEAP[output | 18] = H4 >>> 8 & 255;\r\n                HEAP[output | 19] = H4 & 255;\r\n            }\r\n            function reset() {\r\n                H0 = 1732584193;\r\n                H1 = 4023233417;\r\n                H2 = 2562383102;\r\n                H3 = 271733878;\r\n                H4 = 3285377520;\r\n                TOTAL = 0;\r\n            }\r\n            function init(h0, h1, h2, h3, h4, total) {\r\n                h0 = h0 | 0;\r\n                h1 = h1 | 0;\r\n                h2 = h2 | 0;\r\n                h3 = h3 | 0;\r\n                h4 = h4 | 0;\r\n                total = total | 0;\r\n                H0 = h0;\r\n                H1 = h1;\r\n                H2 = h2;\r\n                H3 = h3;\r\n                H4 = h4;\r\n                TOTAL = total;\r\n            }\r\n            function process(offset, length) {\r\n                offset = offset | 0;\r\n                length = length | 0;\r\n                var hashed = 0;\r\n                if (offset & 63) return -1;\r\n                while ((length | 0) >= 64) {\r\n                    _core_heap(offset);\r\n                    offset = offset + 64 | 0;\r\n                    length = length - 64 | 0;\r\n                    hashed = hashed + 64 | 0;\r\n                }\r\n                TOTAL = TOTAL + hashed | 0;\r\n                return hashed | 0;\r\n            }\r\n            function finish(offset, length, output) {\r\n                offset = offset | 0;\r\n                length = length | 0;\r\n                output = output | 0;\r\n                var hashed = 0, i = 0;\r\n                if (offset & 63) return -1;\r\n                if (~output) if (output & 31) return -1;\r\n                if ((length | 0) >= 64) {\r\n                    hashed = process(offset, length) | 0;\r\n                    if ((hashed | 0) == -1) return -1;\r\n                    offset = offset + hashed | 0;\r\n                    length = length - hashed | 0;\r\n                }\r\n                hashed = hashed + length | 0;\r\n                TOTAL = TOTAL + length | 0;\r\n                HEAP[offset | length] = 128;\r\n                if ((length | 0) >= 56) {\r\n                    for (i = length + 1 | 0; (i | 0) < 64; i = i + 1 | 0) HEAP[offset | i] = 0;\r\n                    _core_heap(offset);\r\n                    length = 0;\r\n                    HEAP[offset | 0] = 0;\r\n                }\r\n                for (i = length + 1 | 0; (i | 0) < 59; i = i + 1 | 0) HEAP[offset | i] = 0;\r\n                HEAP[offset | 59] = TOTAL >>> 29;\r\n                HEAP[offset | 60] = TOTAL >>> 21 & 255;\r\n                HEAP[offset | 61] = TOTAL >>> 13 & 255;\r\n                HEAP[offset | 62] = TOTAL >>> 5 & 255;\r\n                HEAP[offset | 63] = TOTAL << 3 & 255;\r\n                _core_heap(offset);\r\n                if (~output) _state_to_heap(output);\r\n                return hashed | 0;\r\n            }\r\n            function hmac_reset() {\r\n                H0 = I0;\r\n                H1 = I1;\r\n                H2 = I2;\r\n                H3 = I3;\r\n                H4 = I4;\r\n                TOTAL = 64;\r\n            }\r\n            function _hmac_opad() {\r\n                H0 = O0;\r\n                H1 = O1;\r\n                H2 = O2;\r\n                H3 = O3;\r\n                H4 = O4;\r\n                TOTAL = 64;\r\n            }\r\n            function hmac_init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {\r\n                p0 = p0 | 0;\r\n                p1 = p1 | 0;\r\n                p2 = p2 | 0;\r\n                p3 = p3 | 0;\r\n                p4 = p4 | 0;\r\n                p5 = p5 | 0;\r\n                p6 = p6 | 0;\r\n                p7 = p7 | 0;\r\n                p8 = p8 | 0;\r\n                p9 = p9 | 0;\r\n                p10 = p10 | 0;\r\n                p11 = p11 | 0;\r\n                p12 = p12 | 0;\r\n                p13 = p13 | 0;\r\n                p14 = p14 | 0;\r\n                p15 = p15 | 0;\r\n                reset();\r\n                _core(p0 ^ 1549556828, p1 ^ 1549556828, p2 ^ 1549556828, p3 ^ 1549556828, p4 ^ 1549556828, p5 ^ 1549556828, p6 ^ 1549556828, p7 ^ 1549556828, p8 ^ 1549556828, p9 ^ 1549556828, p10 ^ 1549556828, p11 ^ 1549556828, p12 ^ 1549556828, p13 ^ 1549556828, p14 ^ 1549556828, p15 ^ 1549556828);\r\n                O0 = H0;\r\n                O1 = H1;\r\n                O2 = H2;\r\n                O3 = H3;\r\n                O4 = H4;\r\n                reset();\r\n                _core(p0 ^ 909522486, p1 ^ 909522486, p2 ^ 909522486, p3 ^ 909522486, p4 ^ 909522486, p5 ^ 909522486, p6 ^ 909522486, p7 ^ 909522486, p8 ^ 909522486, p9 ^ 909522486, p10 ^ 909522486, p11 ^ 909522486, p12 ^ 909522486, p13 ^ 909522486, p14 ^ 909522486, p15 ^ 909522486);\r\n                I0 = H0;\r\n                I1 = H1;\r\n                I2 = H2;\r\n                I3 = H3;\r\n                I4 = H4;\r\n                TOTAL = 64;\r\n            }\r\n            function hmac_finish(offset, length, output) {\r\n                offset = offset | 0;\r\n                length = length | 0;\r\n                output = output | 0;\r\n                var t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, hashed = 0;\r\n                if (offset & 63) return -1;\r\n                if (~output) if (output & 31) return -1;\r\n                hashed = finish(offset, length, -1) | 0;\r\n                t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;\r\n                _hmac_opad();\r\n                _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);\r\n                if (~output) _state_to_heap(output);\r\n                return hashed | 0;\r\n            }\r\n            function pbkdf2_generate_block(offset, length, block, count, output) {\r\n                offset = offset | 0;\r\n                length = length | 0;\r\n                block = block | 0;\r\n                count = count | 0;\r\n                output = output | 0;\r\n                var h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0;\r\n                if (offset & 63) return -1;\r\n                if (~output) if (output & 31) return -1;\r\n                HEAP[offset + length | 0] = block >>> 24;\r\n                HEAP[offset + length + 1 | 0] = block >>> 16 & 255;\r\n                HEAP[offset + length + 2 | 0] = block >>> 8 & 255;\r\n                HEAP[offset + length + 3 | 0] = block & 255;\r\n                hmac_finish(offset, length + 4 | 0, -1) | 0;\r\n                h0 = t0 = H0, h1 = t1 = H1, h2 = t2 = H2, h3 = t3 = H3, h4 = t4 = H4;\r\n                count = count - 1 | 0;\r\n                while ((count | 0) > 0) {\r\n                    hmac_reset();\r\n                    _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);\r\n                    t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;\r\n                    _hmac_opad();\r\n                    _core(t0, t1, t2, t3, t4, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);\r\n                    t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4;\r\n                    h0 = h0 ^ H0;\r\n                    h1 = h1 ^ H1;\r\n                    h2 = h2 ^ H2;\r\n                    h3 = h3 ^ H3;\r\n                    h4 = h4 ^ H4;\r\n                    count = count - 1 | 0;\r\n                }\r\n                H0 = h0;\r\n                H1 = h1;\r\n                H2 = h2;\r\n                H3 = h3;\r\n                H4 = h4;\r\n                if (~output) _state_to_heap(output);\r\n                return 0;\r\n            }\r\n            return {\r\n                reset: reset,\r\n                init: init,\r\n                process: process,\r\n                finish: finish,\r\n                hmac_reset: hmac_reset,\r\n                hmac_init: hmac_init,\r\n                hmac_finish: hmac_finish,\r\n                pbkdf2_generate_block: pbkdf2_generate_block\r\n            };\r\n        }\r\n        var _sha1_block_size = 64, _sha1_hash_size = 20;\r\n        function sha1_constructor(options) {\r\n            options = options || {};\r\n            this.heap = _heap_init(Uint8Array, options);\r\n            this.asm = options.asm || sha1_asm(global, null, this.heap.buffer);\r\n            this.BLOCK_SIZE = _sha1_block_size;\r\n            this.HASH_SIZE = _sha1_hash_size;\r\n            this.reset();\r\n        }\r\n        sha1_constructor.BLOCK_SIZE = _sha1_block_size;\r\n        sha1_constructor.HASH_SIZE = _sha1_hash_size;\r\n        var sha1_prototype = sha1_constructor.prototype;\r\n        sha1_prototype.reset = hash_reset;\r\n        sha1_prototype.process = hash_process;\r\n        sha1_prototype.finish = hash_finish;\r\n        var sha1_instance = null;\r\n        function get_sha1_instance() {\r\n            if (sha1_instance === null) sha1_instance = new sha1_constructor({\r\n                heapSize: 1048576\r\n            });\r\n            return sha1_instance;\r\n        }\r\n        function sha1_bytes(data) {\r\n            if (data === undefined) throw new SyntaxError(\"data required\");\r\n            return get_sha1_instance().reset().process(data).finish().result;\r\n        }\r\n        function sha1_hex(data) {\r\n            var result = sha1_bytes(data);\r\n            return bytes_to_hex(result);\r\n        }\r\n        function sha1_base64(data) {\r\n            var result = sha1_bytes(data);\r\n            return bytes_to_base64(result);\r\n        }\r\n        sha1_constructor.bytes = sha1_bytes;\r\n        sha1_constructor.hex = sha1_hex;\r\n        sha1_constructor.base64 = sha1_base64;\r\n        exports.SHA1 = sha1_constructor;\r\n    })({}, function() {\r\n        return this;\r\n    }());\r\n});\n",
    "/**\r\n * Created by tkecskes on 1/6/2015.\r\n */\r\ndefine('util/key',[\r\n  './sha1',\r\n  './zssha1',\r\n  './assert',\r\n  './canon',\r\n  './asmcryptosha1' //->asmCrypto\r\n],function(SHA1,ZS,ASSERT,CANON){\r\n\r\n  var keyType = null;\r\n  var ZSSHA = new ZS();\r\n  function rand160Bits(){\r\n    //#4ca8ccec576284f66055d9f6c1a571d48a70902c\r\n    var result = \"\", i,code;\r\n    for (i = 0; i < 40; i++) {\r\n      code = Math.floor(Math.random() * 16);\r\n      code = code > 9 ? code+87 : code+48;\r\n      result += String.fromCharCode(code);\r\n    }\r\n    return result;\r\n  }\r\n  return function KeyGenerator(object){\r\n    if(keyType === null){\r\n      if(WebGMEGlobal && WebGMEGlobal.config && typeof WebGMEGlobal.config.keyType === 'string'){\r\n        keyType = WebGMEGlobal.config.keyType;\r\n      } else if(WebGMEGlobal && typeof WebGMEGlobal.getConfig === 'function'){\r\n        keyType = WebGMEGlobal.getConfig().storageKeyType || \"plainSHA1\";\r\n      } else {\r\n        keyType = \"plainSHA1\";\r\n      }\r\n    }\r\n\r\n    ASSERT(typeof keyType === 'string');\r\n\r\n    switch (keyType){\r\n      case 'rand160Bits':\r\n        return rand160Bits();\r\n        break;\r\n      case 'asmSHA1':\r\n        return asmCrypto.SHA1.hex(CANON.stringify(object));\r\n        break;\r\n      case 'ZSSHA':\r\n        return ZSSHA.getHash(CANON.stringify(object));\r\n      default: //plainSHA1\r\n        return SHA1(CANON.stringify(object));\r\n        break;\r\n    }\r\n  }\r\n});\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('core/future',[], function () {\r\n\t\"use strict\";\r\n\r\n\tvar maxDepth = 5;\r\n\r\n\tvar ASSERT = function (cond) {\r\n\t\tif (!cond) {\r\n\t\t\tvar error = new Error(\"future assertion failed\");\r\n\t\t\tconsole.log(error.stack);\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t};\r\n\r\n\t// ------- Future -------\r\n\r\n\tvar UNRESOLVED = {};\r\n\r\n\tvar Future = function () {\r\n\t\tthis.value = UNRESOLVED;\r\n\t\tthis.listener = null;\r\n\t\tthis.param = null;\r\n\t};\r\n\r\n\tvar setValue = function (future, value) {\r\n\t\tASSERT(future instanceof Future && future.value === UNRESOLVED);\r\n\r\n\t\tif (value instanceof Future) {\r\n\t\t\tsetListener(value, setValue, future);\r\n\t\t} else {\r\n\t\t\tfuture.value = value;\r\n\r\n\t\t\tif (future.listener !== null) {\r\n\t\t\t\tfuture.listener(future.param, value);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar setListener = function (future, listener, param) {\r\n\t\tASSERT(future instanceof Future && future.listener === null && future.value === UNRESOLVED);\r\n\t\tASSERT(typeof listener === \"function\" && listener.length === 2);\r\n\r\n\t\tfuture.listener = listener;\r\n\t\tfuture.param = param;\r\n\r\n\t\tif (future.value !== UNRESOLVED) {\r\n\t\t\tlistener(param, future);\r\n\t\t}\r\n\t};\r\n\r\n\tvar isUnresolved = function (value) {\r\n\t\treturn (value instanceof Future) && value.value === UNRESOLVED;\r\n\t};\r\n\r\n\tvar getValue = function (value) {\r\n\t\tif (value instanceof Future) {\r\n\t\t\tif (value.value instanceof Error) {\r\n\t\t\t\tthrow value.value;\r\n\t\t\t} else if (value.value !== UNRESOLVED) {\r\n\t\t\t\treturn value.value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn value;\r\n\t};\r\n\r\n\t// ------- adapt\r\n\r\n\tvar adapt = function (func) {\r\n\t\tASSERT(typeof func === \"function\");\r\n\r\n\t\treturn function adaptx () {\r\n\t\t\tvar args = arguments;\r\n\t\t\tvar future = new Future();\r\n\r\n\t\t\targs[args.length++] = function adaptCallback (error, value) {\r\n\t\t\t\tif (error) {\r\n\t\t\t\t\tvalue = error instanceof Error ? error : new Error(error);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tASSERT(!(value instanceof Error));\r\n\t\t\t\t}\r\n\t\t\t\tsetValue(future, value);\r\n\t\t\t};\r\n\r\n\t\t\tfunc.apply(this, args);\r\n\r\n\t\t\treturn getValue(future);\r\n\t\t};\r\n\t};\r\n\r\n\tvar unadapt = function (func) {\r\n\t\tASSERT(typeof func === \"function\");\r\n\r\n\t\tif (func.length === 0) {\r\n\t\t\treturn function unadapt0 (callback) {\r\n\t\t\t\tvar value;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvalue = func.call(this);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tcallback(error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthen(value, callback);\r\n\t\t\t};\r\n\t\t} else if (func.length === 1) {\r\n\t\t\treturn function unadapt1 (arg, callback) {\r\n\t\t\t\tvar value;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvalue = func.call(this, arg);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tcallback(error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthen(value, callback);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\treturn function unadaptx () {\r\n\t\t\t\tvar args = arguments;\r\n\r\n\t\t\t\tvar callback = args[--args.length];\r\n\t\t\t\tASSERT(typeof callback === \"function\");\r\n\r\n\t\t\t\tvar value;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvalue = func.apply(this, args);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tcallback(error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthen(value, callback);\r\n\t\t\t};\r\n\t\t}\r\n\t};\r\n\r\n\tvar delay = function (delay, value) {\r\n\t\tvar future = new Future();\r\n\t\tsetTimeout(setValue, delay, future, value);\r\n\t\treturn future;\r\n\t};\r\n\r\n\t// ------- call -------\r\n\r\n\tvar Func = function (func, that, args, index) {\r\n\t\tthis.value = UNRESOLVED;\r\n\t\tthis.listener = null;\r\n\t\tthis.param = null;\r\n\r\n\t\tthis.func = func;\r\n\t\tthis.that = that;\r\n\t\tthis.args = args;\r\n\t\tthis.index = index;\r\n\r\n\t\tsetListener(args[index], setArgument, this);\r\n\t};\r\n\r\n\tFunc.prototype = Future.prototype;\r\n\r\n\tvar setArgument = function (future, value) {\r\n\t\tif (!(value instanceof Error)) {\r\n\t\t\ttry {\r\n\t\t\t\tvar args = future.args;\r\n\t\t\t\targs[future.index] = value;\r\n\r\n\t\t\t\twhile (++future.index < args.length) {\r\n\t\t\t\t\tvalue = args[future.index];\r\n\t\t\t\t\tif (isUnresolved(value)) {\r\n\t\t\t\t\t\tsetListener(value, setArgument, future);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\targs[future.index] = getValue(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = future.func.apply(future.that, args);\r\n\t\t\t\tASSERT(!(value instanceof Error));\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvalue = error instanceof Error ? error : new Error(error);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsetValue(future, value);\r\n\t};\r\n\r\n\tvar call = function () {\r\n\t\tvar args = arguments;\r\n\r\n\t\tvar func = args[--args.length];\r\n\t\tASSERT(typeof func === \"function\");\r\n\r\n\t\tfor ( var i = 0; i < args.length; ++i) {\r\n\t\t\tif (isUnresolved(args[i])) {\r\n\t\t\t\treturn new Func(func, this, args, i);\r\n\t\t\t} else {\r\n\t\t\t\targs[i] = getValue(args[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn func.apply(this, args);\r\n\t};\r\n\r\n\t// ------- join -------\r\n\r\n\tvar Join = function (first, second) {\r\n\t\tthis.value = UNRESOLVED;\r\n\t\tthis.listener = null;\r\n\t\tthis.param = null;\r\n\r\n\t\tthis.missing = 2;\r\n\t\tsetListener(first, setJoinand, this);\r\n\t\tsetListener(second, setJoinand, this);\r\n\t};\r\n\r\n\tJoin.prototype = Object.create(Future.prototype);\r\n\r\n\tvar setJoinand = function (future, value) {\r\n\t\tif (value instanceof Error) {\r\n\t\t\tsetValue(future, value);\r\n\t\t} else if (--future.missing <= 0) {\r\n\t\t\tsetValue(future, undefined);\r\n\t\t}\r\n\t};\r\n\r\n\tvar join = function (first, second) {\r\n\t\tif (getValue(first) instanceof Future) {\r\n\t\t\tif (getValue(second) instanceof Future) {\r\n\t\t\t\tif (first instanceof Join) {\r\n\t\t\t\t\tfirst.missing += 1;\r\n\t\t\t\t\tsetListener(second, setJoinand, first);\r\n\t\t\t\t\treturn first;\r\n\t\t\t\t} else if (second instanceof Join) {\r\n\t\t\t\t\tsecond.missing += 1;\r\n\t\t\t\t\tsetListener(first, setJoinand, second);\r\n\t\t\t\t\treturn second;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn new Join(first, second);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn first;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn getValue(second);\r\n\t\t}\r\n\t};\r\n\r\n\t// ------- hide -------\r\n\r\n\tvar Hide = function (future, handler) {\r\n\t\tthis.value = UNRESOLVED;\r\n\t\tthis.listener = null;\r\n\t\tthis.param = null;\r\n\r\n\t\tthis.handler = handler;\r\n\t\tsetListener(future, hideValue, this);\r\n\t};\r\n\r\n\tHide.prototype = Future.prototype;\r\n\r\n\tvar hideValue = function (future, value) {\r\n\t\ttry {\r\n\t\t\tif (value instanceof Error) {\r\n\t\t\t\tvalue = future.handler(value);\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\tvalue = error instanceof Error ? error : new Error(error);\r\n\t\t}\r\n\r\n\t\tsetValue(future, value);\r\n\t};\r\n\r\n\tvar printStack = function (error) {\r\n\t\tconsole.log(error.stack);\r\n\t};\r\n\r\n\tvar hide = function (future, handler) {\r\n\t\tif (typeof handler !== \"function\") {\r\n\t\t\thandler = printStack;\r\n\t\t}\r\n\r\n\t\tif (isUnresolved(future)) {\r\n\t\t\treturn new Hide(future, handler);\r\n\t\t} else if (future.value instanceof Error) {\r\n\t\t\treturn handler(future.value);\r\n\t\t} else {\r\n\t\t\treturn getValue(future);\r\n\t\t}\r\n\t};\r\n\r\n\t// ------- array -------\r\n\r\n\tvar Arr = function (array, index) {\r\n\t\tthis.value = UNRESOLVED;\r\n\t\tthis.listener = null;\r\n\t\tthis.param = null;\r\n\r\n\t\tthis.array = array;\r\n\t\tthis.index = index;\r\n\r\n\t\tsetListener(array[index], setMember, this);\r\n\t};\r\n\r\n\tArr.prototype = Future.prototype;\r\n\r\n\tvar setMember = function (future, value) {\r\n\t\tif (!(value instanceof Error)) {\r\n\t\t\ttry {\r\n\t\t\t\tvar array = future.array;\r\n\t\t\t\tarray[future.index] = value;\r\n\r\n\t\t\t\twhile (++future.index < array.length) {\r\n\t\t\t\t\tvalue = array[future.index];\r\n\t\t\t\t\tif (isUnresolved(value)) {\r\n\t\t\t\t\t\tsetListener(value, setMember, future);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tarray[future.index] = getValue(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = array;\r\n\t\t\t} catch (error) {\r\n\t\t\t\tvalue = error instanceof Error ? error : new Error(error);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsetValue(future, value);\r\n\t};\r\n\r\n\tvar array = function (array) {\r\n\t\tASSERT(array instanceof Array);\r\n\r\n\t\tfor ( var i = 0; i < array.length; ++i) {\r\n\t\t\tif (isUnresolved(array[i])) {\r\n\t\t\t\treturn new Arr(array, i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t};\r\n\r\n\t// ------- then -------\r\n\r\n\tvar thenHandler = function (callback, value) {\r\n\t\tif (value instanceof Error) {\r\n\t\t\tcallback(value);\r\n\t\t} else {\r\n\t\t\tcallback(null, value);\r\n\t\t}\r\n\t};\r\n\r\n\tvar calldepth = 0;\r\n\tvar then = function (future, callback) {\r\n\t\tvar error = null, value;\r\n\r\n\t\tif (!(future instanceof Future)) {\r\n\t\t\tvalue = future;\r\n\t\t} else if (future.value === UNRESOLVED) {\r\n\t\t\tsetListener(future, thenHandler, callback);\r\n\t\t\treturn;\r\n\t\t} else if (future.value instanceof Error) {\r\n\t\t\terror = future.value;\r\n\t\t} else {\r\n\t\t\tvalue = future.value;\r\n\t\t}\r\n\r\n\t\tif (calldepth < maxDepth) {\r\n\t\t\t++calldepth;\r\n\t\t\ttry {\r\n\t\t\t\tcallback(error, value);\r\n\t\t\t} catch (err) {\r\n\t\t\t\tconsole.log(\"unhandled error from callback\", err);\r\n\t\t\t}\r\n\t\t\t--calldepth;\r\n\t\t} else {\r\n\t\t\tsetTimeout(callback, 0, error, value);\r\n\t\t}\r\n\t};\r\n\r\n\t// -------\r\n\r\n\treturn {\r\n\t\tadapt: adapt,\r\n\t\tunadapt: unadapt,\r\n\t\tdelay: delay,\r\n\t\tcall: call,\r\n\t\tarray: array,\r\n\t\tjoin: join,\r\n\t\thide: hide,\r\n\t\tthen: then\r\n\t};\r\n});\r\n\n",
    "/**\r\n * The MIT License (MIT)\r\n * Copyright (c) 2013, Miklos Maroti\r\n */\r\n\r\n(function () {\r\n\t\"use strict\";\r\n\r\n\t// ------- assert -------\r\n\r\n\tvar TASYNC_TRACE_ENABLE = true;\r\n\r\n\tfunction setTrace (value) {\r\n\t\tTASYNC_TRACE_ENABLE = value;\r\n\t}\r\n\r\n\tfunction assert (cond) {\r\n\t\tif (!cond) {\r\n\t\t\tthrow new Error(\"tasync internal error\");\r\n\t\t}\r\n\t}\r\n\r\n\t// ------- Future -------\r\n\r\n\tvar STATE_LISTEN = 0;\r\n\tvar STATE_REJECTED = 1;\r\n\tvar STATE_RESOLVED = 2;\r\n\r\n\tvar Future = function () {\r\n\t\tthis.state = STATE_LISTEN;\r\n\t\tthis.value = [];\r\n\t};\r\n\r\n\tFuture.prototype.register = function (target) {\r\n\t\tassert(this.state === STATE_LISTEN);\r\n\t\tassert(typeof target === \"object\" && target !== null);\r\n\r\n\t\tthis.value.push(target);\r\n\t};\r\n\r\n\tFuture.prototype.resolve = function (value) {\r\n\t\tassert(this.state === STATE_LISTEN && !(value instanceof Future));\r\n\r\n\t\tvar listeners = this.value;\r\n\r\n\t\tthis.state = STATE_RESOLVED;\r\n\t\tthis.value = value;\r\n\r\n\t\tvar i;\r\n\t\tfor (i = 0; i < listeners.length; ++i) {\r\n\t\t\tlisteners[i].onResolved(value);\r\n\t\t}\r\n\t};\r\n\r\n\tFuture.prototype.reject = function (error) {\r\n\t\tassert(this.state === STATE_LISTEN && error instanceof Error);\r\n\r\n\t\tvar listeners = this.value;\r\n\r\n\t\tthis.state = STATE_REJECTED;\r\n\t\tthis.value = error;\r\n\r\n\t\tvar i;\r\n\t\tfor (i = 0; i < listeners.length; ++i) {\r\n\t\t\tlisteners[i].onRejected(error);\r\n\t\t}\r\n\t};\r\n\r\n\t// ------- Delay -------\r\n\r\n\tfunction delay (timeout, value) {\r\n\t\tif (timeout < 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tvar future = new Future();\r\n\t\tsetTimeout(function () {\r\n\t\t\tfuture.resolve(value);\r\n\t\t}, timeout);\r\n\t\treturn future;\r\n\t}\r\n\r\n\t// ------- Lift -------\r\n\r\n\tvar FutureLift = function (array, index) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.array = array;\r\n\t\tthis.index = index;\r\n\t};\r\n\r\n\tFutureLift.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureLift.prototype.onResolved = function (value) {\r\n\t\tassert(this.state === STATE_LISTEN);\r\n\r\n\t\tvar array = this.array;\r\n\t\tarray[this.index] = value;\r\n\r\n\t\twhile (++this.index < array.length) {\r\n\t\t\tvalue = array[this.index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\tarray[this.index] = value.value;\r\n\t\t\t\t} else if (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvalue.register(this);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\tthis.reject(value.value);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.array = null;\r\n\t\tthis.resolve(array);\r\n\t};\r\n\r\n\tFutureLift.prototype.onRejected = function (error) {\r\n\t\tthis.array = null;\r\n\t\tthis.reject(error);\r\n\t};\r\n\r\n\tvar lift = function (array) {\r\n\t\tif (!(array instanceof Array)) {\r\n\t\t\tthrow new Error(\"array argument is expected\");\r\n\t\t}\r\n\r\n\t\tvar index;\r\n\t\tfor (index = 0; index < array.length; ++index) {\r\n\t\t\tvar value = array[index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\tarray[index] = value.value;\r\n\t\t\t\t} else if (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvar future = new FutureLift(array, index);\r\n\t\t\t\t\tvalue.register(future);\r\n\t\t\t\t\treturn future;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t};\r\n\r\n\t// ------- Apply -------\r\n\r\n\tvar ROOT = {\r\n\t\tsubframes: 0\r\n\t};\r\n\r\n\tvar FRAME = ROOT;\r\n\r\n\tvar FutureApply = function tasync_trace_end (func, that, args, index) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.caller = FRAME;\r\n\t\tthis.position = ++FRAME.subframes;\r\n\t\tthis.subframes = 0;\r\n\r\n\t\tif (TASYNC_TRACE_ENABLE) {\r\n\t\t\tthis.trace = new Error();\r\n\t\t}\r\n\r\n\t\tthis.func = func;\r\n\t\tthis.that = that;\r\n\t\tthis.args = args;\r\n\t\tthis.index = index;\r\n\t};\r\n\r\n\tFutureApply.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureApply.prototype.getPath = function () {\r\n\t\tvar future = this.caller, path = [ this.position ];\r\n\r\n\t\twhile (future !== ROOT) {\r\n\t\t\tpath.push(future.position);\r\n\t\t\tfuture = future.caller;\r\n\t\t}\r\n\r\n\t\treturn path;\r\n\t};\r\n\r\n\tfunction getSlice (trace) {\r\n\t\tassert(typeof trace === \"string\");\r\n\r\n\t\tvar end = trace.indexOf(\"tasync_trace_start\");\r\n\t\tif (end >= 0) {\r\n\t\t\tend = trace.lastIndexOf(\"\\n\", end) + 1;\r\n\t\t} else {\r\n\t\t\tif (trace.charAt(trace.length - 1) !== \"\\n\") {\r\n\t\t\t\t// trace += \"\\n\";\r\n\t\t\t}\r\n\t\t\tend = undefined;\r\n\t\t}\r\n\r\n\t\tvar start = trace.indexOf(\"tasync_trace_end\");\r\n\t\tif (start >= 0) {\r\n\t\t\tstart = trace.indexOf(\"\\n\", start) + 1;\r\n\t\t\tif (start >= 0) {\r\n\t\t\t\tstart = trace.indexOf(\"\\n\", start) + 1;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tstart = 0;\r\n\t\t}\r\n\r\n\t\treturn trace.substring(start, end);\r\n\t}\r\n\r\n\tfunction createError (error, future) {\r\n\t\tif (!(error instanceof Error)) {\r\n\t\t\terror = new Error(error);\r\n\t\t}\r\n\r\n\t\tif (TASYNC_TRACE_ENABLE) {\r\n\t\t\terror.trace = getSlice(error.stack);\r\n\t\t\tdo {\r\n\t\t\t\terror.trace += \"*** callback ***\\n\";\r\n\t\t\t\terror.trace += getSlice(future.trace.stack);\r\n\t\t\t\tfuture = future.caller;\r\n\t\t\t} while (future !== ROOT);\r\n\t\t}\r\n\r\n\t\treturn error;\r\n\t}\r\n\r\n\tFutureApply.prototype.onRejected = function (error) {\r\n\t\tthis.args = null;\r\n\t\tthis.reject(error);\r\n\t};\r\n\r\n\tFutureApply.prototype.onResolved = function tasync_trace_start (value) {\r\n\t\tassert(this.state === STATE_LISTEN);\r\n\r\n\t\tvar args = this.args;\r\n\t\targs[this.index] = value;\r\n\r\n\t\twhile (--this.index >= 0) {\r\n\t\t\tvalue = args[this.index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\targs[this.index] = value.value;\r\n\t\t\t\t} else if (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvalue.register(this);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\tthis.reject(value.value);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tassert(FRAME === ROOT);\r\n\t\tFRAME = this;\r\n\r\n\t\tthis.args = null;\r\n\t\ttry {\r\n\t\t\tvalue = this.func.apply(this.that, args);\r\n\t\t} catch (error) {\r\n\t\t\tFRAME = ROOT;\r\n\r\n\t\t\tthis.reject(createError(error, this));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFRAME = ROOT;\r\n\r\n\t\tif (value instanceof Future) {\r\n\t\t\tassert(value.state === STATE_LISTEN);\r\n\r\n\t\t\tthis.onResolved = this.resolve;\r\n\t\t\tvalue.register(this);\r\n\t\t} else {\r\n\t\t\tthis.resolve(value);\r\n\t\t}\r\n\t};\r\n\r\n\tvar apply = function (func, args, that) {\r\n\t\tif (typeof func !== \"function\") {\r\n\t\t\tthrow new Error(\"function argument is expected\");\r\n\t\t} else if (!(args instanceof Array)) {\r\n\t\t\tthrow new Error(\"array argument is expected\");\r\n\t\t}\r\n\r\n\t\tvar index = args.length;\r\n\t\twhile (--index >= 0) {\r\n\t\t\tvar value = args[index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvar future = new FutureApply(func, that, args, index);\r\n\t\t\t\t\tvalue.register(future);\r\n\t\t\t\t\treturn future;\r\n\t\t\t\t} else if (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\targs[index] = value.value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn func.apply(that, args);\r\n\t};\r\n\r\n\t// ------- Call -------\r\n\r\n\tvar FutureCall = function tasync_trace_end (args, index) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.caller = FRAME;\r\n\t\tthis.position = ++FRAME.subframes;\r\n\t\tthis.subframes = 0;\r\n\r\n\t\tif (TASYNC_TRACE_ENABLE) {\r\n\t\t\tthis.trace = new Error();\r\n\t\t}\r\n\r\n\t\tthis.args = args;\r\n\t\tthis.index = index;\r\n\t};\r\n\r\n\tFutureCall.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureCall.prototype.getPath = FutureApply.prototype.getPath;\r\n\tFutureCall.prototype.onRejected = FutureApply.prototype.onRejected;\r\n\r\n\tvar FUNCTION_CALL = Function.call;\r\n\r\n\tFutureCall.prototype.onResolved = function tasync_trace_start (value) {\r\n\t\tassert(this.state === STATE_LISTEN);\r\n\r\n\t\tvar args = this.args;\r\n\t\targs[this.index] = value;\r\n\r\n\t\twhile (--this.index >= 0) {\r\n\t\t\tvalue = args[this.index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\targs[this.index] = value.value;\r\n\t\t\t\t} else if (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvalue.register(this);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\tthis.reject(value.value);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tassert(FRAME === ROOT);\r\n\t\tFRAME = this;\r\n\r\n\t\tthis.args = null;\r\n\t\ttry {\r\n\t\t\tvar func = args[0];\r\n\t\t\targs[0] = null;\r\n\t\t\tvalue = FUNCTION_CALL.apply(func, args);\r\n\t\t} catch (error) {\r\n\t\t\tFRAME = ROOT;\r\n\r\n\t\t\tthis.reject(createError(error, this));\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFRAME = ROOT;\r\n\r\n\t\tif (value instanceof Future) {\r\n\t\t\tassert(value.state === STATE_LISTEN);\r\n\r\n\t\t\tthis.onResolved = this.resolve;\r\n\t\t\tvalue.register(this);\r\n\t\t} else {\r\n\t\t\tthis.resolve(value);\r\n\t\t}\r\n\t};\r\n\r\n\tvar call = function () {\r\n\t\tvar index = arguments.length;\r\n\t\twhile (--index >= 0) {\r\n\t\t\tvar value = arguments[index];\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tif (value.state === STATE_LISTEN) {\r\n\t\t\t\t\tvar future = new FutureCall(arguments, index);\r\n\t\t\t\t\tvalue.register(future);\r\n\t\t\t\t\treturn future;\r\n\t\t\t\t} else if (value.state === STATE_RESOLVED) {\r\n\t\t\t\t\targuments[index] = value.value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(value.state === STATE_REJECTED);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar func = arguments[0];\r\n\t\treturn FUNCTION_CALL.apply(func, arguments);\r\n\t};\r\n\r\n\t// ------- TryCatch -------\r\n\r\n\tfunction FutureTryCatch (handler) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.handler = handler;\r\n\t}\r\n\r\n\tFutureTryCatch.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureTryCatch.prototype.onRejected = function (error) {\r\n\t\ttry {\r\n\t\t\tvar value = this.handler(error);\r\n\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tthis.onRejected = Future.prorotype.reject;\r\n\t\t\t\tvalue.register(this);\r\n\t\t\t} else {\r\n\t\t\t\tthis.resolve(value);\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\tthis.reject(err);\r\n\t\t}\r\n\t};\r\n\r\n\tFutureTryCatch.prototype.onResolved = Future.prototype.resolve;\r\n\r\n\tfunction trycatch (func, handler) {\r\n\t\tif (typeof func !== \"function\" || typeof handler !== \"function\") {\r\n\t\t\tthrow new Error(\"function arguments are expected\");\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tvar value = func();\r\n\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tvar future = new FutureTryCatch(handler);\r\n\t\t\t\tvalue.register(future);\r\n\r\n\t\t\t\treturn future;\r\n\t\t\t} else {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\treturn handler(error);\r\n\t\t}\r\n\t}\r\n\r\n\t// ------- Wrap -------\r\n\r\n\tfunction wrap (func) {\r\n\t\tif (typeof func !== \"function\") {\r\n\t\t\tthrow new Error(\"function argument is expected\");\r\n\t\t}\r\n\r\n\t\tif (typeof func.tasync_wraped === \"undefined\") {\r\n\t\t\tfunc.tasync_wraped = function () {\r\n\t\t\t\tvar args = arguments;\r\n\t\t\t\tvar future = new Future();\r\n\r\n\t\t\t\targs[args.length++] = function (error, value) {\r\n\t\t\t\t\tif (error) {\r\n\t\t\t\t\t\tfuture.reject(error instanceof Error ? error : new Error(error));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfuture.resolve(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tfunc.apply(this, args);\r\n\r\n\t\t\t\tif (future.state === STATE_LISTEN) {\r\n\t\t\t\t\treturn future;\r\n\t\t\t\t} else if (future.state === STATE_RESOLVED) {\r\n\t\t\t\t\treturn future.value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassert(future.state === STATE_REJECTED);\r\n\t\t\t\t\tthrow future.value;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunc.tasync_wraped.tasync_unwraped = func;\r\n\t\t}\r\n\r\n\t\treturn func.tasync_wraped;\r\n\t}\r\n\r\n\t// ------- Unwrap -------\r\n\r\n\tfunction UnwrapListener (callback) {\r\n\t\tthis.callback = callback;\r\n\t}\r\n\r\n\tUnwrapListener.prototype.onRejected = function (error) {\r\n\t\tthis.callback(error);\r\n\t};\r\n\r\n\tUnwrapListener.prototype.onResolved = function (value) {\r\n\t\tthis.callback(null, value);\r\n\t};\r\n\r\n\tfunction unwrap (func) {\r\n\t\tif (typeof func !== \"function\") {\r\n\t\t\tthrow new Error(\"function argument is expected\");\r\n\t\t}\r\n\r\n\t\tif (typeof func.tasync_unwraped === \"undefined\") {\r\n\t\t\tfunc.tasync_unwraped = function () {\r\n\t\t\t\tvar args = arguments;\r\n\r\n\t\t\t\tvar callback = args[--args.length];\r\n\t\t\t\tassert(typeof callback === \"function\");\r\n\r\n\t\t\t\tvar value;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvalue = func.apply(this, args);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tcallback(error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (value instanceof Future) {\r\n\t\t\t\t\tassert(value.state === STATE_LISTEN);\r\n\r\n\t\t\t\t\tvar listener = new UnwrapListener(callback);\r\n\t\t\t\t\tvalue.register(listener);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcallback(null, value);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfunc.tasync_unwraped.tasync_wraped = func;\r\n\t\t}\r\n\r\n\t\treturn func.tasync_unwraped;\r\n\t}\r\n\r\n\t// ------- Throttle -------\r\n\r\n\tfunction FutureThrottle (func, that, args) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.func = func;\r\n\t\tthis.that = that;\r\n\t\tthis.args = args;\r\n\r\n\t\tthis.caller = FRAME;\r\n\t\tthis.position = ++FRAME.subframes;\r\n\r\n\t\tthis.path = this.getPath();\r\n\t}\r\n\r\n\tFutureThrottle.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureThrottle.prototype.execute = function () {\r\n\t\tvar value;\r\n\t\ttry {\r\n\t\t\tassert(FRAME === ROOT);\r\n\t\t\tFRAME = this;\r\n\r\n\t\t\tvalue = this.func.apply(this.that, this.args);\r\n\r\n\t\t\tFRAME = ROOT;\r\n\t\t} catch (error) {\r\n\t\t\tFRAME = ROOT;\r\n\r\n\t\t\tthis.reject(error);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (value instanceof Future) {\r\n\t\t\tassert(value.state === STATE_LISTEN);\r\n\t\t\tvalue.register(this);\r\n\t\t} else {\r\n\t\t\tthis.resolve(value);\r\n\t\t}\r\n\t};\r\n\r\n\tFutureThrottle.prototype.getPath = FutureApply.prototype.getPath;\r\n\tFutureThrottle.prototype.onResolved = Future.prototype.resolve;\r\n\tFutureThrottle.prototype.onRejected = Future.prototype.reject;\r\n\r\n\tFutureThrottle.prototype.compare = function (second) {\r\n\t\tvar first = this.path;\r\n\t\tsecond = second.path;\r\n\r\n\t\tvar i, limit = first.length < second.length ? first.length : second.length;\r\n\t\tfor (i = 0; i < limit; ++i) {\r\n\t\t\tif (first[i] !== second[i]) {\r\n\t\t\t\treturn first[i] - second[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn first.length - second.length;\r\n\t};\r\n\r\n\tfunction ThrottleListener (limit) {\r\n\t\tthis.running = 0;\r\n\t\tthis.limit = limit;\r\n\t\tthis.queue = [];\r\n\t}\r\n\r\n\tfunction priorityQueueInsert (queue, elem) {\r\n\t\tvar low = 0;\r\n\t\tvar high = queue.length;\r\n\r\n\t\twhile (low < high) {\r\n\t\t\tvar mid = Math.floor((low + high) / 2);\r\n\t\t\tassert(low <= mid && mid < high);\r\n\r\n\t\t\tif (elem.compare(queue[mid]) < 0) {\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t} else {\r\n\t\t\t\thigh = mid;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tqueue.splice(low, 0, elem);\r\n\t}\r\n\r\n\tThrottleListener.prototype.execute = function (func, that, args) {\r\n\t\tif (this.running < this.limit) {\r\n\t\t\tvar value = func.apply(that, args);\r\n\r\n\t\t\tif (value instanceof Future) {\r\n\t\t\t\tassert(value.state === STATE_LISTEN);\r\n\r\n\t\t\t\t++this.running;\r\n\t\t\t\tvalue.register(this);\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t} else {\r\n\t\t\tvar future = new FutureThrottle(func, that, args);\r\n\t\t\tpriorityQueueInsert(this.queue, future);\r\n\r\n\t\t\treturn future;\r\n\t\t}\r\n\t};\r\n\r\n\tThrottleListener.prototype.onResolved = function () {\r\n\t\tif (this.queue.length > 0) {\r\n\t\t\tvar future = this.queue.pop();\r\n\t\t\tfuture.register(this);\r\n\r\n\t\t\tfuture.execute();\r\n\t\t} else {\r\n\t\t\t--this.running;\r\n\t\t}\r\n\t};\r\n\r\n\tThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;\r\n\r\n\t// TODO: prevent recursion, otheriwise throttle will not work\r\n\tfunction throttle (func, limit) {\r\n\t\tif (typeof func !== \"function\") {\r\n\t\t\tthrow new Error(\"function argument is expected\");\r\n\t\t} else if (typeof limit !== \"number\") {\r\n\t\t\tthrow new Error(\"number argument is expected\");\r\n\t\t}\r\n\r\n\t\tvar listener = new ThrottleListener(limit);\r\n\r\n\t\treturn function () {\r\n\t\t\treturn listener.execute(func, this, arguments);\r\n\t\t};\r\n\t}\r\n\r\n\t// ------- Join -------\r\n\r\n\tfunction FutureJoin (first) {\r\n\t\tFuture.call(this);\r\n\r\n\t\tthis.first = first;\r\n\t\tthis.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;\r\n\t}\r\n\r\n\tFutureJoin.prototype = Object.create(Future.prototype);\r\n\r\n\tFutureJoin.prototype.onResolved = function (value) {\r\n\t\tif (--this.missing === 0) {\r\n\t\t\tassert(this.state !== STATE_RESOLVED);\r\n\r\n\t\t\tif (this.state === STATE_LISTEN) {\r\n\t\t\t\tif (this.first instanceof Future) {\r\n\t\t\t\t\tassert(this.first.state === STATE_RESOLVED);\r\n\r\n\t\t\t\t\tthis.resolve(this.first.value);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.resolve(this.first);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tFutureJoin.prototype.onRejected = function (error) {\r\n\t\tif (this.state === STATE_LISTEN) {\r\n\t\t\tthis.reject(error);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction join (first, second) {\r\n\t\tif (first instanceof Future && first.state === STATE_REJECTED) {\r\n\t\t\treturn first;\r\n\t\t} else if (second instanceof Future) {\r\n\t\t\tif (second.state === STATE_RESOLVED) {\r\n\t\t\t\treturn first;\r\n\t\t\t} else if (second.state === STATE_REJECTED) {\r\n\t\t\t\treturn second;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn first;\r\n\t\t}\r\n\r\n\t\tif (!(first instanceof FutureJoin)) {\r\n\t\t\tfirst = new FutureJoin(first);\r\n\t\t}\r\n\r\n\t\tfirst.missing += 1;\r\n\t\tsecond.register(first);\r\n\r\n\t\treturn first;\r\n\t}\r\n\r\n\t// ------- TASYNC -------\r\n\r\n\tvar TASYNC = {\r\n\t\tsetTrace: setTrace,\r\n\t\tdelay: delay,\r\n\t\tlift: lift,\r\n\t\tapply: apply,\r\n\t\tcall: call,\r\n\t\ttrycatch: trycatch,\r\n\t\twrap: wrap,\r\n\t\tunwrap: unwrap,\r\n\t\tthrottle: throttle,\r\n\t\tjoin: join\r\n\t};\r\n\r\n\tif (typeof define === \"function\" && define.amd) {\r\n\t\tdefine('core/tasync',[], function () {\r\n\t\t\treturn TASYNC;\r\n\t\t});\r\n\t} else {\r\n\t\tmodule.exports = TASYNC;\r\n\t}\r\n}());\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('core/coretree',[ \"util/assert\", \"util/key\", \"core/future\", \"core/tasync\", 'util/canon' ], function (ASSERT, GENKEY, FUTURE, TASYNC, CANON) {\r\n\t\"use strict\";\r\n\r\n\tvar HASH_REGEXP = new RegExp(\"#[0-9a-f]{40}\");\r\n\tvar isValidHash = function (key) {\r\n\t\treturn typeof key === \"string\" && key.length === 41 && HASH_REGEXP.test(key);\r\n\t};\r\n\r\n\tvar MAX_RELID = Math.pow(2, 31);\r\n\tvar createRelid = function (data) {\r\n\t\tASSERT(data && typeof data === \"object\");\r\n\r\n\t\tvar relid;\r\n\t\tdo {\r\n\t\t\trelid = Math.floor(Math.random() * MAX_RELID);\r\n\t\t\t// relid = relid.toString();\r\n\t\t} while (data[relid] !== undefined);\r\n\r\n\t\treturn \"\" + relid;\r\n\t};\r\n\r\n\t// make relids deterministic\r\n\tif (false) {\r\n\t\tvar nextRelid = 0;\r\n\t\tcreateRelid = function (data) {\r\n\t\t\tASSERT(data && typeof data === \"object\");\r\n\r\n\t\t\tvar relid;\r\n\t\t\tdo {\r\n\t\t\t\trelid = (nextRelid += -1);\r\n\t\t\t} while (data[relid] !== undefined);\r\n\r\n\t\t\treturn \"\" + relid;\r\n\t\t};\r\n\t}\r\n\r\n\tvar rootCounter = 0;\r\n\r\n\treturn function (storage, options) {\r\n\t\tvar MAX_AGE = (options && options.maxage) || 3;\r\n\t\tvar MAX_TICKS = (options && options.maxticks) || 2000;\r\n\t\tvar MAX_MUTATE = (options && options.maxmutate) || 30000;\r\n\t\tvar autopersist = (options && options.autopersist) || false;\r\n\r\n\t\tvar ID_NAME = storage.ID_NAME;\r\n\t\tvar EMPTY_DATA = {};\r\n\r\n\t\tvar roots = [];\r\n\t\tvar ticks = 0;\r\n\r\n\t\tstorage.loadObject = TASYNC.wrap(storage.loadObject);\r\n\t\tstorage.insertObject = FUTURE.adapt(storage.insertObject);\r\n\t\tstorage.fsyncDatabase = FUTURE.adapt(storage.fsyncDatabase);\r\n\r\n\t\t// ------- static methods\r\n\r\n\t\tvar getParent = function (node) {\r\n\t\t\tASSERT(typeof node.parent === \"object\");\r\n\r\n\t\t\treturn node.parent;\r\n\t\t};\r\n\r\n\t\tvar getRelid = function (node) {\r\n\t\t\tASSERT(node.relid === null || typeof node.relid === \"string\");\r\n\r\n\t\t\treturn node.relid;\r\n\t\t};\r\n\r\n\t\tvar getLevel = function (node) {\r\n\t\t\tvar level = 0;\r\n\t\t\twhile (node.parent !== null) {\r\n\t\t\t\t++level;\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn level;\r\n\t\t};\r\n\r\n\t\tvar getRoot = function (node) {\r\n\t\t\twhile (node.parent !== null) {\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar getPath = function (node, base) {\r\n\t\t\tif (node === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar path = \"\";\r\n\t\t\twhile (node.relid !== null && node !== base) {\r\n\t\t\t\tpath = \"/\" + node.relid + path;\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn path;\r\n\t\t};\r\n\r\n\t\tvar isValidPath = function (path) {\r\n\t\t\treturn typeof path === \"string\" && (path === \"\" || path.charAt(0) === \"/\");\r\n\t\t};\r\n\r\n\t\tvar splitPath = function (path) {\r\n\t\t\tASSERT(isValidPath(path));\r\n\r\n\t\t\tpath = path.split(\"/\");\r\n\t\t\tpath.splice(0, 1);\r\n\r\n\t\t\treturn path;\r\n\t\t};\r\n\r\n\t\tvar buildPath = function (path) {\r\n\t\t\tASSERT(path instanceof Array);\r\n\r\n\t\t\treturn path.length === 0 ? \"\" : \"/\" + path.join(\"/\");\r\n\t\t};\r\n\r\n\t\tvar joinPaths = function (first, second) {\r\n\t\t\tASSERT(isValidPath(first) && isValidPath(second));\r\n\r\n\t\t\treturn first + second;\r\n\t\t};\r\n\r\n        var getCommonPathPrefixData = function (first, second) {\r\n            ASSERT(typeof first === \"string\" && typeof second === \"string\");\r\n\r\n            first = splitPath(first);\r\n            second = splitPath(second);\r\n\r\n            var common = [];\r\n            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {\r\n                common.push(first[i]);\r\n            }\r\n\r\n            return {\r\n                common: buildPath(common),\r\n                first: buildPath(first.slice(i)),\r\n                firstLength: first.length - i,\r\n                second: buildPath(second.slice(i)),\r\n                secondLength: second.length - i\r\n            };\r\n        };\r\n\r\n\t\t// ------- memory management\r\n\r\n\t\tvar __detachChildren = function (node) {\r\n\t\t\tASSERT(node.children instanceof Array && node.age >= MAX_AGE - 1);\r\n\r\n\t\t\tvar children = node.children;\r\n\t\t\tnode.children = null;\r\n\t\t\tnode.age = MAX_AGE;\r\n\r\n\t\t\tfor (var i = 0; i < children.length; ++i) {\r\n\t\t\t\t__detachChildren(children[i]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __ageNodes = function (nodes) {\r\n\t\t\tASSERT(nodes instanceof Array);\r\n\r\n\t\t\tvar i = nodes.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tvar node = nodes[i];\r\n\r\n\t\t\t\tASSERT(node.age < MAX_AGE);\r\n\t\t\t\tif (++node.age >= MAX_AGE) {\r\n\t\t\t\t\tnodes.splice(i, 1);\r\n\t\t\t\t\t__detachChildren(node);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t__ageNodes(node.children);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __ageRoots = function () {\r\n\t\t\tif (++ticks >= MAX_TICKS) {\r\n\t\t\t\tticks = 0;\r\n\t\t\t\t__ageNodes(roots);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __getChildNode = function (children, relid) {\r\n\t\t\tASSERT(children instanceof Array && typeof relid === \"string\");\r\n\r\n\t\t\tfor (var i = 0; i < children.length; ++i) {\r\n\t\t\t\tvar child = children[i];\r\n\t\t\t\tif (child.relid === relid) {\r\n\t\t\t\t\tASSERT(child.parent.age === 0);\r\n\r\n\t\t\t\t\tchild.age = 0;\r\n\t\t\t\t\treturn child;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\tvar __getChildData = function (data, relid) {\r\n\t\t\tASSERT(typeof relid === \"string\");\r\n\r\n\t\t\tif (typeof data === \"object\" && data !== null) {\r\n\t\t\t\tdata = data[relid];\r\n\t\t\t\treturn typeof data === \"undefined\" ? EMPTY_DATA : data;\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar normalize = function (node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\t\t\t// console.log(\"normalize start\", printNode(getRoot(node)));\r\n\r\n\t\t\tvar parent;\r\n\r\n\t\t\tif (node.children === null) {\r\n\t\t\t\tASSERT(node.age === MAX_AGE);\r\n\r\n\t\t\t\tif (node.parent !== null) {\r\n\t\t\t\t\tparent = normalize(node.parent);\r\n\r\n\t\t\t\t\tvar temp = __getChildNode(parent.children, node.relid);\r\n\t\t\t\t\tif (temp !== null) {\r\n\t\t\t\t\t\t// TODO: make the current node close to the returned one\r\n\r\n\t\t\t\t\t\t// console.log(\"normalize end1\",\r\n\t\t\t\t\t\t// printNode(getRoot(temp)));\r\n\t\t\t\t\t\treturn temp;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);\r\n\t\t\t\t\tASSERT(__getChildNode(parent.children, node.relid) === null);\r\n\r\n\t\t\t\t\tnode.parent = parent;\r\n\t\t\t\t\tparent.children.push(node);\r\n\r\n\t\t\t\t\ttemp = __getChildData(parent.data, node.relid);\r\n\t\t\t\t\tif (!isValidHash(temp) || temp !== __getChildData(node.data, ID_NAME)) {\r\n\t\t\t\t\t\tnode.data = temp;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\troots.push(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.age = 0;\r\n\t\t\t\tnode.children = [];\r\n\t\t\t} else if (node.age !== 0) {\r\n\t\t\t\tparent = node;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tparent.age = 0;\r\n\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t} while (parent !== null && parent.age !== 0);\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"normalize end2\", printNode(getRoot(node)));\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\t// ------- hierarchy\r\n\r\n\t\tvar getAncestor = function (first, second) {\r\n\t\t\tASSERT(getRoot(first) === getRoot(second));\r\n\r\n\t\t\tfirst = normalize(first);\r\n\t\t\tsecond = normalize(second);\r\n\r\n\t\t\tvar a = [];\r\n\t\t\tdo {\r\n\t\t\t\ta.push(first);\r\n\t\t\t\tfirst = first.parent;\r\n\t\t\t} while (first !== null);\r\n\r\n\t\t\tvar b = [];\r\n\t\t\tdo {\r\n\t\t\t\tb.push(second);\r\n\t\t\t\tsecond = second.parent;\r\n\t\t\t} while (second !== null);\r\n\r\n\t\t\tvar i = a.length - 1;\r\n\t\t\tvar j = b.length - 1;\r\n\t\t\twhile (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {\r\n\t\t\t\t--i;\r\n\t\t\t\t--j;\r\n\t\t\t}\r\n\r\n\t\t\tASSERT(a[i] === b[j]);\r\n\t\t\treturn a[i];\r\n\t\t};\r\n\r\n\t\tvar isAncestor = function (node, ancestor) {\r\n\t\t\tASSERT(getRoot(node) === getRoot(ancestor));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tancestor = normalize(ancestor);\r\n\r\n\t\t\tdo {\r\n\t\t\t\tif (node === ancestor) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t} while (node !== null);\r\n\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t\tvar createRoot = function () {\r\n\t\t\tvar root = {\r\n\t\t\t\tparent: null,\r\n\t\t\t\trelid: null,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: {\r\n\t\t\t\t\t_mutable: true\r\n\t\t\t\t},\r\n\t\t\t\trootid: ++rootCounter\r\n\t\t\t};\r\n\t\t\troot.data[ID_NAME] = \"\";\r\n\t\t\troots.push(root);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn root;\r\n\t\t};\r\n\r\n\t\tvar getChild = function (node, relid) {\r\n\t\t\tASSERT(typeof relid === \"string\" && relid !== ID_NAME);\r\n\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tvar child = __getChildNode(node.children, relid);\r\n\t\t\tif (child !== null) {\r\n\t\t\t\treturn child;\r\n\t\t\t}\r\n\r\n\t\t\tchild = {\r\n\t\t\t\tparent: node,\r\n\t\t\t\trelid: relid,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: __getChildData(node.data, relid)\r\n\t\t\t};\r\n\t\t\tnode.children.push(child);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn child;\r\n\t\t};\r\n\r\n\t\tvar createChild = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (typeof node.data !== \"object\" || node.data === null) {\r\n\t\t\t\tthrow new Error(\"invalid node data\");\r\n\t\t\t}\r\n\r\n\t\t\tvar relid = createRelid(node.data);\r\n\t\t\tvar child = {\r\n\t\t\t\tparent: node,\r\n\t\t\t\trelid: relid,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: EMPTY_DATA\r\n\t\t\t};\r\n\r\n\t\t\t// TODO: make sure that it is not on the list\r\n\t\t\tnode.children.push(child);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn child;\r\n\t\t};\r\n\r\n\t\tvar getDescendant = function (node, head, base) {\r\n\t\t\tASSERT(typeof base === \"undefined\" || isAncestor(head, base));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\thead = normalize(head);\r\n\t\t\tbase = typeof base === \"undefined\" ? null : normalize(base.parent);\r\n\r\n\t\t\tvar path = [];\r\n\t\t\twhile (head.parent !== base) {\r\n\t\t\t\tpath.push(head.relid);\r\n\t\t\t\thead = head.parent;\r\n\t\t\t}\r\n\r\n\t\t\tvar i = path.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tnode = getChild(node, path[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar getDescendantByPath = function (node, path) {\r\n\t\t\tASSERT(path === \"\" || path.charAt(0) === \"/\");\r\n\r\n\t\t\tpath = path.split(\"/\");\r\n\r\n\t\t\tfor (var i = 1; i < path.length; ++i) {\r\n\t\t\t\tnode = getChild(node, path[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\t// ------- data manipulation\r\n\r\n\t\tvar __isMutableData = function (data) {\r\n\t\t\treturn typeof data === \"object\" && data !== null && data._mutable === true;\r\n\t\t};\r\n\r\n\t\tvar isMutable = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\t\t\treturn __isMutableData(node.data);\r\n\t\t};\r\n\r\n\t\tvar isObject = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\t\t\treturn typeof node.data === \"object\" && node.data !== null;\r\n\t\t};\r\n\r\n\t\tvar isEmpty = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (typeof node.data !== \"object\" || node.data === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if (node.data === EMPTY_DATA) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn __isEmptyData(node.data);\r\n\t\t};\r\n\r\n\t\tvar __isEmptyData = function (data) {\r\n\t\t\tfor (var keys in data) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\tvar __areEquivalent = function (data1, data2) {\r\n\t\t\treturn data1 === data2 || (typeof data1 === \"string\" && data1 === __getChildData(data2, ID_NAME)) || (__isEmptyData(data1) && __isEmptyData(data2));\r\n\t\t};\r\n\r\n\t\tvar mutateCount = 0;\r\n\t\tvar mutate = function (node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tvar data = node.data;\r\n\r\n\t\t\tif (typeof data !== \"object\" || data === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if (data._mutable === true) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: infinite cycle if MAX_MUTATE is smaller than depth!\r\n\t\t\tif (autopersist && ++mutateCount > MAX_MUTATE) {\r\n\t\t\t\tmutateCount = 0;\r\n\r\n\t\t\t\tfor (var i = 0; i < roots.length; ++i) {\r\n\t\t\t\t\tif (__isMutableData(roots[i].data)) {\r\n\t\t\t\t\t\t__saveData(roots[i].data);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (node.parent !== null && !mutate(node.parent)) {\r\n\t\t\t\t// this should never happen\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar copy = {\r\n\t\t\t\t_mutable: true\r\n\t\t\t};\r\n\r\n\t\t\tfor (var key in data) {\r\n\t\t\t\tcopy[key] = data[key];\r\n\t\t\t}\r\n\r\n\t\t\tASSERT(copy._mutable === true);\r\n\r\n\t\t\tif (typeof data[ID_NAME] === \"string\") {\r\n\t\t\t\tcopy[ID_NAME] = \"\";\r\n\t\t\t}\r\n\r\n\t\t\tif (node.parent !== null) {\r\n\t\t\t\tASSERT(__areEquivalent(__getChildData(node.parent.data, node.relid), node.data));\r\n\t\t\t\tnode.parent.data[node.relid] = copy;\r\n\t\t\t}\r\n\r\n\t\t\tnode.data = copy;\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\tvar getData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tASSERT(!__isMutableData(node.data));\r\n\t\t\treturn node.data;\r\n\t\t};\r\n\r\n\t\tvar __reloadChildrenData = function (node) {\r\n\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\tvar child = node.children[i];\r\n\r\n\t\t\t\tvar data = __getChildData(node.data, child.relid);\r\n\t\t\t\tif (!isValidHash(data) || data !== __getChildData(child.data, ID_NAME)) {\r\n\t\t\t\t\tchild.data = data;\r\n\t\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar setData = function (node, data) {\r\n\t\t\tASSERT(data !== null && typeof data !== \"undefined\");\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (node.parent !== null) {\r\n\t\t\t\tif (!mutate(node.parent)) {\r\n\t\t\t\t\tthrow new Error(\"incorrect node data\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.parent.data[node.relid] = data;\r\n\t\t\t}\r\n\r\n\t\t\tnode.data = data;\r\n\t\t\t__reloadChildrenData(node);\r\n\t\t};\r\n\r\n\t\tvar deleteData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (node.parent !== null) {\r\n\t\t\t\tif (!mutate(node.parent)) {\r\n\t\t\t\t\tthrow new Error(\"incorrect node data\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete node.parent.data[node.relid];\r\n\t\t\t}\r\n\r\n\t\t\tvar data = node.data;\r\n\r\n\t\t\tnode.data = EMPTY_DATA;\r\n\t\t\t__reloadChildrenData(node);\r\n\r\n\t\t\treturn data;\r\n\t\t};\r\n\r\n\t\tvar copyData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (typeof node.data !== \"object\" || node.data === null) {\r\n\t\t\t\treturn node.data;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: return immutable data without coping\r\n\t\t\treturn JSON.parse(JSON.stringify(node.data));\r\n\t\t};\r\n\r\n\t\tvar getProperty = function (node, name) {\r\n\t\t\tASSERT(typeof name === \"string\" && name !== ID_NAME);\r\n\r\n\t\t\tvar data;\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (typeof node.data === \"object\" && node.data !== null) {\r\n\t\t\t\tdata = node.data[name];\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: corerel uses getProperty to get the overlay content which can get mutable\r\n\t\t\t// ASSERT(!__isMutableData(data));\r\n\t\t\treturn data;\r\n\t\t};\r\n\r\n\t\tvar setProperty = function (node, name, data) {\r\n\t\t\tASSERT(typeof name === \"string\" && name !== ID_NAME);\r\n\t\t\tASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined); //TODO is the 'null' really can be a value of a property???\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (!mutate(node)) {\r\n\t\t\t\tthrow new Error(\"incorrect node data\");\r\n\t\t\t}\r\n\r\n\t\t\tnode.data[name] = data;\r\n\r\n\t\t\tvar child = __getChildNode(node.children, name);\r\n\t\t\tif (child !== null) {\r\n\t\t\t\tchild.data = data;\r\n\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar deleteProperty = function (node, name) {\r\n\t\t\tASSERT(typeof name === \"string\" && name !== ID_NAME);\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (!mutate(node)) {\r\n\t\t\t\tthrow new Error(\"incorrect node data\");\r\n\t\t\t}\r\n\r\n\t\t\tdelete node.data[name];\r\n\r\n\t\t\tvar child = __getChildNode(node.children, name);\r\n\t\t\tif (child !== null) {\r\n\t\t\t\tchild.data = EMPTY_DATA;\r\n\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar noUnderscore = function (relid) {\r\n\t\t\tASSERT(typeof relid === \"string\");\r\n\t\t\treturn relid.charAt(0) !== \"_\";\r\n\t\t};\r\n\r\n\t\tvar getKeys = function (node, predicate) {\r\n\t\t\tASSERT(typeof predicate === \"undefined\" || typeof predicate === \"function\");\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tpredicate = predicate || noUnderscore;\r\n\r\n\t\t\tif (typeof node.data !== \"object\" || node.data === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar keys = Object.keys(node.data);\r\n\r\n\t\t\tvar i = keys.length;\r\n\t\t\twhile (--i >= 0 && !predicate(keys[i])) {\r\n\t\t\t\tkeys.pop();\r\n\t\t\t}\r\n\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tif (!predicate(keys[i])) {\r\n\t\t\t\t\tkeys[i] = keys.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn keys;\r\n\t\t};\r\n\r\n\t\t// ------- persistence\r\n\r\n\t\tvar getHash = function (node) {\r\n\t\t\tif (node === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar hash;\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (typeof node.data === \"object\" && node.data !== null) {\r\n\t\t\t\thash = node.data[ID_NAME];\r\n\t\t\t}\r\n\r\n\t\t\tASSERT(typeof hash === \"string\" || typeof hash === \"undefined\");\r\n\t\t\treturn hash;\r\n\t\t};\r\n\r\n\t\tvar isHashed = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\t\t\treturn typeof node.data === \"object\" && node.data !== null && typeof node.data[ID_NAME] === \"string\";\r\n\t\t};\r\n\r\n\t\tvar setHashed = function (node, hashed) {\r\n\t\t\tASSERT(typeof hashed === \"boolean\");\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (!mutate(node)) {\r\n\t\t\t\tthrow new Error(\"incorrect node data\");\r\n\t\t\t}\r\n\r\n\t\t\tif (hashed) {\r\n\t\t\t\tnode.data[ID_NAME] = \"\";\r\n\t\t\t} else {\r\n\t\t\t\tdelete node.data[ID_NAME];\r\n\t\t\t}\r\n\r\n\t\t\tASSERT(typeof node.children[ID_NAME] === \"undefined\");\r\n\t\t};\r\n\r\n\t\tvar __saveData = function (data) {\r\n\t\t\tASSERT(__isMutableData(data));\r\n\r\n\t\t\tvar done = EMPTY_DATA;\r\n\t\t\tdelete data._mutable;\r\n\r\n\t\t\tfor (var relid in data) {\r\n\t\t\t\tvar child = data[relid];\r\n\t\t\t\tif (__isMutableData(child)) {\r\n\t\t\t\t\tvar sub = __saveData(child);\r\n\t\t\t\t\tif (sub === EMPTY_DATA) {\r\n\t\t\t\t\t\tdelete data[relid];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdone = FUTURE.join(done, sub);\r\n\t\t\t\t\t\tif (typeof child[ID_NAME] === \"string\") {\r\n\t\t\t\t\t\t\tdata[relid] = child[ID_NAME];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdone = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (done !== EMPTY_DATA) {\r\n\t\t\t\tvar hash = data[ID_NAME];\r\n\t\t\t\tASSERT(hash === \"\" || typeof hash === \"undefined\");\r\n\r\n\t\t\t\tif (hash === \"\") {\r\n\t\t\t\t\thash = \"#\" + GENKEY(data);\r\n\t\t\t\t\tdata[ID_NAME] = hash;\r\n\r\n\t\t\t\t\tdone = FUTURE.join(done, storage.insertObject(data));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn done;\r\n\t\t};\r\n\r\n\t\tvar persist = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (!__isMutableData(node.data)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar done = __saveData(node.data);\r\n\t\t\treturn FUTURE.join(done, storage.fsyncDatabase());\r\n\t\t};\r\n\r\n\t\tvar loadRoot = function (hash) {\r\n\t\t\tASSERT(isValidHash(hash));\r\n\r\n\t\t\treturn TASYNC.call(__loadRoot2, storage.loadObject(hash));\r\n\t\t};\r\n\r\n\t\tvar __loadRoot2 = function (data) {\r\n\t\t\tvar root = {\r\n\t\t\t\tparent: null,\r\n\t\t\t\trelid: null,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: data,\r\n\t\t\t\trootid: ++rootCounter\r\n\t\t\t};\r\n\t\t\troots.push(root);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn root;\r\n\t\t};\r\n\r\n\t\tvar loadChild = function (node, relid) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = getChild(node, relid);\r\n\r\n\t\t\tif (isValidHash(node.data)) {\r\n\t\t\t\t// TODO: this is a hack, we should avoid loading it multiple\r\n\t\t\t\t// times\r\n\t\t\t\treturn TASYNC.call(__loadChild2, node, storage.loadObject(node.data));\r\n\t\t\t} else {\r\n\t\t\t\treturn typeof node.data === \"object\" && node.data !== null ? node : null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n        var getChildHash = function(node,relid){\r\n            ASSERT(isValidNode(node));\r\n\r\n            node = getChild(node, relid);\r\n\r\n            if (isValidHash(node.data)) {\r\n                // TODO: this is a hack, we should avoid loading it multiple\r\n                // times\r\n                return node.data;\r\n            } else {\r\n                return typeof node.data === \"object\" && node.data !== null ? getHash(node) : null;\r\n            }\r\n        };\r\n\r\n\r\n\r\n\t\tvar __loadChild2 = function (node, newdata) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\t// TODO: this is a hack, we should avoid loading it multiple times\r\n\t\t\tif (isValidHash(node.data)) {\r\n\t\t\t\tASSERT(node.data === newdata[ID_NAME]);\r\n\r\n\t\t\t\tnode.data = newdata;\r\n\t\t\t\t__reloadChildrenData(node);\r\n\t\t\t} else {\r\n\t\t\t\t// TODO: if this bites you, use the Cache\r\n                /*if(node.data !== newdata){\r\n                    console.log(\"kecso\",node);\r\n                }\r\n\t\t\t\tASSERT(node.data === newdata);*/\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar loadByPath = function (node, path) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\t\t\tASSERT(path === \"\" || path.charAt(0) === \"/\");\r\n\r\n\t\t\tpath = path.split(\"/\");\r\n\t\t\treturn __loadDescendantByPath2(node, path, 1);\r\n\t\t};\r\n\r\n\t\tvar __loadDescendantByPath2 = function (node, path, index) {\r\n\t\t\tif (node === null || index === path.length) {\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tvar child = loadChild(node, path[index]);\r\n\t\t\treturn TASYNC.call(__loadDescendantByPath2, child, path, index + 1);\r\n\t\t};\r\n\r\n\t\t// ------- valid -------\r\n\r\n\t\tvar printNode = function (node) {\r\n\t\t\tvar str = \"{\";\r\n\t\t\tstr += \"age:\" + node.age;\r\n\r\n\t\t\tif (typeof node.relid === \"string\") {\r\n\t\t\t\tstr += \", relid: \\\"\" + node.relid + \"\\\"\";\r\n\t\t\t}\r\n\r\n\t\t\tstr += \", children:\";\r\n\t\t\tif (node.children === null) {\r\n\t\t\t\tstr += \"null\";\r\n\t\t\t} else {\r\n\t\t\t\tstr += \"[\";\r\n\t\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\t\tif (i !== 0) {\r\n\t\t\t\t\t\tstr += \", \";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstr += printNode(node.children[i]);\r\n\t\t\t\t}\r\n\t\t\t\tstr += \"]\";\r\n\t\t\t}\r\n\r\n\t\t\tstr += \"}\";\r\n\t\t\treturn str;\r\n\t\t};\r\n\r\n\t\tvar __test = function (text, cond) {\r\n\t\t\tif (!cond) {\r\n\t\t\t\tthrow new Error(text);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar checkValidTree = function (node) {\r\n\t\t\tif (isValidNode(node)) {\r\n\t\t\t\tif (node.children instanceof Array) {\r\n\t\t\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\t\t\tcheckValidTree(node.children[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// disable checking for now\r\n\t\tvar checkValidTreeRunning = true;\r\n\r\n\t\tvar isValidNode = function (node) {\r\n\t\t\ttry {\r\n\t\t\t\t__test(\"object\", typeof node === \"object\" && node !== null);\r\n\t\t\t\t__test(\"object 2\", node.hasOwnProperty(\"parent\") && node.hasOwnProperty(\"relid\"));\r\n\t\t\t\t__test(\"parent\", typeof node.parent === \"object\");\r\n\t\t\t\t__test(\"relid\", typeof node.relid === \"string\" || node.relid === null);\r\n\t\t\t\t__test(\"parent 2\", (node.parent === null) === (node.relid === null));\r\n\t\t\t\t__test(\"age\", node.age >= 0 && node.age <= MAX_AGE);\r\n\t\t\t\t__test(\"children\", node.children === null || node.children instanceof Array);\r\n\t\t\t\t__test(\"children 2\", (node.age === MAX_AGE) === (node.children === null));\r\n\t\t\t\t__test(\"data\", typeof node.data === \"object\" || typeof node.data === \"string\" || typeof node.data === \"number\");\r\n\r\n\t\t\t\tif (node.parent !== null) {\r\n\t\t\t\t\t__test(\"age 2\", node.age >= node.parent.age);\r\n\t\t\t\t\t__test(\"mutable\", !__isMutableData(node.data) || __isMutableData(node.parent.data));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!checkValidTreeRunning) {\r\n\t\t\t\t\tcheckValidTreeRunning = true;\r\n\t\t\t\t\tcheckValidTree(getRoot(node));\r\n\t\t\t\t\tcheckValidTreeRunning = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.log(\"Wrong node\", error.stack);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tgetParent: getParent,\r\n\t\t\tgetRelid: getRelid,\r\n\t\t\tgetLevel: getLevel,\r\n\t\t\tgetRoot: getRoot,\r\n\t\t\tgetPath: getPath,\r\n\t\t\tisValidPath: isValidPath,\r\n\t\t\tsplitPath: splitPath,\r\n\t\t\tbuildPath: buildPath,\r\n\t\t\tjoinPaths: joinPaths,\r\n\t\t\tgetCommonPathPrefixData: getCommonPathPrefixData,\r\n\r\n\t\t\tnormalize: normalize,\r\n\t\t\tgetAncestor: getAncestor,\r\n\t\t\tisAncestor: isAncestor,\r\n\t\t\tcreateRoot: createRoot,\r\n\t\t\tcreateChild: createChild,\r\n\t\t\tgetChild: getChild,\r\n\t\t\tgetDescendant: getDescendant,\r\n\t\t\tgetDescendantByPath: getDescendantByPath,\r\n\r\n\t\t\tisMutable: isMutable,\r\n\t\t\tisObject: isObject,\r\n\t\t\tisEmpty: isEmpty,\r\n\t\t\tmutate: mutate,\r\n\t\t\tgetData: getData,\r\n\t\t\tsetData: setData,\r\n\t\t\tdeleteData: deleteData,\r\n\t\t\tcopyData: copyData,\r\n\t\t\tgetProperty: getProperty,\r\n\t\t\tsetProperty: setProperty,\r\n\t\t\tdeleteProperty: deleteProperty,\r\n\t\t\tgetKeys: getKeys,\r\n\r\n\t\t\tisHashed: isHashed,\r\n\t\t\tsetHashed: setHashed,\r\n\t\t\tgetHash: getHash,\r\n\t\t\tpersist: TASYNC.wrap(FUTURE.unadapt(persist)),\r\n\t\t\tloadRoot: loadRoot,\r\n\t\t\tloadChild: loadChild,\r\n\t\t\tloadByPath: loadByPath,\r\n\r\n\t\t\tisValidNode: isValidNode,\r\n\r\n            getChildHash: getChildHash\r\n\t\t};\r\n\t};\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('core/corerel',[ \"util/assert\", \"core/coretree\", \"core/tasync\", \"util/canon\" ], function (ASSERT, CoreTree, TASYNC, CANON) {\r\n\t\"use strict\";\r\n\r\n\t// ----------------- RELID -----------------\r\n\r\n\tvar ATTRIBUTES = \"atr\";\r\n\tvar REGISTRY = \"reg\";\r\n\tvar OVERLAYS = \"ovr\";\r\n\tvar COLLSUFFIX = \"-inv\";\r\n\r\n\tfunction isPointerName(name) {\r\n\t\tASSERT(typeof name === \"string\");\r\n        //TODO this is needed as now we work with modified data as well\r\n        if(name === \"_mutable\"){\r\n            return false;\r\n        }\r\n\t\treturn name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\r\n\t}\r\n\r\n\tfunction isValidRelid(relid) {\r\n\t\treturn typeof relid === \"string\" && parseInt(relid, 10).toString() === relid;\r\n\t}\r\n\r\n\tfunction __test(text, cond) {\r\n\t\tif (!cond) {\r\n\t\t\tthrow new Error(text);\r\n\t\t}\r\n\t}\r\n\r\n\t// ----------------- Core -----------------\r\n\r\n\tfunction CoreRel(coretree) {\r\n\t\tASSERT(typeof coretree == \"object\");\r\n\r\n\t\tfunction isValidNode(node) {\r\n\t\t\ttry {\r\n\t\t\t\t__test(\"coretree\", coretree.isValidNode(node));\r\n\t\t\t\t__test(\"isobject\", coretree.isObject(node));\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.log(\"Wrong node\", error.stack);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction getAttributeNames(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = coretree.getChild(node, ATTRIBUTES);\r\n\t\t\tvar keys = coretree.getKeys(node);\r\n\t\t\tvar i = keys.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tif (keys[i].charAt(0) === \"\") {\r\n\t\t\t\t\tconsole.log(\"***** This happens?\");\r\n\t\t\t\t\tkeys.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn keys;\r\n\t\t}\r\n\r\n\t\tfunction getRegistryNames(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = coretree.getChild(node, REGISTRY);\r\n\t\t\tvar keys = coretree.getKeys(node);\r\n\t\t\tvar i = keys.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tif (keys[i].charAt(0) === \"\") {\r\n\t\t\t\t\tconsole.log(\"***** This happens?\");\r\n\t\t\t\t\tkeys.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn keys;\r\n\t\t}\r\n\r\n\t\tfunction getAttribute(node, name) {\r\n\t\t\tnode = coretree.getChild(node, ATTRIBUTES);\r\n\t\t\treturn coretree.getProperty(node, name);\r\n\t\t}\r\n\r\n\t\tfunction delAttribute(node, name) {\r\n\t\t\tnode = coretree.getChild(node, ATTRIBUTES);\r\n\t\t\tcoretree.deleteProperty(node, name);\r\n\t\t}\r\n\r\n\t\tfunction setAttribute(node, name, value) {\r\n\t\t\tnode = coretree.getChild(node, ATTRIBUTES);\r\n\t\t\tcoretree.setProperty(node, name, value);\r\n\t\t}\r\n\r\n\t\tfunction getRegistry(node, name) {\r\n\t\t\tnode = coretree.getChild(node, REGISTRY);\r\n\t\t\treturn coretree.getProperty(node, name);\r\n\t\t}\r\n\r\n\t\tfunction delRegistry(node, name) {\r\n\t\t\tnode = coretree.getChild(node, REGISTRY);\r\n\t\t\tcoretree.deleteProperty(node, name);\r\n\t\t}\r\n\r\n\t\tfunction setRegistry(node, name, value) {\r\n\t\t\tnode = coretree.getChild(node, REGISTRY);\r\n\t\t\tcoretree.setProperty(node, name, value);\r\n\t\t}\r\n\r\n\t\tfunction overlayInsert(overlays, source, name, target) {\r\n\t\t\tASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\r\n\t\t\tASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\r\n\t\t\tASSERT(coretree.getCommonPathPrefixData(source, target).common === \"\");\r\n\r\n\t\t\t// console.log(\"insert\", overlays.parent.data.atr.name, source, name, target);\r\n\r\n\t\t\tvar node = coretree.getChild(overlays, source);\r\n\r\n\t\t\tASSERT(coretree.getProperty(node, name) === undefined);\r\n\t\t\tcoretree.setProperty(node, name, target);\r\n\r\n\t\t\tnode = coretree.getChild(overlays, target);\r\n\t\t\tname = name + COLLSUFFIX;\r\n\r\n\t\t\tvar array = coretree.getProperty(node, name);\r\n\t\t\tif (array) {\r\n\t\t\t\tASSERT(array.indexOf(source) < 0);\r\n\r\n\t\t\t\tarray = array.slice(0);\r\n\t\t\t\tarray.push(source);\r\n\t\t\t} else {\r\n\t\t\t\tarray = [ source ];\r\n\t\t\t}\r\n\r\n\t\t\tcoretree.setProperty(node, name, array);\r\n\t\t}\r\n\r\n\t\tfunction overlayRemove(overlays, source, name, target) {\r\n\t\t\tASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\r\n\t\t\tASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\r\n\t\t\tASSERT(coretree.getCommonPathPrefixData(source, target).common === \"\");\r\n\r\n\t\t\t// console.log(\"remove\", overlays.parent.data.atr.name, source, name, target);\r\n\r\n\t\t\tvar node = coretree.getChild(overlays, source);\r\n\t\t\tASSERT(node && coretree.getProperty(node, name) === target);\r\n\t\t\tcoretree.deleteProperty(node, name);\r\n\r\n\t\t\tnode = coretree.getChild(overlays, target);\r\n\t\t\tASSERT(node);\r\n\r\n\t\t\tname = name + COLLSUFFIX;\r\n\r\n\t\t\tvar array = coretree.getProperty(node, name);\r\n\t\t\tASSERT(Array.isArray(array) && array.length >= 1);\r\n\r\n\t\t\tif (array.length === 1) {\r\n\t\t\t\tASSERT(array[0] === source);\r\n\r\n\t\t\t\tcoretree.deleteProperty(node, name);\r\n\t\t\t} else {\r\n\t\t\t\tvar index = array.indexOf(source);\r\n\t\t\t\tASSERT(index >= 0);\r\n\r\n\t\t\t\tarray = array.slice(0);\r\n\t\t\t\tarray.splice(index, 1);\r\n\r\n\t\t\t\tcoretree.setProperty(node, name, array);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction overlayQuery(overlays, prefix) {\r\n\t\t\tASSERT(isValidNode(overlays) && coretree.isValidPath(prefix));\r\n\r\n\t\t\tvar prefix2 = prefix + \"/\";\r\n\t\t\tvar list = [];\r\n\t\t\tvar paths = coretree.getKeys(overlays);\r\n\r\n\t\t\tfor (var i = 0; i < paths.length; ++i) {\r\n\t\t\t\tvar path = paths[i];\r\n\t\t\t\tif (path === prefix || path.substr(0, prefix2.length) === prefix2) {\r\n\t\t\t\t\tvar node = coretree.getChild(overlays, path);\r\n\t\t\t\t\tvar names = coretree.getKeys(node);\r\n\t\t\t\t\tfor (var j = 0; j < names.length; ++j) {\r\n\t\t\t\t\t\tvar name = names[j];\r\n\t\t\t\t\t\tif (isPointerName(name)) {\r\n\t\t\t\t\t\t\tlist.push({\r\n\t\t\t\t\t\t\t\ts: path,\r\n\t\t\t\t\t\t\t\tn: name,\r\n\t\t\t\t\t\t\t\tt: coretree.getProperty(node, name),\r\n\t\t\t\t\t\t\t\tp: true\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar array = coretree.getProperty(node, name);\r\n\t\t\t\t\t\t\tASSERT(Array.isArray(array));\r\n\t\t\t\t\t\t\tname = name.slice(0, -COLLSUFFIX.length);\r\n\t\t\t\t\t\t\tfor (var k = 0; k < array.length; ++k) {\r\n\t\t\t\t\t\t\t\tlist.push({\r\n\t\t\t\t\t\t\t\t\ts: array[k],\r\n\t\t\t\t\t\t\t\t\tn: name,\r\n\t\t\t\t\t\t\t\t\tt: path,\r\n\t\t\t\t\t\t\t\t\tp: false\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(\"query\", overlays.parent.data.atr.name, prefix, list);\r\n\r\n\t\t\treturn list;\r\n\t\t}\r\n\r\n\t\tfunction createNode(parameters) {\r\n\t\t\tparameters = parameters || {};\r\n\t\t\tvar relid = parameters.relid,\r\n\t\t\t\tparent = parameters.parent;\r\n\r\n\t\t\tASSERT(!parent || isValidNode(parent));\r\n\t\t\tASSERT(!relid || typeof relid === 'string');\r\n\r\n\t\t\tvar node;\r\n\t\t\tif (parent) {\r\n\t\t\t\tif (relid) {\r\n\t\t\t\t\tnode = coretree.getChild(parent, relid);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnode = coretree.createChild(parent);\r\n\t\t\t\t}\r\n\t\t\t\tcoretree.setHashed(node, true);\r\n\t\t\t} else {\r\n\t\t\t\tnode = coretree.createRoot();\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n        function getDataForSingleHash(node) {\r\n            ASSERT(isValidNode(node));\r\n\r\n            var data = {\r\n                attributes: coretree.getProperty(node, ATTRIBUTES),\r\n                registry: coretree.getProperty(node, REGISTRY),\r\n                children: coretree.getKeys(node)\r\n            };\r\n            var prefix = \"\";\r\n\r\n            while (node) {\r\n                var overlays = coretree.getChild(node, OVERLAYS);\r\n                var rels = coretree.getProperty(overlays, prefix);\r\n                data[prefix] = rels;\r\n\r\n                prefix = \"/\" + coretree.getRelid(node) + prefix;\r\n                node = coretree.getParent(node);\r\n            }\r\n\r\n            data = JSON.stringify(data);\r\n            return data;\r\n        }\r\n\r\n\t\tfunction deleteNode(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar parent = coretree.getParent(node);\r\n\t\t\tvar prefix = \"/\" + coretree.getRelid(node);\r\n\t\t\tASSERT(parent !== null);\r\n\r\n\t\t\tcoretree.deleteProperty(parent, coretree.getRelid(node));\r\n\r\n\t\t\twhile (parent) {\r\n\t\t\t\tvar overlays = coretree.getChild(parent, OVERLAYS);\r\n\r\n\t\t\t\tvar list = overlayQuery(overlays, prefix);\r\n\t\t\t\tfor (var i = 0; i < list.length; ++i) {\r\n\t\t\t\t\tvar entry = list[i];\r\n\t\t\t\t\toverlayRemove(overlays, entry.s, entry.n, entry.t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tprefix = \"/\" + coretree.getRelid(parent) + prefix;\r\n\t\t\t\tparent = coretree.getParent(parent);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction copyNode(node, parent) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\t\t\tASSERT(!parent || isValidNode(parent));\r\n\r\n\t\t\tnode = coretree.normalize(node);\r\n\t\t\tvar newNode;\r\n\r\n\t\t\tif (parent) {\r\n\t\t\t\tvar ancestor = coretree.getAncestor(node, parent);\r\n\r\n\t\t\t\t// cannot copy inside of itself\r\n\t\t\t\tif (ancestor === node) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewNode = coretree.createChild(parent);\r\n\t\t\t\tcoretree.setHashed(newNode, true);\r\n\t\t\t\tcoretree.setData(newNode, coretree.copyData(node));\r\n\r\n\t\t\t\tvar ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\r\n\t\t\t\tvar ancestorNewPath = coretree.getPath(newNode, ancestor);\r\n\r\n\t\t\t\tvar base = coretree.getParent(node);\r\n\t\t\t\tvar baseOldPath = \"/\" + coretree.getRelid(node);\r\n\t\t\t\tvar aboveAncestor = 1;\r\n\r\n\t\t\t\twhile (base) {\r\n\t\t\t\t\tvar baseOverlays = coretree.getChild(base, OVERLAYS);\r\n\t\t\t\t\tvar list = overlayQuery(baseOverlays, baseOldPath);\r\n\t\t\t\t\tvar tempAncestor = coretree.getAncestor(base,ancestor);\r\n\r\n\t\t\t\t\taboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\r\n\r\n\t\t\t\t\tvar relativePath = aboveAncestor < 0 ? coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\r\n\r\n\t\t\t\t\tfor (var i = 0; i < list.length; ++i) {\r\n\t\t\t\t\t\tvar entry = list[i];\r\n\r\n\t\t\t\t\t\tif (entry.p) {\r\n\t\t\t\t\t\t\tASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\r\n\t\t\t\t\t\t\tASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === \"/\");\r\n\r\n\t\t\t\t\t\t\tvar source, target, overlays;\r\n\r\n\t\t\t\t\t\t\tif (aboveAncestor < 0) {\r\n\t\t\t\t\t\t\t\t//below ancestor node - further from root\r\n\t\t\t\t\t\t\t\tsource = ancestorNewPath + entry.s.substr(baseOldPath.length);\r\n\t\t\t\t\t\t\t\ttarget = coretree.joinPaths(relativePath, entry.t);\r\n\t\t\t\t\t\t\t\toverlays = ancestorOverlays;\r\n\t\t\t\t\t\t\t} else if (aboveAncestor === 0) {\r\n\t\t\t\t\t\t\t\t//at ancestor node\r\n\t\t\t\t\t\t\t\tvar data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\r\n\r\n\t\t\t\t\t\t\t\toverlays = newNode;\r\n\t\t\t\t\t\t\t\twhile (data.firstLength-- > 0) {\r\n\t\t\t\t\t\t\t\t\toverlays = coretree.getParent(overlays);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\toverlays = coretree.getChild(overlays, OVERLAYS);\r\n\r\n\t\t\t\t\t\t\t\tsource = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\r\n\t\t\t\t\t\t\t\ttarget = data.second;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t//above ancestor node - closer to root\r\n\t\t\t\t\t\t\t\tASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\r\n\r\n\t\t\t\t\t\t\t\tsource = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\r\n\t\t\t\t\t\t\t\ttarget = entry.t;\r\n\t\t\t\t\t\t\t\toverlays = baseOverlays;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\toverlayInsert(overlays, source, entry.n, target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbaseOldPath = \"/\" + coretree.getRelid(base) + baseOldPath;\r\n\t\t\t\t\tbase = coretree.getParent(base);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnewNode = coretree.createRoot();\r\n\t\t\t\tcoretree.setData(newNode, coretree.copyData(node));\r\n\t\t\t}\r\n\r\n\t\t\treturn newNode;\r\n\t\t}\r\n\r\n        //kecso\r\n        function copyNodes(nodes,parent){\r\n            //copying multiple nodes at once for keeping their internal relations\r\n            var paths = [],\r\n                i, j,index,names,pointer,\r\n                copiedNodes = [],\r\n                internalRelationPaths=[]; //every single element will be an object with the internally pointing relations and the index of the target\r\n\r\n            for(i=0;i<nodes.length;i++){\r\n                paths.push(coretree.getPath(nodes[i]));\r\n            }\r\n\r\n            for(i=0;i<nodes.length;i++){\r\n                names = getPointerNames(nodes[i]);\r\n                pointer = {};\r\n                for(j=0;j<names.length;j++){\r\n                    index = paths.indexOf(getPointerPath(nodes[i],names[j]));\r\n                    if(index !== -1){\r\n                        pointer[names[j]] = index;\r\n                    }\r\n                }\r\n                internalRelationPaths.push(pointer);\r\n            }\r\n\r\n            //now we use our simple copy\r\n            for(i=0;i<nodes.length;i++){\r\n                copiedNodes.push(copyNode(nodes[i],parent));\r\n            }\r\n\r\n            //and now back to the relations\r\n            for(i=0;i<internalRelationPaths.length;i++){\r\n                names = Object.keys(internalRelationPaths[i]);\r\n                for(j=0;j<names.length;j++){\r\n                    setPointer(copiedNodes[i],names[j],copiedNodes[internalRelationPaths[i][names[j]]]);\r\n                }\r\n            }\r\n\r\n            return copiedNodes;\r\n        }\r\n\r\n\t\tfunction moveNode(node, parent) {\r\n\t\t\tASSERT(isValidNode(node) && isValidNode(parent));\r\n\r\n\t\t\tnode = coretree.normalize(node);\r\n\t\t\tvar ancestor = coretree.getAncestor(node, parent);\r\n\r\n\t\t\t// cannot move inside of itself\r\n\t\t\tif (ancestor === node) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar base = coretree.getParent(node);\r\n\t\t\tvar baseOldPath = \"/\" + coretree.getRelid(node);\r\n\t\t\tvar aboveAncestor = 1;\r\n\r\n\t\t\tvar oldNode = node;\r\n\t\t\tnode = coretree.getChild(parent, coretree.getRelid(oldNode));\r\n\t\t\tif (!coretree.isEmpty(node)) {\r\n\t\t\t\t// we have to change the relid of the node, to fit into its new\r\n\t\t\t\t// place...\r\n\t\t\t\tnode = coretree.createChild(parent);\r\n\t\t\t}\r\n\t\t\tcoretree.setHashed(node, true);\r\n\t\t\tcoretree.setData(node, coretree.copyData(oldNode));\r\n\r\n\t\t\tvar ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\r\n\t\t\tvar ancestorNewPath = coretree.getPath(node, ancestor);\r\n\r\n\t\t\twhile (base) {\r\n\t\t\t\tvar baseOverlays = coretree.getChild(base, OVERLAYS);\r\n\t\t\t\tvar list = overlayQuery(baseOverlays, baseOldPath);\r\n\t\t\t\tvar tempAncestor = coretree.getAncestor(base,ancestor);\r\n\r\n\t\t\t\taboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\r\n\r\n\t\t\t\tvar relativePath = aboveAncestor < 0 ? coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\r\n\r\n\t\t\t\tfor (var i = 0; i < list.length; ++i) {\r\n\t\t\t\t\tvar entry = list[i];\r\n\r\n\t\t\t\t\toverlayRemove(baseOverlays, entry.s, entry.n, entry.t);\r\n\r\n\t\t\t\t\tvar tmp;\r\n\t\t\t\t\tif (!entry.p) {\r\n\t\t\t\t\t\ttmp = entry.s;\r\n\t\t\t\t\t\tentry.s = entry.t;\r\n\t\t\t\t\t\tentry.t = tmp;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\r\n\t\t\t\t\tASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === \"/\");\r\n\r\n\t\t\t\t\tvar source, target, overlays;\r\n\r\n\t\t\t\t\tif (aboveAncestor < 0) {\r\n\t\t\t\t\t\t//below ancestor node\r\n\t\t\t\t\t\tsource = ancestorNewPath + entry.s.substr(baseOldPath.length);\r\n\t\t\t\t\t\ttarget = coretree.joinPaths(relativePath, entry.t);\r\n\t\t\t\t\t\toverlays = ancestorOverlays;\r\n\t\t\t\t\t} else if (aboveAncestor === 0) {\r\n\t\t\t\t\t\t//at ancestor node\r\n\t\t\t\t\t\tvar data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\r\n\r\n\t\t\t\t\t\toverlays = node;\r\n\t\t\t\t\t\twhile (data.firstLength-- > 0) {\r\n\t\t\t\t\t\t\toverlays = coretree.getParent(overlays);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toverlays = coretree.getChild(overlays, OVERLAYS);\r\n\r\n\t\t\t\t\t\tsource = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\r\n\t\t\t\t\t\ttarget = data.second;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//above ancestor node\r\n\t\t\t\t\t\tASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\r\n\r\n\t\t\t\t\t\tsource = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\r\n\t\t\t\t\t\ttarget = entry.t;\r\n\t\t\t\t\t\toverlays = baseOverlays;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!entry.p) {\r\n\t\t\t\t\t\ttmp = entry.s;\r\n\t\t\t\t\t\tentry.s = entry.t;\r\n\t\t\t\t\t\tentry.t = tmp;\r\n\r\n\t\t\t\t\t\ttmp = source;\r\n\t\t\t\t\t\tsource = target;\r\n\t\t\t\t\t\ttarget = tmp;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//console.log(source, target);\r\n\t\t\t\t\toverlayInsert(overlays, source, entry.n, target);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseOldPath = \"/\" + coretree.getRelid(base) + baseOldPath;\r\n\t\t\t\tbase = coretree.getParent(base);\r\n\t\t\t}\r\n\r\n\t\t\tdeleteNode(oldNode);\r\n\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n\t\tfunction getChildrenRelids(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\treturn coretree.getKeys(node, isValidRelid);\r\n\t\t}\r\n\r\n\t\tfunction getChildrenPaths(node) {\r\n\t\t\tvar path = coretree.getPath(node);\r\n\r\n\t\t\tvar relids = getChildrenRelids(node);\r\n\t\t\tfor (var i = 0; i < relids.length; ++i) {\r\n\t\t\t\trelids[i] = path + \"/\" + relids[i];\r\n\t\t\t}\r\n\r\n\t\t\treturn relids;\r\n\t\t}\r\n\r\n\t\tfunction loadChildren(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar children = coretree.getKeys(node, isValidRelid);\r\n\t\t\tfor (var i = 0; i < children.length; ++i) {\r\n\t\t\t\tchildren[i] = coretree.loadChild(node, children[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn TASYNC.lift(children);\r\n\t\t}\r\n\r\n\t\tfunction getPointerNames(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar source = \"\";\r\n\t\t\tvar names = [];\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getProperty(coretree.getChild(node, OVERLAYS), source);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tfor (var name in child) {\r\n\t\t\t\t\t\tASSERT(names.indexOf(name) === -1);\r\n\t\t\t\t\t\tif (isPointerName(name)) {\r\n\t\t\t\t\t\t\tnames.push(name);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn names;\r\n\t\t}\r\n\r\n\t\tfunction getPointerPath(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && typeof name === \"string\");\r\n\r\n\t\t\tvar source = \"\";\r\n\t\t\tvar target;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\t\t\t\tASSERT(child);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, source);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\ttarget = coretree.getProperty(child, name);\r\n\t\t\t\t\tif (target !== undefined) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\tif (target !== undefined) {\r\n\t\t\t\tASSERT(node);\r\n\t\t\t\ttarget = coretree.joinPaths(coretree.getPath(node), target);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tfunction hasPointer(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && typeof name === \"string\");\r\n\r\n\t\t\tvar source = \"\";\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\t\t\t\tASSERT(child);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, source);\r\n\t\t\t\tif (child && coretree.getProperty(child, name) !== undefined) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfunction getOutsidePointerPath(node, name, source) {\r\n\t\t\tASSERT(isValidNode(node) && typeof name === \"string\");\r\n\t\t\tASSERT(typeof source === \"string\");\r\n\r\n\t\t\tvar target;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\t\t\t\tASSERT(child);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, source);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\ttarget = coretree.getProperty(child, name);\r\n\t\t\t\t\tif (target !== undefined) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\tif (target !== undefined) {\r\n\t\t\t\tASSERT(node);\r\n\t\t\t\ttarget = coretree.joinPaths(coretree.getPath(node), target);\r\n\t\t\t}\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\r\n\t\tfunction loadPointer(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && name);\r\n\r\n\t\t\tvar source = \"\";\r\n\t\t\tvar target;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\t\t\t\tASSERT(child);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, source);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\ttarget = coretree.getProperty(child, name);\r\n\t\t\t\t\tif (target !== undefined) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\tif (target !== undefined) {\r\n\t\t\t\tASSERT(typeof target === \"string\" && node);\r\n\t\t\t\treturn coretree.loadByPath(node, target);\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction getCollectionNames(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar target = \"\";\r\n\t\t\tvar names = [];\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tfor (var name in child) {\r\n\t\t\t\t\t\tif (!isPointerName(name)) {\r\n\t\t\t\t\t\t\tname = name.slice(0, -COLLSUFFIX.length);\r\n\t\t\t\t\t\t\tif (names.indexOf(name) < 0) {\r\n\t\t\t\t\t\t\t\tnames.push(name);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget = \"/\" + coretree.getRelid(node) + target;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn names;\r\n\t\t}\r\n\r\n\t\tfunction loadCollection(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && name);\r\n\r\n\t\t\tname += COLLSUFFIX;\r\n\r\n\t\t\tvar collection = [];\r\n\t\t\tvar target = \"\";\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, target);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tvar sources = coretree.getProperty(child, name);\r\n\t\t\t\t\tif (sources) {\r\n\t\t\t\t\t\tASSERT(Array.isArray(sources) && sources.length >= 1);\r\n\r\n\t\t\t\t\t\tfor (var i = 0; i < sources.length; ++i) {\r\n\t\t\t\t\t\t\tcollection.push(coretree.loadByPath(node, sources[i]));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget = \"/\" + coretree.getRelid(node) + target;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn TASYNC.lift(collection);\r\n\t\t}\r\n\r\n\t\tfunction getCollectionPaths(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && name);\r\n\r\n\t\t\tname += COLLSUFFIX;\r\n\r\n\t\t\tvar result = [];\r\n\t\t\tvar target = \"\";\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar child = coretree.getChild(node, OVERLAYS);\r\n\r\n\t\t\t\tchild = coretree.getChild(child, target);\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tvar sources = coretree.getProperty(child, name);\r\n\t\t\t\t\tif (sources) {\r\n\t\t\t\t\t\tASSERT(Array.isArray(sources) && sources.length >= 1);\r\n\r\n\t\t\t\t\t\tvar prefix = coretree.getPath(node);\r\n\r\n\t\t\t\t\t\tfor (var i = 0; i < sources.length; ++i) {\r\n\t\t\t\t\t\t\tresult.push(coretree.joinPaths(prefix, sources[i]));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget = \"/\" + coretree.getRelid(node) + target;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\tfunction deletePointer(node, name) {\r\n\t\t\tASSERT(isValidNode(node) && typeof name === \"string\");\r\n\r\n\t\t\tvar source = \"\";\r\n\r\n\t\t\tdo {\r\n\t\t\t\tvar overlays = coretree.getChild(node, OVERLAYS);\r\n\t\t\t\tASSERT(overlays);\r\n\r\n\t\t\t\tvar target = coretree.getProperty(coretree.getChild(overlays, source), name);\r\n\t\t\t\tif (target !== undefined) {\r\n\t\t\t\t\toverlayRemove(overlays, source, name, target);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsource = \"/\" + coretree.getRelid(node) + source;\r\n\t\t\t\tnode = coretree.getParent(node);\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tfunction setPointer(node, name, target) {\r\n\t\t\tASSERT(isValidNode(node) && typeof name === \"string\" && (!target || isValidNode(target)));\r\n\r\n\t\t\tdeletePointer(node, name);\r\n\r\n\t\t\tif (target) {\r\n\t\t\t\tvar ancestor = coretree.getAncestor(node, target);\r\n\r\n\t\t\t\tvar overlays = coretree.getChild(ancestor, OVERLAYS);\r\n\t\t\t\tvar sourcePath = coretree.getPath(node, ancestor);\r\n\t\t\t\tvar targetPath = coretree.getPath(target, ancestor);\r\n\r\n\t\t\t\toverlayInsert(overlays, sourcePath, name, targetPath);\r\n\t\t\t}\r\n\t\t}\r\n\r\n        function getChildrenHashes(node){\r\n            var keys = getChildrenRelids(node),\r\n                i,hashes = {};\r\n\r\n            for(i=0;i<keys.length;i++){\r\n                hashes[keys[i]] = coretree.getChildHash(node,keys[i]);\r\n            }\r\n\r\n            return hashes;\r\n        }\r\n\r\n\t\t// copy everything from coretree\r\n\t\tvar corerel = {};\r\n\t\tfor( var key in coretree) {\r\n\t\t\tcorerel[key] = coretree[key];\r\n\t\t}\r\n\r\n\t\tcorerel.isValidNode = isValidNode;\r\n\t\tcorerel.isValidRelid = isValidRelid;\r\n\r\n\t\tcorerel.getChildrenRelids = getChildrenRelids;\r\n\t\tcorerel.getChildrenPaths = getChildrenPaths;\r\n\r\n\t\tcorerel.loadChildren = loadChildren;\r\n\t\tcorerel.createNode = createNode;\r\n\t\tcorerel.deleteNode = deleteNode;\r\n\t\tcorerel.copyNode = copyNode;\r\n        corerel.copyNodes = copyNodes;\r\n\t\tcorerel.moveNode = moveNode;\r\n\r\n\t\tcorerel.getAttributeNames = getAttributeNames;\r\n\t\tcorerel.getAttribute = getAttribute;\r\n\t\tcorerel.setAttribute = setAttribute;\r\n\t\tcorerel.delAttribute = delAttribute;\r\n\r\n\t\tcorerel.getRegistryNames = getRegistryNames;\r\n\t\tcorerel.getRegistry = getRegistry;\r\n\t\tcorerel.setRegistry = setRegistry;\r\n\t\tcorerel.delRegistry = delRegistry;\r\n\r\n\t\tcorerel.getPointerNames = getPointerNames;\r\n\t\tcorerel.getPointerPath = getPointerPath;\r\n\t\tcorerel.hasPointer = hasPointer;\r\n\t\tcorerel.getOutsidePointerPath = getOutsidePointerPath;\r\n\t\tcorerel.loadPointer = loadPointer;\r\n\t\tcorerel.deletePointer = deletePointer;\r\n\t\tcorerel.setPointer = setPointer;\r\n\t\tcorerel.getCollectionNames = getCollectionNames;\r\n\t\tcorerel.getCollectionPaths = getCollectionPaths;\r\n\t\tcorerel.loadCollection = loadCollection;\r\n\r\n        corerel.getDataForSingleHash = getDataForSingleHash;\r\n\r\n\t\tcorerel.getCoreTree = function() {\r\n\t\t\treturn coretree;\r\n\t\t};\r\n\r\n        corerel.getChildrenHashes = getChildrenHashes;\r\n\r\n    corerel.overlayInsert = overlayInsert;\r\n\r\n\t\treturn corerel;\r\n\t}\r\n\r\n\treturn CoreRel;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('core/setcore',[ \"util/assert\"], function (ASSERT) {\r\n    \"use strict\";\r\n\r\n    var SETS_ID = '_sets';\r\n    var REL_ID = 'member';\r\n\r\n    function SetCore(innerCore){\r\n\r\n        //help functions\r\n        var setModified = function(node){\r\n            innerCore.setRegistry(node,'_sets_',(innerCore.getRegistry(node,'_sets_') || 0)+1);\r\n        };\r\n        var getMemberPath = function(node,setElementNode){\r\n            var ownPath = innerCore.getPath(node),\r\n                memberPath = innerCore.getPointerPath(setElementNode,REL_ID);\r\n            ownPath = ownPath.substring(0,ownPath.indexOf('/_')); //TODO this is a hack and should be solved some other way if possible\r\n            if(ownPath !== memberPath){\r\n                return memberPath;\r\n            }\r\n\r\n            //now we should check who really set this member as its own\r\n            while(innerCore.getBase(node) !== null && innerCore.getBase(setElementNode) !== null && innerCore.getRegistry(innerCore.getBase(setElementNode),'_') === '_'){\r\n                node = innerCore.getBase(node);\r\n                setElementNode = innerCore.getBase(setElementNode);\r\n                ownPath = innerCore.getPath(node);\r\n                ownPath = ownPath.substring(0,ownPath.indexOf('/_')); //TODO this is a hack and should be solved some other way if possible\r\n            }\r\n            memberPath = innerCore.getPointerPath(setElementNode,REL_ID);\r\n\r\n\r\n            return memberPath;\r\n\r\n        };\r\n        var getMemberRelId = function(node,setName,memberPath){\r\n            ASSERT(typeof setName === 'string');\r\n            var setNode = innerCore.getChild(innerCore.getChild(node,SETS_ID),setName);\r\n            var elements = innerCore.getChildrenRelids(setNode);\r\n\r\n            for(var i=0;i<elements.length;i++){\r\n                if(getMemberPath(node,innerCore.getChild(setNode,elements[i])) === memberPath){\r\n                    return elements[i];\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        var createNewMemberRelid = function(setNode){\r\n            var MAX_RELID = Math.pow(2, 31);\r\n            var existingRelIds = innerCore.getChildrenRelids(setNode);\r\n            var relid;\r\n            do{\r\n                relid = Math.floor(Math.random() * MAX_RELID);\r\n            } while (existingRelIds.indexOf(relid) !== -1);\r\n            return \"\" + relid;\r\n        };\r\n\r\n        var harmonizeMemberData = function(node,setName){\r\n            var setNode = innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),\r\n              base = innerCore.getBase(setNode),\r\n              allMembers = innerCore.getChildrenRelids(setNode),\r\n              ownMembers, inheritedMembers, i, j, path, names, ownMember, inheritedMember, k;\r\n            if(base){\r\n                harmonizeMemberData(base,setName); //recursively harmonize base members first\r\n                inheritedMembers = innerCore.getChildrenRelids(base);\r\n                ownMembers = [];\r\n                for(i=0;i<allMembers.length;i++){\r\n                    if(inheritedMembers.indexOf(allMembers[i]) === -1){\r\n                        ownMembers.push(allMembers[i]);\r\n                    }\r\n                }\r\n\r\n                for(i=0;i<ownMembers.length;i++){\r\n                    ownMember = innerCore.getChild(setNode,ownMembers[i]);\r\n                    path = innerCore.getPointerPath(ownMember,'member');\r\n                    for(j=0;j<inheritedMembers.length;j++){\r\n                        inheritedMember = innerCore.getChild(setNode,inheritedMembers[j]);\r\n                        if(getMemberPath(node,inheritedMember) === path){\r\n                            //redundancy...\r\n                            names = innerCore.getAttributeNames(ownMember);\r\n                            for(k=0;k<names.length;k++){\r\n                                if(innerCore.getAttribute(ownMember,names[k]) !== innerCore.getAttribute(inheritedMember,names[k])){\r\n                                    innerCore.setAttribute(inheritedMember,names[k],innerCore.getAttribute(ownMember,names[k]));\r\n                                }\r\n                            }\r\n                            names = innerCore.getRegistryNames(ownMember);\r\n                            for(k=0;k<names.length;k++){\r\n                                if(innerCore.getRegistry(ownMember,names[k]) !== innerCore.getRegistry(inheritedMember,names[k])){\r\n                                    innerCore.setRegistry(inheritedMember,names[k],innerCore.getRegistry(ownMember,names[k]));\r\n                                }\r\n                            }\r\n                            innerCore.deleteNode(innerCore.getChild(setNode,ownMembers[i]),true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        //copy lower layer\r\n        var setcore = {};\r\n        for(var i in innerCore){\r\n            setcore[i] = innerCore[i];\r\n        }\r\n\r\n        //adding new functions\r\n        setcore.getSetNumbers = function(node){\r\n            return this.getSetNames(node).length;\r\n        };\r\n        setcore.getSetNames = function(node){\r\n            return  innerCore.getPointerNames(innerCore.getChild(node,SETS_ID))|| [];\r\n        };\r\n        setcore.getPointerNames = function(node){\r\n            var sorted = [],\r\n                raw = innerCore.getPointerNames(node);\r\n            for(var i=0;i<raw.length;i++){\r\n                if(raw[i].indexOf(REL_ID) === -1){\r\n                    sorted.push(raw[i]);\r\n                }\r\n            }\r\n            return sorted;\r\n        };\r\n        setcore.getCollectionNames = function(node){\r\n            var sorted = [],\r\n                raw = innerCore.getCollectionNames(node);\r\n            for(var i=0;i<raw.length;i++){\r\n                if(raw[i].indexOf(REL_ID) === -1){\r\n                    sorted.push(raw[i]);\r\n                }\r\n            }\r\n            return sorted;\r\n        };\r\n        setcore.getMemberPaths = function(node,setName){\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var setNode = innerCore.getChild(innerCore.getChild(node,SETS_ID),setName);\r\n            var members = [];\r\n            var elements = innerCore.getChildrenRelids(setNode);\r\n            elements = elements.sort(); //TODO this should be removed at some point\r\n            for(var i=0;i<elements.length;i++){\r\n                var path = getMemberPath(node,innerCore.getChild(setNode,elements[i]));\r\n                if(path){\r\n                    members.push(path);\r\n                }\r\n            }\r\n            return members;\r\n        };\r\n        setcore.delMember = function(node,setName,memberPath){\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            //we only need the path of the member so we allow to enter only it\r\n            if(typeof memberPath !== 'string'){\r\n                memberPath = innerCore.getPath(memberPath);\r\n            }\r\n\r\n            var setMemberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(setMemberRelId){\r\n                var setMemberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),setMemberRelId);\r\n                innerCore.deleteNode(setMemberNode,true);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.addMember = function(node,setName,member){\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node,SETS_ID);\r\n            //TODO decide if the member addition should really create the set or it should fail...\r\n            if(innerCore.getPointerPath(setsNode,setName) === undefined){\r\n                setcore.createSet(node,setName);\r\n            }\r\n            harmonizeMemberData(node,setName);\r\n            var setNode = innerCore.getChild(setsNode,setName);\r\n            var setMemberRelId = getMemberRelId(node,setName,setcore.getPath(member));\r\n            if(setMemberRelId === null){\r\n                var setMember =  innerCore.getChild(setNode,createNewMemberRelid(setNode));\r\n                innerCore.setPointer(setMember,'member',member);\r\n                innerCore.setRegistry(setMember,\"_\",\"_\");//TODO hack, somehow the empty children have been removed during persist\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        setcore.getMemberAttributeNames = function(node,setName,memberPath){\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                return innerCore.getAttributeNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberOwnAttributeNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n                return innerCore.getOwnAttributeNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberAttribute = function(node,setName,memberPath,attrName){\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                return innerCore.getAttribute(memberNode,attrName);\r\n            }\r\n        };\r\n        setcore.setMemberAttribute = function(node,setName,memberPath,attrName,attrValue){\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string' && attrValue !== undefined);\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                innerCore.setAttribute(memberNode,attrName,attrValue);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.delMemberAttribute = function(node,setName,memberPath,attrName){\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                innerCore.delAttribute(memberNode,attrName);\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        setcore.getMemberRegistryNames = function(node,setName,memberPath){\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                return innerCore.getRegistryNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberOwnRegistryNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n                return innerCore.getOwnRegistryNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberRegistry = function(node,setName,memberPath,regName){\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                return innerCore.getRegistry(memberNode,regName);\r\n            }\r\n        };\r\n        setcore.setMemberRegistry = function(node,setName,memberPath,regName,regValue){\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string' && regValue !== undefined);\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                innerCore.setRegistry(memberNode,regName,regValue);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.delMemberRegistry = function(node,setName,memberPath,regName){\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\r\n            harmonizeMemberData(node,setName);\r\n            var memberRelId = getMemberRelId(node,setName,memberPath);\r\n            if(memberRelId){\r\n                var memberNode = innerCore.getChild(innerCore.getChild(innerCore.getChild(node,SETS_ID),setName),memberRelId);\r\n                innerCore.delRegistry(memberNode,regName);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.createSet = function(node,setName) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node,SETS_ID),\r\n                setNode = innerCore.getChild(setsNode,setName);\r\n            innerCore.setRegistry(setNode,\"_\",\"_\");//TODO hack, somehow the empty children have been removed during persist\r\n            innerCore.setPointer(innerCore.getChild(node,SETS_ID), setName, null);\r\n            setModified(node);\r\n        };\r\n        setcore.deleteSet = function(node,setName) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node,SETS_ID),\r\n                setNode = innerCore.getChild(setsNode,setName);\r\n            innerCore.deletePointer(setsNode,setName);\r\n            innerCore.deleteNode(setNode,true);\r\n            setModified(node);\r\n        };\r\n\r\n        setcore.isMemberOf = function(node){\r\n            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine\r\n            var coll = setcore.getCollectionPaths(node,REL_ID);\r\n            var sets = {};\r\n            for(var i=0;i<coll.length;i++){\r\n                var pathArray = coll[i].split('/');\r\n                if(pathArray.indexOf('_meta') === -1){\r\n                    //now we simply skip META sets...\r\n                    var index = pathArray.indexOf(SETS_ID);\r\n                    if(index>0 && pathArray.length>index+1){\r\n                        //otherwise it is not a real set\r\n                        var ownerPath = pathArray.slice(0,index).join('/');\r\n                        if(sets[ownerPath] === undefined){\r\n                            sets[ownerPath] = [];\r\n                        }\r\n                        sets[ownerPath].push(pathArray[index+1]);\r\n                    }\r\n                }\r\n            }\r\n            return sets;\r\n        };\r\n\r\n        /*setcore.getDataForSingleHash = function(node){\r\n            ASSERT(setcore.isValidNode(node));\r\n            var datas = innerCore.getDataForSingleHash(node);\r\n\r\n            //now we should stir all the sets hashes into the node's hash to get changes deep inside\r\n            var names = setcore.getSetNames(node);\r\n            for(var i=0;i<names.length;i++){\r\n                var setNode = setcore.getChild(setcore.getChild(node,SETS_ID),names[i]);\r\n                var memberRelids = setcore.getChildrenRelids(setNode);\r\n                for(var j=0;j<memberRelids.length;j++){\r\n                    datas = datas.concat(innerCore.getDataForSingleHash(setcore.getChild(setNode,memberRelids[j])));\r\n                }\r\n            }\r\n\r\n            return datas;\r\n        };*/\r\n\r\n        return setcore;\r\n\r\n    }\r\n\r\n    return SetCore;\r\n});\r\n\r\n\r\n\n",
    "/*\r\n * Copyright (C) 2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('core/guidcore',[ \"util/assert\", \"util/guid\", \"core/tasync\" ], function (ASSERT, GUID, TASYNC) {\r\n\t\"use strict\";\r\n\r\n\tvar GUID_REGEXP = new RegExp(\"[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}\", 'i');\r\n    var OWN_GUID = \"_relguid\";\r\n\r\n\tfunction guidCore (_innerCore) {\r\n\r\n\t\t//helper functions\r\n\t\tfunction toInternalGuid (myGuid) {\r\n\t\t\treturn myGuid.replace(/-/g, \"\");\r\n\t\t}\r\n\r\n\t\tfunction toExternalGuid (myGuid) {\r\n\t\t\tvar out = myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' + myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\tfunction guidToArray (guid) {\r\n            if(guid === null || guid === undefined){\r\n                return [0,0,0,0,0,0,0,0];\r\n            }\r\n\t\t\tvar array = [];\r\n\t\t\tfor ( var i = 0; i < guid.length / 4; i++) {\r\n\t\t\t\tarray.push(parseInt(guid.substr(4 * i, 4), 16));\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t}\r\n\r\n        function getRelidGuid(node){\r\n            //TODO we always should know what structure we should expect as a relid, now we think it is a number so it can be converted to 0xsomething\r\n            var relid = _core.getRelid(node);\r\n            relid = Number(relid);\r\n            if (relid ===\"NaN\"){\r\n                return null\r\n            }\r\n            if (relid < 0){\r\n                relid = relid *(-1);\r\n            }\r\n\r\n            relid = relid.toString(16);\r\n\r\n            //now we should fill up with 0's in the beggining\r\n            while(relid.length<32){\r\n                relid=relid+\"0\"; //TODO we pad to the end so the final result will be more visible during debug\r\n            }\r\n            return relid\r\n        }\r\n\r\n\t\tfunction xorGuids (a, b) {\r\n\t\t\tvar arrayA = guidToArray(a);\r\n\t\t\tvar arrayB = guidToArray(b);\r\n\r\n\t\t\tASSERT(arrayA.length === arrayB.length);\r\n\r\n\t\t\tvar arrayOut = [];\r\n\t\t\tfor ( var i = 0; i < arrayA.length; i++) {\r\n\t\t\t\tarrayOut.push(arrayA[i] ^ arrayB[i]);\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < arrayOut.length; i++) {\r\n\t\t\t\tarrayOut[i] = Number(arrayOut[i]).toString(16);\r\n\t\t\t\tvar difi = 4 - arrayOut[i].length;\r\n\t\t\t\twhile (difi > 0) {\r\n\t\t\t\t\tarrayOut[i] = '0' + arrayOut[i];\r\n\t\t\t\t\tdifi--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn arrayOut.join(\"\");\r\n\t\t}\r\n\r\n\t\tvar _core = {};\r\n\t\tfor ( var i in _innerCore) {\r\n\t\t\t_core[i] = _innerCore[i];\r\n\t\t}\r\n\r\n\t\t//new functions\r\n        _core.getMiddleGuid = function(node){\r\n            var outGuid = _core.getAttribute(node, OWN_GUID);\r\n            var tempnode = _core.getParent(node);\r\n            while (tempnode) {\r\n                outGuid = xorGuids(outGuid, _core.getAttribute(tempnode, OWN_GUID));\r\n                tempnode = _core.getParent(tempnode);\r\n            }\r\n            return outGuid;\r\n        };\r\n\r\n\t\t_core.getGuid = function (node) {\r\n            var middle = _core.getMiddleGuid(node),\r\n                relid = getRelidGuid(node),\r\n                guid = xorGuids(middle,relid);\r\n            return toExternalGuid(guid);\r\n\t\t};\r\n\r\n        _core.setGuid = function(node,guid){\r\n            ASSERT(GUID_REGEXP.test(guid));\r\n            var children = _core.loadChildren(node);\r\n            return TASYNC.call(function(nodeArray){\r\n                var newGuid = toInternalGuid(guid);\r\n                //first setting the node's OWN_GUID\r\n                var oldOwn = _core.getAttribute(node,OWN_GUID);\r\n                var parent = _core.getParent(node);\r\n                if (parent) {\r\n                    _core.setAttribute(node, OWN_GUID, xorGuids(newGuid,xorGuids(_core.getMiddleGuid(parent),getRelidGuid(node))));\r\n                } else {\r\n                    _core.setAttribute(node, OWN_GUID, xorGuids(newGuid,getRelidGuid(node)));\r\n                }\r\n                var newOwn = _core.getAttribute(node,OWN_GUID);\r\n                //now modify its children's\r\n                for ( var i = 0; i < nodeArray.length; i++) {\r\n                    var oldGuid = _core.getAttribute(nodeArray[i],OWN_GUID);\r\n                    _core.setAttribute(nodeArray[i], OWN_GUID, xorGuids(oldGuid,xorGuids(oldOwn,newOwn)));\r\n                }\r\n\r\n\r\n                return;\r\n            },children);\r\n        };\r\n\r\n\t\t//modified functions\r\n\t\t_core.createNode = function (parameters) {\r\n\t\t\tparameters = parameters || {};\r\n\t\t\tvar guid = parameters.guid || GUID(),\r\n\t\t\t\tparent = parameters.parent;\r\n\r\n\t\t\tASSERT(GUID_REGEXP.test(guid));\r\n\r\n\t\t\tvar node = _innerCore.createNode(parameters);\r\n\t\t\tguid = toInternalGuid(guid);\r\n\r\n\t\t\tvar relguid = \"\";\r\n\t\t\tif (parent) {\r\n\t\t\t\trelguid = xorGuids(toInternalGuid(_core.getMiddleGuid(_core.getParent(node))),xorGuids(guid,getRelidGuid(node)));\r\n\t\t\t} else {\r\n\t\t\t\trelguid = xorGuids(guid,getRelidGuid(node));\r\n\t\t\t}\r\n\t\t\t_innerCore.setAttribute(node, OWN_GUID, relguid);\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n        _core.moveNode = function(node,parent){\r\n            var oldGuid = toInternalGuid(_core.getGuid(node)),\r\n                newNode = _innerCore.moveNode(node,parent);\r\n\r\n            _core.setAttribute(newNode,OWN_GUID,xorGuids(_core.getMiddleGuid(parent),xorGuids(oldGuid,getRelidGuid(newNode))));\r\n\r\n            return newNode;\r\n        };\r\n\r\n        _core.copyNode = function(node,parent){\r\n            var newNode = _innerCore.copyNode(node,parent);\r\n            _core.setAttribute(newNode,OWN_GUID,toInternalGuid(GUID()));\r\n            return newNode;\r\n        };\r\n\r\n        _core.copyNodes = function(nodes,parent){\r\n            var copiedNodes = _innerCore.copyNodes(nodes,parent),\r\n                i;\r\n            for(i=0;i<copiedNodes.length;i++){\r\n                _core.setAttribute(copiedNodes[i],OWN_GUID,toInternalGuid(GUID()));\r\n            }\r\n\r\n            return copiedNodes;\r\n        };\r\n\r\n\t\treturn _core;\r\n\t}\r\n\r\n\treturn guidCore;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('core/nullpointercore',[], function () {\r\n    \"use strict\";\r\n\r\n    var NULLPTR_NAME = \"_null_pointer\";\r\n    var NULLPTR_RELID = \"_nullptr\";\r\n\r\n\r\n    function nullPointerCore (_innerCore) {\r\n        var _core = {};\r\n        for(var i in _innerCore){\r\n            _core[i] = _innerCore[i];\r\n        }\r\n\r\n        \r\n        //extra functions\r\n        _core.setPointer = function(node,name, target){\r\n            if(target === null){\r\n                var nullChild = _innerCore.getChild(node,NULLPTR_RELID);\r\n                _innerCore.setAttribute(nullChild,'name',NULLPTR_NAME);\r\n                _innerCore.setPointer(node,name,nullChild);\r\n            } else {\r\n                _innerCore.setPointer(node,name,target);\r\n            }\r\n        };\r\n        _core.getPointerPath = function(node,name){\r\n            var path = _innerCore.getPointerPath(node,name);\r\n            if(path && path.indexOf(NULLPTR_RELID) !== -1){\r\n                return null;\r\n            } else {\r\n                return path;\r\n            }\r\n        };\r\n        _core.loadPointer = function(node,name){\r\n            var path = _core.getPointerPath(node,name);\r\n            if(path === null){\r\n                return null;\r\n            } else {\r\n                return _innerCore.loadPointer(node,name);\r\n            }\r\n        };\r\n\r\n        \r\n        return _core;\r\n    }\r\n\r\n    return nullPointerCore;\r\n});\r\n\r\n\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('core/coreunwrap',[ \"util/assert\", \"core/tasync\" ], function(ASSERT, TASYNC) {\r\n\t\"use strict\";\r\n\r\n\t// ----------------- CoreUnwrap -----------------\r\n\r\n\tvar CoreUnwrap = function(oldcore) {\r\n\r\n\t\tfunction checkNode(node) {\r\n\t\t\tif (node === null || oldcore.isValidNode(node)) {\r\n\t\t\t\treturn node;\r\n\t\t\t} else {\r\n\t\t\t\tthrow new Error(\"Invalid result node\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction checkNodes(nodes) {\r\n\t\t\tASSERT(nodes instanceof Array);\r\n\r\n\t\t\tvar i;\r\n\t\t\tfor (i = 0; i < nodes.length; ++i) {\r\n\t\t\t\tif (!oldcore.isValidNode(nodes[i])) {\r\n\t\t\t\t\tthrow new Error(\"Invalid result node array\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn nodes;\r\n\t\t}\r\n\r\n\t\t// copy all operations\r\n\t\tvar core = {};\r\n\t\tfor ( var key in oldcore) {\r\n\t\t\tcore[key] = oldcore[key];\r\n\t\t}\r\n\r\n\t\tcore.loadRoot = TASYNC.unwrap(oldcore.loadRoot);\r\n\t\tcore.persist = TASYNC.unwrap(oldcore.persist);\r\n\r\n\t\t// core.loadChild = TASYNC.unwrap(oldcore.loadChild);\r\n\t\tcore.loadChild = TASYNC.unwrap(function(node, relid) {\r\n\t\t\treturn TASYNC.call(checkNode, oldcore.loadChild(node, relid));\r\n\t\t});\r\n\r\n\t\t// core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);\r\n\t\tcore.loadByPath = TASYNC.unwrap(function(node, path) {\r\n\t\t\treturn TASYNC.call(checkNode, oldcore.loadByPath(node, path));\r\n\t\t});\r\n\r\n\t\t// core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);\r\n\t\tcore.loadChildren = TASYNC.unwrap(function(node) {\r\n\t\t\treturn TASYNC.call(checkNodes, oldcore.loadChildren(node));\r\n\t\t});\r\n\r\n\t\tcore.loadPointer = TASYNC.unwrap(oldcore.loadPointer);\r\n\t\tcore.loadCollection = TASYNC.unwrap(oldcore.loadCollection);\r\n\r\n    //core diff async functions\r\n    if(typeof oldcore.generateTreeDiff === 'function'){\r\n        core.generateTreeDiff = TASYNC.unwrap(oldcore.generateTreeDiff);\r\n    }\r\n\r\n    if(typeof  oldcore.generateLightTreeDiff === 'function'){\r\n      core.generateLightTreeDiff = TASYNC.unwrap(oldcore.generateLightTreeDiff);\r\n    }\r\n\r\n    if(typeof oldcore.applyTreeDiff === 'function'){\r\n      core.applyTreeDiff = TASYNC.unwrap(oldcore.applyTreeDiff);\r\n    }\r\n\r\n\t\tcore.loadSubTree = TASYNC.unwrap(oldcore.loadSubTree);\r\n\t\tcore.loadTree = TASYNC.unwrap(oldcore.loadTree);\r\n\t\treturn core;\r\n\t};\r\n\r\n\treturn CoreUnwrap;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('core/descriptorcore',[], function () {\r\n    \"use strict\";\r\n\r\n    var DESCR_ID = \"_desc\";\r\n\r\n    function descriptorCore (_innerCore) {\r\n\r\n        //helper functions\r\n        function updateDescriptorHash(node){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var dCount = _innerCore.getRegistry(node,'d_count') || 0;\r\n            _innerCore.setRegistry(node,'d_count',dCount + 1);\r\n        }\r\n        var _core = {};\r\n        for(var i in _innerCore){\r\n            _core[i] = _innerCore[i];\r\n        }\r\n\r\n\r\n        //extra functions\r\n        _core.getAttributeDescriptor = function(node,attributename){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"a_\"+attributename);\r\n            return _innerCore.getRegistry(descriptor,'descriptor');\r\n        };\r\n        _core.setAttributeDescriptor = function(node,attributename,descobject){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"a_\"+attributename);\r\n            _innerCore.setRegistry(descriptor,'descriptor',descobject);\r\n            updateDescriptorHash(node);\r\n        };\r\n        _core.delAttributeDescriptor = function(node,attributename){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"a_\"+attributename);\r\n            _innerCore.deleteNode(descriptor);\r\n            updateDescriptorHash(node);\r\n        };\r\n\r\n        _core.getPointerDescriptor = function(node,pointername){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"p_\"+pointername);\r\n            return _innerCore.getRegistry(descriptor,'descriptor');\r\n        };\r\n        _core.setPointerDescriptor = function(node,pointername,descobject){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"p_\"+pointername);\r\n            _innerCore.setRegistry(descriptor,'descriptor',descobject);\r\n            updateDescriptorHash(node);\r\n        };\r\n        _core.delPointerDescriptor = function(node,pointername){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"p_\"+pointername);\r\n            _innerCore.deleteNode(descriptor);\r\n            updateDescriptorHash(node);\r\n        };\r\n\r\n\r\n        _core.getNodeDescriptor = function(node){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"n_\");\r\n            return _innerCore.getRegistry(descriptor,'descriptor');\r\n        };\r\n        _core.setNodeDescriptor = function(node,descobject){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"n_\");\r\n            _innerCore.setRegistry(descriptor,'descriptor',descobject);\r\n            updateDescriptorHash(node);\r\n        };\r\n        _core.delNodeDescriptor = function(node,descobject){\r\n            var descriptors = _innerCore.getChild(node,DESCR_ID);\r\n            var descriptor = _innerCore.getChild(descriptors,\"n_\");\r\n            _innerCore.deleteNode(descriptor);\r\n            updateDescriptorHash(node);\r\n        };\r\n\r\n\r\n        return _core;\r\n    }\r\n\r\n    return descriptorCore;\r\n});\r\n\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('core/coretype',[ \"util/assert\", \"core/core\", \"core/tasync\" ], function(ASSERT, Core, TASYNC) {\r\n\t\"use strict\";\r\n\r\n\t// ----------------- CoreType -----------------\r\n\r\n    //FIXME TODO these stuff have been simply copied from lower layer, probably it should be put to some constant place\r\n    var OVERLAYS = \"ovr\";\r\n    var COLLSUFFIX = \"-inv\";\r\n\r\n    var CoreType = function(oldcore) {\r\n\t\t// copy all operations\r\n\t\tvar core = {};\r\n\t\tfor ( var key in oldcore) {\r\n\t\t\tcore[key] = oldcore[key];\r\n\t\t}\r\n\r\n\t\t// ----- validity\r\n\r\n\t\tfunction __test(text, cond) {\r\n\t\t\tif (!cond) {\r\n\t\t\t\tthrow new Error(text);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isValidNode(node) {\r\n\t\t\ttry {\r\n\t\t\t\t__test(\"core\", oldcore.isValidNode(node));\r\n\t\t\t\t__test(\"base\", typeof node.base === \"object\");\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.log(\"Wrong node\", error.stack);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n        function isFalseNode(node) {\r\n            //TODO this hack should be removed, but now it seems just fine :)\r\n            if(typeof oldcore.getPointerPath(node,\"base\") === \"undefined\"){\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n\t\tcore.isValidNode = isValidNode;\r\n\r\n\t\t// ----- navigation\r\n\r\n\t\tcore.getBase = function(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\t// TODO: check if base has moved\r\n\t\t\treturn node.base;\r\n\t\t};\r\n\r\n        core.getBaseRoot = function(node) {\r\n            ASSERT(isValidNode(node));\r\n            while (node.base !== null){\r\n                node = node.base;\r\n            }\r\n\r\n            return node;\r\n        };\r\n\r\n\t\tcore.loadRoot = function(hash) {\r\n\t\t\treturn TASYNC.call(__loadRoot2, oldcore.loadRoot(hash));\r\n\t\t};\r\n\r\n\t\tfunction __loadRoot2(node) {\r\n            ASSERT(typeof node.base === \"undefined\" || node.base === null); //kecso - TODO it should be undefined, but maybe because of the cache it can be null\r\n\r\n\t\t\tnode.base = null;\r\n\t\t\treturn node;\r\n\t\t}\r\n\r\n        core.loadChild = function(node,relid){\r\n            var child = null,\r\n                base = core.getBase(node),\r\n                basechild = null;\r\n            if(base){\r\n                //the parent is inherited\r\n                if(oldcore.getChildrenRelids(base).indexOf(relid) !== -1) {\r\n                    //inherited child\r\n                    if (oldcore.getChildrenRelids(node).indexOf(relid) !== -1) {\r\n                        //but it is overwritten so we should load it\r\n                        child = oldcore.loadChild(node, relid);\r\n                    }\r\n                    basechild = core.loadChild( base, relid);\r\n                    return TASYNC.call(function(b,c,n,r){\r\n                        child = c || core.getChild(n,r);\r\n                        child.base = b;\r\n                        core.getCoreTree().setHashed(child,true);\r\n                        return child;\r\n                    },basechild,child,node,relid);\r\n                }\r\n            }\r\n            //normal child\r\n            return TASYNC.call(__loadBase,oldcore.loadChild(node,relid));\r\n        };\r\n\r\n        core.loadByPath = function(node,path){\r\n            ASSERT(isValidNode(node));\r\n            ASSERT(path === \"\" || path.charAt(0) === \"/\");\r\n            path = path.split(\"/\");\r\n            return loadDescendantByPath(node, path, 1);\r\n        };\r\n        var loadDescendantByPath = function(node,pathArray,index){\r\n            if (node === null || index === pathArray.length) {\r\n                return node;\r\n            }\r\n\r\n            var child = core.loadChild(node, pathArray[index]);\r\n            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);\r\n        };\r\n\r\n        //TODO the pointer loading is totally based upon the loadByPath...\r\n        core.loadPointer = function(node,name){\r\n            var pointerPath = core.getPointerPath(node,name);\r\n            return TASYNC.call(core.loadByPath,core.getRoot(node),pointerPath);\r\n        };\r\n\r\n        function __loadBase(node) {\r\n            ASSERT(node === null || typeof node.base === \"undefined\" || typeof node.base === \"object\");\r\n\r\n            if (typeof node.base === \"undefined\") {\r\n                if(core.isEmpty(node)) {\r\n                    //empty nodes do not have a base\r\n                    node.base = null;\r\n                    return node;\r\n                } else if(isFalseNode(node)){\r\n                    var root = core.getRoot(node);\r\n                    oldcore.deleteNode(node);\r\n                    core.persist(root);\r\n                    return null;\r\n                } else {\r\n                    var basepath = oldcore.getPointerPath(node,'base');\r\n                    ASSERT(basepath !== undefined);\r\n                    if(basepath === null){\r\n                        node.base = null;\r\n                        return node;\r\n                    } else {\r\n                        return TASYNC.call(__loadBase2, node, core.loadByPath(core.getRoot(node),basepath));\r\n                    }\r\n                }\r\n            } else {\r\n                //TODO can the base change at this point???\r\n                return node;\r\n            }\r\n        }\r\n\r\n\t\tfunction __loadBase2(node, target) {\r\n            if(typeof node.base !== null && typeof node.base === 'object' && (oldcore.getPath(node.base) === oldcore.getPath(target))){\r\n                //TODO somehow the object already loaded properly and we do no know about it!!!\r\n                return node;\r\n            } else {\r\n                ASSERT(typeof node.base === \"undefined\" || node.base === null); //kecso\r\n\r\n                if(target === null) {\r\n                    node.base = null;\r\n                    return node;\r\n                }  else {\r\n                    return TASYNC.call(function(n,b){n.base = b; return n;},node,__loadBase(target));\r\n                }\r\n            }\r\n\t\t}\r\n\r\n        core.getChildrenRelids = function(node){\r\n            var inheritRelIds = node.base === null ? [] : core.getChildrenRelids(core.getBase(node));\r\n            var ownRelIds = oldcore.getChildrenRelids(node);\r\n            for(var i=0;i<inheritRelIds.length;i++){\r\n                if(ownRelIds.indexOf(inheritRelIds[i]) === -1){\r\n                    ownRelIds.push(inheritRelIds[i]);\r\n                }\r\n            }\r\n            return ownRelIds;\r\n        };\r\n        \r\n        core.loadChildren = function(node) {\r\n            ASSERT(isValidNode(node));\r\n            var relids = core.getChildrenRelids(node);\r\n            relids = relids.sort(); //TODO this should be temporary\r\n            var children = [];\r\n            for(var i = 0; i< relids.length; i++)\r\n                children[i] = core.loadChild(node,relids[i]);\r\n            return TASYNC.call(function(n){\r\n                var newn = [];\r\n                for(var i=0; i<n.length;i++){\r\n                    if(n[i] !== null){\r\n                        newn.push(n[i]);\r\n                    }\r\n                }\r\n                return newn;\r\n            },TASYNC.lift(children));\r\n        };\r\n\r\n        //collection handling and needed functions\r\n        function _isInheritedChild(node){\r\n            var parent = core.getParent(node),\r\n                base = core.getBase(node),\r\n                parentBase = parent ? core.getBase(parent) : null,\r\n                baseParent = base ? core.getParent(base) : null;\r\n\r\n            if(baseParent && parentBase && core.getPath(baseParent) === core.getPath(parentBase)){\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function _getInstanceRoot(node){\r\n\r\n            while(_isInheritedChild(node)){\r\n                node = core.getParent(node);\r\n            }\r\n\r\n            return node;\r\n        }\r\n        //TODO copied function from corerel\r\n        function isPointerName(name) {\r\n            ASSERT(typeof name === \"string\");\r\n\r\n            return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\r\n        }\r\n\r\n        function _getInheritedCollectionNames(node){\r\n            var target = \"\",\r\n                names = [],\r\n                coretree = core.getCoreTree(),\r\n                startNode = node,\r\n                endNode = _getInstanceRoot(node),\r\n                exit;\r\n\r\n            if(core.getPath(startNode) === core.getPath(endNode)){\r\n                return names;\r\n            }\r\n\r\n            do{\r\n                startNode = core.getBase(startNode);\r\n                endNode = core.getBase(endNode);\r\n                node = startNode;\r\n                exit = false;\r\n                target = \"\";\r\n                do {\r\n                    if(core.getPath(node) === core.getPath(endNode)){\r\n                        exit = true;\r\n                    }\r\n                    var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\r\n                    if (child) {\r\n                        for ( var name in child) {\r\n                            if (!isPointerName(name)) {\r\n                                name = name.slice(0, -COLLSUFFIX.length);\r\n                                if (names.indexOf(name) < 0) {\r\n                                    names.push(name);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    target = \"/\" + coretree.getRelid(node) + target;\r\n                    node = coretree.getParent(node);\r\n                } while (!exit);\r\n            } while (_isInheritedChild(startNode));\r\n\r\n            return names;\r\n        }\r\n        function _getInheritedCollectionPaths(node,name){\r\n            var target = \"\",\r\n                result = [],\r\n                coretree = core.getCoreTree(),\r\n                startNode = node,\r\n                endNode = _getInstanceRoot(node),\r\n                prefixStart = startNode,\r\n                prefixNode = prefixStart,\r\n                exit,\r\n                collName = name + COLLSUFFIX,\r\n                notOverwritten = function(sNode,eNode,source){\r\n                    var result = true,\r\n                        tNode = sNode,\r\n                        child,target;\r\n\r\n                    while(core.getPath(tNode) !== core.getPath(eNode)){\r\n                        child = coretree.getChild(tNode,OVERLAYS);\r\n                        child = coretree.getChild(child,source);\r\n                        if(child){\r\n                            target = coretree.getProperty(child,name);\r\n                            if(target){\r\n                                return false;\r\n                            }\r\n                        }\r\n                        tNode = core.getBase(tNode);\r\n                    }\r\n\r\n                    return result;\r\n                };\r\n\r\n            if(core.getPath(startNode) === core.getPath(endNode)){\r\n                return result;\r\n            }\r\n\r\n            do{\r\n                startNode = core.getBase(startNode);\r\n                endNode = core.getBase(endNode);\r\n                node = startNode;\r\n                prefixNode = prefixStart;\r\n                exit = false;\r\n                target = \"\";\r\n                do {\r\n                    if(core.getPath(node) === core.getPath(endNode)){\r\n                        exit = true;\r\n                    }\r\n                    var child = coretree.getChild(node, OVERLAYS);\r\n                    child = coretree.getChild(child,target);\r\n                    if (child) {\r\n                        var sources = coretree.getProperty(child, collName);\r\n                        if (sources) {\r\n                            ASSERT(Array.isArray(sources) && sources.length >= 1);\r\n\r\n                            var prefix = coretree.getPath(prefixNode);\r\n\r\n                            for ( var i = 0; i < sources.length; ++i) {\r\n                                if(notOverwritten(prefixNode,node,sources[i])){\r\n                                    result.push(coretree.joinPaths(prefix, sources[i]));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    target = \"/\" + coretree.getRelid(node) + target;\r\n                    node = coretree.getParent(node);\r\n                    prefixNode = core.getParent(prefixNode);\r\n                } while (!exit);\r\n            } while (_isInheritedChild(startNode));\r\n\r\n            return result;\r\n        }\r\n        core.getCollectionNames = function(node){\r\n            ASSERT(isValidNode(node));\r\n            var checkCollNames = function(draft){\r\n                    var i,filtered = [],sources;\r\n                    for(i=0;i<draft.length;i++){\r\n                        sources = core.getCollectionPaths(node,draft[i]);\r\n                        if(sources.length > 0){\r\n                            filtered.push(draft[i])\r\n                        }\r\n                    }\r\n                    return filtered;\r\n                },\r\n                ownNames = oldcore.getCollectionNames(node),\r\n                inhNames = checkCollNames(_getInheritedCollectionNames(node)),\r\n                i;\r\n            for(i=0;i<ownNames.length;i++){\r\n                if(inhNames.indexOf(ownNames[i]) < 0){\r\n                    inhNames.push(ownNames[i])\r\n                }\r\n            }\r\n\r\n            return inhNames;\r\n        };\r\n\r\n        core.getCollectionPaths = function(node,name){\r\n            ASSERT(isValidNode(node) && name);\r\n            var ownPaths = oldcore.getCollectionPaths(node,name),\r\n                inhPaths = _getInheritedCollectionPaths(node,name);\r\n\r\n            inhPaths = inhPaths.concat(ownPaths);\r\n\r\n            return inhPaths;\r\n        };\r\n\r\n        core.loadCollection = function(node, name) {\r\n            var root =  core.getRoot(node);\r\n            var paths = core.getCollectionPaths(node,name);\r\n\r\n            var nodes = [];\r\n            for(var i = 0; i < paths.length; i++) {\r\n                nodes[i] = core.loadByPath(root, paths[i]);\r\n            }\r\n\r\n            return TASYNC.lift(nodes);\r\n        };\r\n\r\n\t\t// ----- creation\r\n\r\n\t\tcore.createNode = function(parameters) {\r\n\t\t\tparameters = parameters || {};\r\n\t\t\tvar base = parameters.base || null,\r\n\t\t\t\tparent = parameters.parent;\r\n\r\n\r\n\t\t\tASSERT(!parent || isValidNode(parent));\r\n\t\t\tASSERT(!base || isValidNode(base));\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n\r\n\t\t\tvar node = oldcore.createNode(parameters);\r\n            node.base = base;\r\n            oldcore.setPointer(node,\"base\",base);\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\t// ----- properties\r\n\r\n\t\tcore.getAttributeNames = function(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar merged = {};\r\n\t\t\tdo {\r\n\t\t\t\tvar names = oldcore.getAttributeNames(node);\r\n\t\t\t\tfor ( var i = 0; i < names.length; ++i) {\r\n\t\t\t\t\tif (!(names[i] in merged)) {\r\n\t\t\t\t\t\tmerged[names[i]] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = node.base;\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn Object.keys(merged);\r\n\t\t};\r\n        core.getOwnAttributeNames = function(node){\r\n            return oldcore.getAttributeNames(node);\r\n        };\r\n\r\n\t\tcore.getRegistryNames = function(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar merged = {};\r\n\t\t\tdo {\r\n\t\t\t\tvar names = oldcore.getRegistryNames(node);\r\n\t\t\t\tfor ( var i = 0; i < names.length; ++i) {\r\n\t\t\t\t\tif (!(names[i] in merged)) {\r\n\t\t\t\t\t\tmerged[names[i]] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = node.base;\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn Object.keys(merged);\r\n\t\t};\r\n        core.getOwnRegistryNames = function(node){\r\n            return oldcore.getRegistryNames(node);\r\n        };\r\n\r\n\t\tcore.getAttribute = function(node, name) {\r\n\t\t\tASSERT(isValidNode(node));\r\n            var value;\r\n\t\t\tdo {\r\n\t\t\t\tvalue = oldcore.getAttribute(node, name);\r\n\t\t\t\tnode = node.base;\r\n\t\t\t} while (typeof value === \"undefined\" && node !== null);\r\n\r\n\t\t\treturn value;\r\n\t\t};\r\n        core.getOwnAttribute = function(node,name) {\r\n            return oldcore.getAttribute(node,name);\r\n        };\r\n\r\n\t\tcore.getRegistry = function(node, name) {\r\n\t\t\tASSERT(isValidNode(node));\r\n            var value;\r\n\t\t\tdo {\r\n\t\t\t\tvalue = oldcore.getRegistry(node, name);\r\n\t\t\t\tnode = node.base;\r\n\t\t\t} while (typeof value === \"undefined\" && node !== null);\r\n\r\n\t\t\treturn value;\r\n\t\t};\r\n        core.getOwnRegistry = function(node,name) {\r\n            return oldcore.getRegistry(node,name);\r\n        };\r\n\r\n\r\n\t\t// ----- pointers\r\n\r\n\t\tcore.getPointerNames = function(node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tvar merged = {};\r\n\t\t\tdo {\r\n\t\t\t\tvar names = oldcore.getPointerNames(node);\r\n\t\t\t\tfor ( var i = 0; i < names.length; ++i) {\r\n\t\t\t\t\tif (!(names[i] in merged)) {\r\n\t\t\t\t\t\tmerged[names[i]] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = node.base;\r\n\t\t\t} while (node);\r\n\r\n\t\t\treturn Object.keys(merged);\r\n\t\t};\r\n        core.getOwnPointerNames = function(node){\r\n            ASSERT(isValidNode(node));\r\n            return oldcore.getPointerNames(node);\r\n        };\r\n\r\n        core.getPointerPath = function (node, name) {\r\n            ASSERT(isValidNode(node) && typeof name === \"string\");\r\n\r\n            var ownPointerPath = oldcore.getPointerPath(node,name);\r\n            if(ownPointerPath !== undefined){\r\n                return ownPointerPath;\r\n            }\r\n            var source = \"\",\r\n                target,\r\n                coretree = core.getCoreTree(),\r\n                basePath,\r\n                hasNullTarget = false,\r\n                getProperty = function(node,name){\r\n                    var property;\r\n                    while(property === undefined && node !== null){\r\n                        property = coretree.getProperty(node,name);\r\n                        node = core.getBase(node);\r\n                    }\r\n                    return property;\r\n                },\r\n                getSimpleBasePath = function(node){\r\n                    var path = oldcore.getPointerPath(node,name);\r\n                    if(path === undefined){\r\n                        if(node.base !== null && node.base !== undefined){\r\n                            return getSimpleBasePath(node.base);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return path;\r\n                    }\r\n                },\r\n                getParentOfBasePath = function(node){\r\n                    if(node.base){\r\n                        var parent = core.getParent(node.base);\r\n                        if(parent){\r\n                            return core.getPath(parent);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return undefined;\r\n                    }\r\n                },\r\n                getBaseOfParentPath = function(node){\r\n                    var parent = core.getParent(node);\r\n                    if(parent){\r\n                        if(parent.base){\r\n                            return core.getPath(parent.base);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return undefined;\r\n                    }\r\n                },\r\n                getTargetRelPath = function(node,relSource,name){\r\n                    var ovr = core.getChild(node,'ovr');\r\n                    var source = core.getChild(ovr,relSource);\r\n                    return getProperty(source,name);\r\n                };\r\n\r\n            basePath = node.base ? getSimpleBasePath(node.base) : undefined;\r\n\r\n            while(node){\r\n                target = getTargetRelPath(node,source,name);\r\n                if( target !== undefined){\r\n                    if(target.indexOf('_nullptr') !== -1){\r\n                        hasNullTarget = true;\r\n                        target = undefined;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                source = \"/\" + core.getRelid(node) + source;\r\n                if(getParentOfBasePath(node) === getBaseOfParentPath(node)){\r\n                    node = core.getParent(node);\r\n                } else {\r\n                    node = null;\r\n                }\r\n            }\r\n\r\n\r\n            if (target !== undefined) {\r\n                ASSERT(node);\r\n                target = coretree.joinPaths(oldcore.getPath(node), target);\r\n            }\r\n            return target || basePath || (hasNullTarget ? null : undefined);\r\n        };\r\n        core.getOwnPointerPath = function(node,name){\r\n            oldcore.getPointerPath(node,name);\r\n        };\r\n\r\n        core.setBase = function(node,base){\r\n            ASSERT(isValidNode(node) && (base === undefined || base === null || isValidNode(base)));\r\n            ASSERT(!base || core.getPath(core.getParent(node)) !== core.getPath(base));\r\n            ASSERT(!base || core.getPath(node) !== core.getPath(base));\r\n            if(!!base){\r\n                //TODO maybe this is not the best way, needs to be double checked\r\n                node.base = base;\r\n                var parent = core.getParent(node),\r\n                    parentBase,baseParent;\r\n                if(parent){\r\n                    parentBase = core.getBase(parent);\r\n                    baseParent = core.getParent(base);\r\n                    if(core.getPath(parentBase) !== core.getPath(baseParent)){\r\n                        //we have to set an exact pointer only if it is not inherited child\r\n                        oldcore.setPointer(node, \"base\", base);\r\n                    } else {\r\n                        oldcore.deletePointer(node,\"base\"); //we remove the pointer just in case\r\n                    }\r\n                } else {\r\n                    //if for some reason the node doesn't have a parent it is surely not an inherited child\r\n                    oldcore.setPointer(node,\"base\",base);\r\n                }\r\n            } else {\r\n                oldcore.setPointer(node,'base',null);\r\n                node.base = null;\r\n            }\r\n        };\r\n\r\n        core.getChild = function(node,relid){\r\n            ASSERT(isValidNode(node) && (typeof node.base === 'undefined' || typeof node.base === 'object'));\r\n            var child = oldcore.getChild(node,relid);\r\n            if(node.base !== null && node.base !== undefined){\r\n                if(child.base === null || child.base === undefined){\r\n                    child.base = core.getChild(node.base,relid);\r\n                }\r\n            } else {\r\n                child.base = null;\r\n            }\r\n            return child;\r\n        };\r\n        core.moveNode = function(node,parent){\r\n            //TODO we have to check if the move is really allowed!!!\r\n            ASSERT(isValidNode(node) && isValidNode(parent));\r\n            var base = node.base,\r\n                parentBase = parent.base;\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n            ASSERT(!parentBase || core.getPath(parentBase) !== core.getPath(node));\r\n\r\n            var moved = oldcore.moveNode(node,parent);\r\n            moved.base = base;\r\n            return moved;\r\n        };\r\n        core.copyNode = function(node,parent){\r\n            var base = node.base;\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n\r\n            var newnode = oldcore.copyNode(node,parent);\r\n            newnode.base = base;\r\n            oldcore.setPointer(newnode,'base',base);\r\n            return newnode;\r\n        };\r\n        function _inheritedPointerNames(node){\r\n            var allNames = core.getPointerNames(node),\r\n                ownNames = core.getOwnPointerNames(node),\r\n                names = [],\r\n                i;\r\n\r\n            for(i=0;i<allNames.length;i++){\r\n                if(ownNames.indexOf(allNames[i]) === -1){\r\n                    names.push(allNames[i]);\r\n                }\r\n            }\r\n\r\n            return names;\r\n        }\r\n\r\n        core.copyNodes = function(nodes,parent){\r\n            var copiedNodes,\r\n                i, j,index,base,\r\n                relations = [],\r\n                names,pointer,\r\n                paths = [];\r\n\r\n            //here we also have to copy the inherited relations which points inside the copy area\r\n            for(i=0;i<nodes.length;i++){\r\n                paths.push(core.getPath(nodes[i]));\r\n            }\r\n\r\n            for(i=0;i<nodes.length;i++){\r\n                names = _inheritedPointerNames(nodes[i]);\r\n                pointer = {};\r\n                for(j=0;j<names.length;j++){\r\n                    index = paths.indexOf(core.getPointerPath(nodes[i],names[j]));\r\n                    if(index !== -1){\r\n                        pointer[names[j]] = index;\r\n                    }\r\n                }\r\n                relations.push(pointer);\r\n            }\r\n\r\n            //making the actual copy\r\n            copiedNodes = oldcore.copyNodes(nodes,parent);\r\n            \r\n            //setting internal-inherited relations\r\n            for(i=0;i<nodes.length;i++){\r\n                names = Object.keys(relations[i]);\r\n                for(j=0;j<names.length;j++){\r\n                    core.setPointer(copiedNodes[i],names[j],copiedNodes[relations[i][names[j]]]);\r\n                }\r\n            }\r\n\r\n            //setting base relation\r\n            for(i=0;i<nodes.length;i++){\r\n                base = nodes[i].base;\r\n                copiedNodes[i].base = base;\r\n                oldcore.setPointer(copiedNodes[i],'base',base);\r\n            }\r\n\r\n\r\n            return copiedNodes;\r\n        };\r\n\r\n        core.getDataForSingleHash = function(node){\r\n            ASSERT(isValidNode(node));\r\n            var datas = [];\r\n            while(node){\r\n                datas.push(oldcore.getDataForSingleHash(node));\r\n                node = core.getBase(node);\r\n            }\r\n            return datas;\r\n        };\r\n\r\n        core.getChildrenPaths = function(node){\r\n            var path = core.getPath(node);\r\n\r\n            var relids = core.getChildrenRelids(node);\r\n            for ( var i = 0; i < relids.length; ++i) {\r\n                relids[i] = path + \"/\" + relids[i];\r\n            }\r\n\r\n            return relids;\r\n        };\r\n\r\n        core.deleteNode = function(node,technical){\r\n            //currently we only check if the node is inherited from its parents children\r\n            if(node && (node.base !== null || technical === true)){\r\n                var parent = core.getParent(node),\r\n                    parentsBase = parent ? core.getBase(node) : null,\r\n                    base = core.getBase(node),\r\n                    basesParent = base ? core.getParent(node) : null;\r\n\r\n                if(parent && parentsBase && base && basesParent){\r\n                    if(core.getPath(parentsBase) !== core.getPath(basesParent)){\r\n                        oldcore.deleteNode(node);\r\n                    }\r\n                } else {\r\n                    oldcore.deleteNode(node);\r\n                }\r\n            }\r\n        };\r\n\r\n        core.getTypeRoot = function(node){\r\n            if(node.base){\r\n                while(node.base !== null){\r\n                    node = core.getBase(node);\r\n                }\r\n                return node;\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n\r\n        // -------- kecso\r\n\r\n\t\treturn core;\r\n\t};\r\n\r\n\treturn CoreType;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n/*\r\nexample constraint structure for the outside world:\r\n{\r\nscript:string,\r\npriority:integer,\r\nname:string,\r\nmessage:string\r\n}\r\nprovided API:\r\ngetConstraint(node,name) -> constraintObj\r\nsetConstraint(node,constraintObj)\r\ngetConstraintNames(node)\r\ndelConstraint(node,name)\r\n */\r\ndefine('core/constraintcore',[ \"util/assert\" ], function (ASSERT) {\r\n    \"use strict\";\r\n    var CONSTRAINTS_RELID = \"_constraints\";\r\n    var C_DEF_PRIORITY = 1;\r\n    function constraintCore (_innerCore) {\r\n        var _core = {};\r\n        for(var i in _innerCore){\r\n            _core[i] = _innerCore[i];\r\n        }\r\n\r\n        var createNewConstraintRelId = function(constraintsNode){\r\n            var max = Math.pow(2, 31);\r\n            var existingRelIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var relId;\r\n            do{\r\n                relId = Math.floor(Math.random() * max);\r\n            } while (existingRelIds.indexOf(relId) !== -1);\r\n            return \"\" + relId;\r\n        };\r\n\r\n        var getConstraintRelId = function(constraintsNode,name){\r\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var relId;\r\n            for(var i=0;i<relIds.length;i++){\r\n                if(name === _innerCore.getAttribute(_innerCore.getChild(constraintsNode,relIds[i]),\"name\")){\r\n                    relId = relIds[i];\r\n                    break;\r\n                }\r\n            }\r\n            return relId;\r\n        };\r\n        var getRegConstName = function(name){\r\n            return \"_ch#_\"+name;\r\n        };\r\n        \r\n        _core.getConstraint = function(node,name){\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node,CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode,name);\r\n            if(constRelId){\r\n                var constraintNode = _innerCore.getChild(constraintsNode,constRelId);\r\n                return {\r\n                    \"script\":_innerCore.getAttribute(constraintNode,\"script\"),\r\n                    \"priority\":_innerCore.getAttribute(constraintNode,\"priority\"),\r\n                    \"info\":_innerCore.getAttribute(constraintNode,\"info\")\r\n                };\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n\r\n        _core.setConstraint = function(node,name,constraintObj){\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');\r\n            var constraintsNode = _innerCore.getChild(node,CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode,name);\r\n            if(!constRelId){\r\n                //we should create a new one\r\n                constRelId = createNewConstraintRelId(constraintsNode);\r\n            }\r\n\r\n            var constraintNode = _innerCore.getChild(constraintsNode,constRelId);\r\n            constraintObj.priority = constraintObj.priority || C_DEF_PRIORITY;\r\n            constraintObj.script = constraintObj.script || \"console.log(\\\"empty constraint\\\");\";\r\n            constraintObj.info = constraintObj.info || \"\";\r\n            _innerCore.setAttribute(constraintNode,\"name\",name);\r\n            _innerCore.setAttribute(constraintNode,\"script\",constraintObj.script);\r\n            _innerCore.setAttribute(constraintNode,\"priority\",constraintObj.priority);\r\n            _innerCore.setAttribute(constraintNode,\"info\",constraintObj.info);\r\n            _innerCore.setRegistry(node,getRegConstName(name),(_innerCore.getRegistry(node,getRegConstName(name)) || 0)+1);\r\n        };\r\n\r\n        _core.delConstraint = function(node,name){\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node,CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode,name);\r\n            if(constRelId){\r\n                var constraintNode = _innerCore.getChild(constraintsNode,constRelId);\r\n                _innerCore.deleteNode(constraintNode,true);\r\n            }\r\n            _innerCore.delRegistry(node,getRegConstName(name));\r\n        };\r\n\r\n        _core.getConstraintNames = function(node){\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node,CONSTRAINTS_RELID);\r\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var names = [];\r\n            for(var i=0;i<relIds.length;i++){\r\n                names.push(_innerCore.getAttribute(_innerCore.getChild(constraintsNode,relIds[i]),\"name\"));\r\n            }\r\n            return names;\r\n        };\r\n\r\n        //TODO this means we always have to have this layer above type/inheritance layer\r\n        _core.getOwnConstraintNames = function(node){\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var names = _core.getConstraintNames(node),\r\n                base = _core.getBase(node),\r\n                baseNames = [], i,index;\r\n\r\n            if(base){\r\n                baseNames = _core.getConstraintNames(base);\r\n            }\r\n\r\n            for(i=0;i<baseNames.length;i++){\r\n                index = names.indexOf(baseNames[i]);\r\n                if(index !== -1){\r\n                    names.splice(index,1);\r\n                }\r\n            }\r\n\r\n            return names;\r\n        };\r\n\r\n        return _core;\r\n    }\r\n\r\n    return constraintCore;\r\n});\r\n\n",
    "/* jshint proto: true */\r\n\r\n/**\r\n * jjv.js -- A javascript library to validate json input through a json-schema.\r\n *\r\n * Copyright (c) 2013 Alex Cornejo.\r\n *\r\n * Redistributable under a MIT-style open source license.\r\n */\r\n\r\n(function () {\r\n  var clone = function (obj) {\r\n      // Handle the 3 simple types (string, number, function), and null or undefined\r\n      if (obj === null || typeof obj !== 'object') return obj;\r\n      var copy;\r\n\r\n      // Handle Date\r\n      if (obj instanceof Date) {\r\n          copy = new Date();\r\n          copy.setTime(obj.getTime());\r\n          return copy;\r\n      }\r\n\r\n      // handle RegExp\r\n      if (obj instanceof RegExp) {\r\n        copy = new RegExp(obj);\r\n        return copy;\r\n      }\r\n\r\n      // Handle Array\r\n      if (obj instanceof Array) {\r\n          copy = [];\r\n          for (var i = 0, len = obj.length; i < len; i++)\r\n              copy[i] = clone(obj[i]);\r\n          return copy;\r\n      }\r\n\r\n      // Handle Object\r\n      if (obj instanceof Object) {\r\n          copy = {};\r\n//           copy = Object.create(Object.getPrototypeOf(obj));\r\n          for (var attr in obj) {\r\n              if (obj.hasOwnProperty(attr))\r\n                copy[attr] = clone(obj[attr]);\r\n          }\r\n          return copy;\r\n      }\r\n\r\n      throw new Error(\"Unable to clone object!\");\r\n  };\r\n\r\n  var clone_stack = function (stack) {\r\n    var stack_last = stack.length-1, key = stack[stack_last].key;\r\n    var new_stack = stack.slice(0);\r\n    new_stack[stack_last].object[key] = clone(new_stack[stack_last].object[key]);\r\n    return new_stack;\r\n  };\r\n\r\n  var copy_stack = function (new_stack, old_stack) {\r\n    var stack_last = new_stack.length-1, key = new_stack[stack_last].key;\r\n    old_stack[stack_last].object[key] = new_stack[stack_last].object[key];\r\n  };\r\n\r\n  var handled = {\r\n    'type': true,\r\n    'not': true,\r\n    'anyOf': true,\r\n    'allOf': true,\r\n    'oneOf': true,\r\n    '$ref': true,\r\n    '$schema': true,\r\n    'id': true,\r\n    'exclusiveMaximum': true,\r\n    'exclusiveMininum': true,\r\n    'properties': true,\r\n    'patternProperties': true,\r\n    'additionalProperties': true,\r\n    'items': true,\r\n    'additionalItems': true,\r\n    'required': true,\r\n    'default': true,\r\n    'title': true,\r\n    'description': true,\r\n    'definitions': true,\r\n    'dependencies': true\r\n  };\r\n\r\n  var fieldType = {\r\n    'null': function (x) {\r\n      return x === null;\r\n    },\r\n    'string': function (x) {\r\n      return typeof x === 'string';\r\n    },\r\n    'boolean': function (x) {\r\n      return typeof x === 'boolean';\r\n    },\r\n    'number': function (x) {\r\n      return typeof x === 'number' && !isNaN(x);\r\n    },\r\n    'integer': function (x) {\r\n      return typeof x === 'number' && x%1 === 0;\r\n    },\r\n    'object': function (x) {\r\n      return x && typeof x === 'object' && !Array.isArray(x);\r\n    },\r\n    'array': function (x) {\r\n      return Array.isArray(x);\r\n    },\r\n    'date': function (x) {\r\n      return x instanceof Date;\r\n    }\r\n  };\r\n\r\n  // missing: uri, date-time, ipv4, ipv6\r\n  var fieldFormat = {\r\n    'alpha': function (v) {\r\n      return (/^[a-zA-Z]+$/).test(v);\r\n    },\r\n    'alphanumeric': function (v) {\r\n      return (/^[a-zA-Z0-9]+$/).test(v);\r\n    },\r\n    'identifier': function (v) {\r\n      return (/^[-_a-zA-Z0-9]+$/).test(v);\r\n    },\r\n    'hexadecimal': function (v) {\r\n      return (/^[a-fA-F0-9]+$/).test(v);\r\n    },\r\n    'numeric': function (v) {\r\n      return (/^[0-9]+$/).test(v);\r\n    },\r\n    'date-time': function (v) {\r\n      return !isNaN(Date.parse(v)) && v.indexOf('/') === -1;\r\n    },\r\n    'uppercase': function (v) {\r\n      return v === v.toUpperCase();\r\n    },\r\n    'lowercase': function (v) {\r\n      return v === v.toLowerCase();\r\n    },\r\n    'hostname': function (v) {\r\n      return v.length < 256 && (/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$/).test(v);\r\n    },\r\n    'uri': function (v) {\r\n      return (/[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,4}\\b(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?/).test(v);\r\n    },\r\n    'email': function (v) { // email, ipv4 and ipv6 adapted from node-validator\r\n      return (/^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/).test(v);\r\n    },\r\n    'ipv4': function (v) {\r\n      if ((/^(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)$/).test(v)) {\r\n        var parts = v.split('.').sort();\r\n        if (parts[3] <= 255)\r\n          return true;\r\n      }\r\n      return false;\r\n    },\r\n    'ipv6': function(v) {\r\n      return (/^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/).test(v);\r\n     /*  return (/^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/).test(v); */\r\n    }\r\n  };\r\n\r\n  var fieldValidate = {\r\n    'readOnly': function (v, p) {\r\n      return false;\r\n    },\r\n    // ****** numeric validation ********\r\n    'minimum': function (v, p, schema) {\r\n      return !(v < p || schema.exclusiveMinimum && v <= p);\r\n    },\r\n    'maximum': function (v, p, schema) {\r\n      return !(v > p || schema.exclusiveMaximum && v >= p);\r\n    },\r\n    'multipleOf': function (v, p) {\r\n      return (v/p)%1 === 0 || typeof v !== 'number';\r\n    },\r\n    // ****** string validation ******\r\n    'pattern': function (v, p) {\r\n      if (typeof v !== 'string')\r\n        return true;\r\n      var pattern, modifiers;\r\n      if (typeof p === 'string')\r\n        pattern=p;\r\n      else {\r\n        pattern=p[0];\r\n        modifiers=p[1];\r\n      }\r\n      var regex = new RegExp(pattern, modifiers);\r\n      return regex.test(v);\r\n    },\r\n    'minLength': function (v, p) {\r\n      return v.length >= p || typeof v !== 'string';\r\n    },\r\n    'maxLength': function (v, p) {\r\n      return v.length <= p || typeof v !== 'string';\r\n    },\r\n    // ***** array validation *****\r\n    'minItems': function (v, p) {\r\n      return v.length >= p || !Array.isArray(v);\r\n    },\r\n    'maxItems': function (v, p) {\r\n      return v.length <= p || !Array.isArray(v);\r\n    },\r\n    'uniqueItems': function (v, p) {\r\n      var hash = {}, key;\r\n      for (var i = 0, len = v.length; i < len; i++) {\r\n        key = JSON.stringify(v[i]);\r\n        if (hash.hasOwnProperty(key))\r\n          return false;\r\n        else\r\n          hash[key] = true;\r\n      }\r\n      return true;\r\n    },\r\n    // ***** object validation ****\r\n    'minProperties': function (v, p) {\r\n      if (typeof v !== 'object')\r\n        return true;\r\n      var count = 0;\r\n      for (var attr in v) if (v.hasOwnProperty(attr)) count = count + 1;\r\n      return count >= p;\r\n    },\r\n    'maxProperties': function (v, p) {\r\n      if (typeof v !== 'object')\r\n        return true;\r\n      var count = 0;\r\n      for (var attr in v) if (v.hasOwnProperty(attr)) count = count + 1;\r\n      return count <= p;\r\n    },\r\n    // ****** all *****\r\n    'enum': function (v, p) {\r\n      var i, len, vs;\r\n      if (typeof v === 'object') {\r\n        vs = JSON.stringify(v);\r\n        for (i = 0, len = p.length; i < len; i++)\r\n          if (vs === JSON.stringify(p[i]))\r\n            return true;\r\n      } else {\r\n        for (i = 0, len = p.length; i < len; i++)\r\n          if (v === p[i])\r\n            return true;\r\n      }\r\n      return false;\r\n    }\r\n  };\r\n\r\n  var normalizeID = function (id) {\r\n    return id.indexOf(\"://\") === -1 ? id : id.split(\"#\")[0];\r\n  };\r\n\r\n  var resolveURI = function (env, schema_stack, uri) {\r\n    var curschema, components, hash_idx, name;\r\n\r\n    hash_idx = uri.indexOf('#');\r\n\r\n    if (hash_idx === -1) {\r\n      if (!env.schema.hasOwnProperty(uri))\r\n        return null;\r\n      return [env.schema[uri]];\r\n    }\r\n\r\n    if (hash_idx > 0) {\r\n      name = uri.substr(0, hash_idx);\r\n      uri = uri.substr(hash_idx+1);\r\n      if (!env.schema.hasOwnProperty(name)) {\r\n        if (schema_stack && schema_stack[0].id === name)\r\n          schema_stack = [schema_stack[0]];\r\n        else\r\n          return null;\r\n      } else\r\n        schema_stack = [env.schema[name]];\r\n    } else {\r\n      if (!schema_stack)\r\n        return null;\r\n      uri = uri.substr(1);\r\n    }\r\n\r\n    if (uri === '')\r\n      return [schema_stack[0]];\r\n\r\n    if (uri.charAt(0) === '/') {\r\n      uri = uri.substr(1);\r\n      curschema = schema_stack[0];\r\n      components = uri.split('/');\r\n      while (components.length > 0) {\r\n        if (!curschema.hasOwnProperty(components[0]))\r\n          return null;\r\n        curschema = curschema[components[0]];\r\n        schema_stack.push(curschema);\r\n        components.shift();\r\n      }\r\n      return schema_stack;\r\n    } else // FIX: should look for subschemas whose id matches uri\r\n      return null;\r\n  };\r\n\r\n  var resolveObjectRef = function (object_stack, uri) {\r\n    var components, object, last_frame = object_stack.length-1, skip_frames, frame, m = /^(\\d+)/.exec(uri);\r\n\r\n    if (m) {\r\n      uri = uri.substr(m[0].length);\r\n      skip_frames = parseInt(m[1], 10);\r\n      if (skip_frames < 0 || skip_frames > last_frame)\r\n        return;\r\n      frame = object_stack[last_frame-skip_frames];\r\n      if (uri === '#')\r\n        return frame.key;\r\n    } else\r\n      frame = object_stack[0];\r\n\r\n    object = frame.object[frame.key];\r\n\r\n    if (uri === '')\r\n      return object;\r\n\r\n    if (uri.charAt(0) === '/') {\r\n      uri = uri.substr(1);\r\n      components = uri.split('/');\r\n      while (components.length > 0) {\r\n        components[0] = components[0].replace(/~1/g, '/').replace(/~0/g, '~');\r\n        if (!object.hasOwnProperty(components[0]))\r\n          return;\r\n        object = object[components[0]];\r\n        components.shift();\r\n      }\r\n      return object;\r\n    } else\r\n      return;\r\n  };\r\n\r\n  var checkValidity = function (env, schema_stack, object_stack, options) {\r\n    var i, len, count, hasProp, hasPattern;\r\n    var p, v, malformed = false, objerrs = {}, objerr, objreq, errors = {}, props, matched, isArray;\r\n    var sl = schema_stack.length-1, schema = schema_stack[sl];\r\n    var ol = object_stack.length-1, object = object_stack[ol].object, name = object_stack[ol].key, prop = object[name];\r\n\r\n    if (schema.hasOwnProperty('$ref')) {\r\n      schema_stack= resolveURI(env, schema_stack, schema.$ref);\r\n      if (!schema_stack)\r\n        return {'$ref': schema.$ref};\r\n      else\r\n        return checkValidity(env, schema_stack, object_stack, options);\r\n    }\r\n\r\n    if (schema.hasOwnProperty('type')) {\r\n      if (typeof schema.type === 'string') {\r\n        if (options.useCoerce && env.coerceType.hasOwnProperty(schema.type))\r\n          prop = object[name] = env.coerceType[schema.type](prop);\r\n        if (!env.fieldType[schema.type](prop))\r\n          return {'type': schema.type};\r\n      } else {\r\n        malformed = true;\r\n        for (i = 0, len = schema.type.length; i < len && malformed; i++)\r\n          if (env.fieldType[schema.type[i]](prop))\r\n            malformed = false;\r\n        if (malformed)\r\n          return {'type': schema.type};\r\n      }\r\n    }\r\n\r\n    if (schema.hasOwnProperty('allOf')) {\r\n      for (i = 0, len = schema.allOf.length; i < len; i++) {\r\n        objerr = checkValidity(env, schema_stack.concat(schema.allOf[i]), object_stack, options);\r\n        if (objerr)\r\n          return objerr;\r\n      }\r\n    }\r\n\r\n    if (!options.useCoerce && !options.useDefault && !options.removeAdditional) {\r\n      if (schema.hasOwnProperty('oneOf')) {\r\n        for (i = 0, len = schema.oneOf.length, count = 0; i < len; i++) {\r\n          objerr = checkValidity(env, schema_stack.concat(schema.oneOf[i]), object_stack, options);\r\n          if (!objerr) {\r\n            count = count + 1;\r\n            if (count > 1)\r\n              break;\r\n          } else {\r\n            objerrs = objerr;\r\n          }\r\n        }\r\n        if (count > 1)\r\n          return {'oneOf': true};\r\n        else if (count < 1)\r\n          return objerrs;\r\n        objerrs = {};\r\n      }\r\n\r\n      if (schema.hasOwnProperty('anyOf')) {\r\n        for (i = 0, len = schema.anyOf.length; i < len; i++) {\r\n          objerr = checkValidity(env, schema_stack.concat(schema.anyOf[i]), object_stack, options);\r\n          if (!objerr)\r\n            break;\r\n        }\r\n        if (objerr)\r\n          return objerr;\r\n      }\r\n\r\n      if (schema.hasOwnProperty('not')) {\r\n        objerr = checkValidity(env, schema_stack.concat(schema.not), object_stack, options);\r\n        if (!objerr)\r\n          return {'not': true};\r\n      }\r\n    } else {\r\n      if (schema.hasOwnProperty('oneOf')) {\r\n        for (i = 0, len = schema.oneOf.length, count = 0; i < len; i++) {\r\n          new_stack = clone_stack(object_stack);\r\n          objerr = checkValidity(env, schema_stack.concat(schema.oneOf[i]), new_stack, options);\r\n          if (!objerr) {\r\n            count = count + 1;\r\n            if (count > 1)\r\n              break;\r\n            else\r\n              copy_stack(new_stack, object_stack);\r\n          } else {\r\n            objerrs = objerr;\r\n          }\r\n        }\r\n        if (count > 1)\r\n          return {'oneOf': true};\r\n        else if (count < 1)\r\n          return objerrs;\r\n        objerrs = {};\r\n      }\r\n\r\n      if (schema.hasOwnProperty('anyOf')) {\r\n        for (i = 0, len = schema.anyOf.length; i < len; i++) {\r\n          new_stack = clone_stack(object_stack);\r\n          objerr = checkValidity(env, schema_stack.concat(schema.anyOf[i]), new_stack, options);\r\n          if (!objerr) {\r\n            copy_stack(new_stack, object_stack);\r\n            break;\r\n          }\r\n        }\r\n        if (objerr)\r\n          return objerr;\r\n      }\r\n\r\n      if (schema.hasOwnProperty('not')) {\r\n        objerr = checkValidity(env, schema_stack.concat(schema.not), clone_stack(object_stack), options);\r\n        if (!objerr)\r\n          return {'not': true};\r\n      }\r\n    }\r\n\r\n    if (schema.hasOwnProperty('dependencies')) {\r\n      for (p in schema.dependencies)\r\n        if (schema.dependencies.hasOwnProperty(p) && prop.hasOwnProperty(p)) {\r\n          if (Array.isArray(schema.dependencies[p])) {\r\n            for (i = 0, len = schema.dependencies[p].length; i < len; i++)\r\n              if (!prop.hasOwnProperty(schema.dependencies[p][i])) {\r\n                return {'dependencies': true};\r\n              }\r\n          } else {\r\n            objerr = checkValidity(env, schema_stack.concat(schema.dependencies[p]), object_stack, options);\r\n            if (objerr)\r\n              return objerr;\r\n          }\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(prop)) {\r\n      props = [];\r\n      objerrs = {};\r\n      for (p in prop)\r\n        if (prop.hasOwnProperty(p))\r\n          props.push(p);\r\n\r\n      if (options.checkRequired && schema.required) {\r\n        for (i = 0, len = schema.required.length; i < len; i++)\r\n          if (!prop.hasOwnProperty(schema.required[i])) {\r\n            objerrs[schema.required[i]] = {'required': true};\r\n            malformed = true;\r\n          }\r\n      }\r\n\r\n      hasProp = schema.hasOwnProperty('properties');\r\n      hasPattern = schema.hasOwnProperty('patternProperties');\r\n      if (hasProp || hasPattern) {\r\n        i = props.length;\r\n        while (i--) {\r\n          matched = false;\r\n          if (hasProp && schema.properties.hasOwnProperty(props[i])) {\r\n            matched = true;\r\n            objerr = checkValidity(env, schema_stack.concat(schema.properties[props[i]]), object_stack.concat({object: prop, key: props[i]}), options);\r\n            if (objerr !== null) {\r\n              objerrs[props[i]] = objerr;\r\n              malformed = true;\r\n            }\r\n          }\r\n          if (hasPattern) {\r\n            for (p in schema.patternProperties)\r\n              if (schema.patternProperties.hasOwnProperty(p) && props[i].match(p)) {\r\n                matched = true;\r\n                objerr = checkValidity(env, schema_stack.concat(schema.patternProperties[p]), object_stack.concat({object: prop, key: props[i]}), options);\r\n                if (objerr !== null) {\r\n                  objerrs[props[i]] = objerr;\r\n                  malformed = true;\r\n                }\r\n              }\r\n          }\r\n          if (matched)\r\n            props.splice(i, 1);\r\n        }\r\n      }\r\n\r\n      if (options.useDefault && hasProp && !malformed) {\r\n        for (p in schema.properties)\r\n          if (schema.properties.hasOwnProperty(p) && !prop.hasOwnProperty(p) && schema.properties[p].hasOwnProperty('default'))\r\n            prop[p] = schema.properties[p]['default'];\r\n      }\r\n\r\n      if (options.removeAdditional && hasProp && schema.additionalProperties !== true && typeof schema.additionalProperties !== 'object') {\r\n        for (i = 0, len = props.length; i < len; i++)\r\n          delete prop[props[i]];\r\n      } else {\r\n        if (schema.hasOwnProperty('additionalProperties')) {\r\n          if (typeof schema.additionalProperties === 'boolean') {\r\n            if (!schema.additionalProperties) {\r\n              for (i = 0, len = props.length; i < len; i++) {\r\n                objerrs[props[i]] = {'additional': true};\r\n                malformed = true;\r\n              }\r\n            }\r\n          } else {\r\n            for (i = 0, len = props.length; i < len; i++) {\r\n              objerr = checkValidity(env, schema_stack.concat(schema.additionalProperties), object_stack.concat({object: prop, key: props[i]}), options);\r\n              if (objerr !== null) {\r\n                objerrs[props[i]] = objerr;\r\n                malformed = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (malformed)\r\n        return {'schema': objerrs};\r\n    } else {\r\n      if (schema.hasOwnProperty('items')) {\r\n        if (Array.isArray(schema.items)) {\r\n          for (i = 0, len = schema.items.length; i < len; i++) {\r\n            objerr = checkValidity(env, schema_stack.concat(schema.items[i]), object_stack.concat({object: prop, key: i}), options);\r\n            if (objerr !== null) {\r\n              objerrs[i] = objerr;\r\n              malformed = true;\r\n            }\r\n          }\r\n          if (prop.length > len && schema.hasOwnProperty('additionalItems')) {\r\n            if (typeof schema.additionalItems === 'boolean') {\r\n              if (!schema.additionalItems)\r\n                return {'additionalItems': true};\r\n            } else {\r\n              for (i = len, len = prop.length; i < len; i++) {\r\n                objerr = checkValidity(env, schema_stack.concat(schema.additionalItems), object_stack.concat({object: prop, key: i}), options);\r\n                if (objerr !== null) {\r\n                  objerrs[i] = objerr;\r\n                  malformed = true;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          for (i = 0, len = prop.length; i < len; i++) {\r\n            objerr = checkValidity(env, schema_stack.concat(schema.items), object_stack.concat({object: prop, key: i}), options);\r\n            if (objerr !== null) {\r\n              objerrs[i] = objerr;\r\n              malformed = true;\r\n            }\r\n          }\r\n        }\r\n      } else if (schema.hasOwnProperty('additionalItems')) {\r\n        if (typeof schema.additionalItems !== 'boolean') {\r\n          for (i = 0, len = prop.length; i < len; i++) {\r\n            objerr = checkValidity(env, schema_stack.concat(schema.additionalItems), object_stack.concat({object: prop, key: i}), options);\r\n            if (objerr !== null) {\r\n              objerrs[i] = objerr;\r\n              malformed = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (malformed)\r\n        return {'schema': objerrs};\r\n    }\r\n\r\n    for (v in schema) {\r\n      if (schema.hasOwnProperty(v) && !handled.hasOwnProperty(v)) {\r\n        if (v === 'format') {\r\n          if (env.fieldFormat.hasOwnProperty(schema[v]) && !env.fieldFormat[schema[v]](prop, schema, object_stack, options)) {\r\n            objerrs[v] = true;\r\n            malformed = true;\r\n          }\r\n        } else {\r\n          if (env.fieldValidate.hasOwnProperty(v) && !env.fieldValidate[v](prop, schema[v].hasOwnProperty('$data') ? resolveObjectRef(object_stack, schema[v].$data) : schema[v], schema, object_stack, options)) {\r\n            objerrs[v] = true;\r\n            malformed = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (malformed)\r\n      return objerrs;\r\n    else\r\n      return null;\r\n  };\r\n\r\n  var defaultOptions = {\r\n    useDefault: false,\r\n    useCoerce: false,\r\n    checkRequired: true,\r\n    removeAdditional: false\r\n  };\r\n\r\n  function Environment() {\r\n    if (!(this instanceof Environment))\r\n      return new Environment();\r\n\r\n    this.coerceType = {};\r\n    this.fieldType = clone(fieldType);\r\n    this.fieldValidate = clone(fieldValidate);\r\n    this.fieldFormat = clone(fieldFormat);\r\n    this.defaultOptions = clone(defaultOptions);\r\n    this.schema = {};\r\n  }\r\n\r\n  Environment.prototype = {\r\n    validate: function (name, object, options) {\r\n      var schema_stack = [name], errors = null, object_stack = [{object: {'__root__': object}, key: '__root__'}];\r\n\r\n      if (typeof name === 'string') {\r\n        schema_stack = resolveURI(this, null, name);\r\n        if (!schema_stack)\r\n          throw new Error('jjv: could not find schema \\'' + name + '\\'.');\r\n      }\r\n\r\n      if (!options) {\r\n        options = this.defaultOptions;\r\n      } else {\r\n        for (var p in this.defaultOptions)\r\n          if (this.defaultOptions.hasOwnProperty(p) && !options.hasOwnProperty(p))\r\n            options[p] = this.defaultOptions[p];\r\n      }\r\n\r\n      errors = checkValidity(this, schema_stack, object_stack, options);\r\n\r\n      if (errors)\r\n        return {validation: errors.hasOwnProperty('schema') ? errors.schema : errors};\r\n      else\r\n        return null;\r\n    },\r\n\r\n    resolveRef: function (schema_stack, $ref) {\r\n      return resolveURI(this, schema_stack, $ref);\r\n    },\r\n\r\n    addType: function (name, func) {\r\n      this.fieldType[name] = func;\r\n    },\r\n\r\n    addTypeCoercion: function (type, func) {\r\n      this.coerceType[type] = func;\r\n    },\r\n\r\n    addCheck: function (name, func) {\r\n      this.fieldValidate[name] = func;\r\n    },\r\n\r\n    addFormat: function (name, func) {\r\n      this.fieldFormat[name] = func;\r\n    },\r\n\r\n    addSchema: function (name, schema) {\r\n      if (!schema && name) {\r\n        schema = name;\r\n        name = undefined;\r\n      }\r\n      if (schema.hasOwnProperty('id') && typeof schema.id === 'string' && schema.id !== name) {\r\n        if (schema.id.charAt(0) === '/')\r\n          throw new Error('jjv: schema id\\'s starting with / are invalid.');\r\n        this.schema[normalizeID(schema.id)] = schema;\r\n      } else if (!name) {\r\n        throw new Error('jjv: schema needs either a name or id attribute.');\r\n      }\r\n      if (name)\r\n        this.schema[normalizeID(name)] = schema;\r\n    }\r\n  };\r\n\r\n  // Export for use in server and client.\r\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\r\n    module.exports = Environment;\r\n  else if (typeof define === 'function' && define.amd)\r\n    define('util/jjv',[],function () {return Environment;});\r\n  else\r\n    window.jjv = Environment;\r\n})();\r\n\n",
    "define('core/metacore',[ \"util/assert\", \"core/core\", \"core/tasync\", \"util/jjv\", \"util/canon\" ], function(ASSERT, Core, TASYNC, JsonValidator, CANON) {\r\n    \"use strict\";\r\n\r\n    // ----------------- CoreType -----------------\r\n\r\n    var MetaCore = function(oldcore) {\r\n        // copy all operations\r\n        var core = {};\r\n        for ( var key in oldcore) {\r\n            core[key] = oldcore[key];\r\n        }\r\n\r\n        var sameNode = function(nodeA,nodeB){\r\n            if(core.getPath(nodeA) === core.getPath(nodeB)){\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n\r\n        var realNode = function(node){ //TODO we have to make some more sophisticated distinction\r\n            if(core.getPath(node).indexOf('_') !== -1){\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        var MetaNode = function(node){\r\n            return core.getChild(node,\"_meta\");\r\n        };\r\n        var MetaChildrenNode = function(node){\r\n            return core.getChild(MetaNode(node),\"children\");\r\n        };\r\n        var MetaPointerNode = function(node,name){\r\n            var meta = MetaNode(node),\r\n                pointerNames = core.getPointerNames(meta) || [];\r\n            if(pointerNames.indexOf(name) !== -1){\r\n                return core.getChild(meta,\"_p_\"+name);\r\n            }\r\n            return null;\r\n        };\r\n        var _MetaPointerNode = function(node,name){\r\n            //this function always gives back a node, use this if you just want to create the node as well\r\n            core.setPointer(MetaNode(node),name,null);\r\n            return core.getChild(MetaNode(node),\"_p_\"+name);\r\n        };\r\n\r\n        var MetaAspectsNode = function(node){\r\n            return core.getChild(MetaNode(node),'aspects');\r\n        };\r\n        var MetaAspectNode = function(node,name){\r\n            var aspectNode = MetaAspectsNode(node),\r\n                names = core.getPointerNames(aspectNode) ||[];\r\n            if(names.indexOf(name) !== -1){\r\n                return core.getChild(aspectNode,\"_a_\"+name);\r\n            }\r\n            return null;\r\n        };\r\n\r\n        var _MetaAspectNode = function(node,name){\r\n            //this function always gives back a node, use this if you just want to create the node as well\r\n            var aspectNode = core.getChild(MetaNode(node),'aspects');\r\n\r\n            core.setPointer(aspectNode,name,null);\r\n            return core.getChild(aspectNode,\"_a_\"+name);\r\n        };\r\n        //now the additional functions\r\n        core.isTypeOf = function(node, typeNode){\r\n            if(!realNode(node)){\r\n                return false;\r\n            }\r\n            while(node){\r\n                if(sameNode(node,typeNode)){\r\n                    return true;\r\n                }\r\n                node = core.getBase(node);\r\n            }\r\n            return false;\r\n        };\r\n\r\n        core.isValidChildOf = function(node,parentNode){\r\n            if(!realNode(node)){\r\n                return true;\r\n            }\r\n            var validChildTypePaths = core.getMemberPaths(MetaChildrenNode(parentNode),\"items\") || [];\r\n            while(node){\r\n                if(validChildTypePaths.indexOf(core.getPath(node)) !== -1){\r\n                    return true;\r\n                }\r\n                node = core.getBase(node);\r\n            }\r\n            return false;\r\n        };\r\n\r\n        core.getValidPointerNames = function(node){\r\n            var validNames = core.getPointerNames(MetaNode(node)) || [],\r\n                i,\r\n                validPointerNames = [],\r\n                metaPointerNode;\r\n\r\n            for(i=0;i<validNames.length;i++){\r\n                metaPointerNode = MetaPointerNode(node,validNames[i]);\r\n                if(metaPointerNode.max === 1){ //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\r\n                    validPointerNames.push(validNames[i]);\r\n                }\r\n            }\r\n\r\n            return validPointerNames;\r\n        };\r\n\r\n        core.getValidSetNames = function(node){\r\n            var validNames = core.getPointerNames(MetaNode(node)) || [],\r\n                i,\r\n                validSetNames = [],\r\n                metaPointerNode;\r\n\r\n            for(i=0;i<validNames.length;i++){\r\n                metaPointerNode = MetaPointerNode(node,validNames[i]);\r\n                if(metaPointerNode.max === undefined || metaPointerNode.max === -1 || metaPointerNode.max > 1){ //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\r\n                    validSetNames.push(validNames[i]);\r\n                }\r\n            }\r\n\r\n            return validSetNames;\r\n        };\r\n\r\n        core.isValidTargetOf = function(node,source,name){\r\n            if(!realNode(source) || node === null){ //we position ourselves over the null-pointer layer\r\n                return true;\r\n            }\r\n            var pointerMetaNode = MetaPointerNode(source,name);\r\n            if(pointerMetaNode){\r\n                var validTargetTypePaths = core.getMemberPaths(pointerMetaNode,\"items\") || [];\r\n                while(node){\r\n                    if(validTargetTypePaths.indexOf(core.getPath(node)) !== -1){\r\n                        return true;\r\n                    }\r\n                    node = core.getBase(node);\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        core.getValidAttributeNames = function(node){\r\n            var names = [];\r\n            if(realNode(node)){\r\n                names = core.getAttributeNames(MetaNode(node)) || [];\r\n            }\r\n            return names;\r\n        };\r\n\r\n        core.isValidAttributeValueOf = function(node,name,value){\r\n            //currently it only checks the name and the type\r\n            if(!realNode(node)){\r\n                return true;\r\n            }\r\n            if(core.getValidAttributeNames(node).indexOf(name) === -1){\r\n                return false;\r\n            }\r\n            var meta = core.getAttribute(MetaNode(node),name);\r\n            switch(meta.type){\r\n                case \"boolean\":\r\n                    if(value === true || value === false){\r\n                        return true;\r\n                    }\r\n                    break;\r\n                case \"string\":\r\n                case \"asset\":\r\n                    if(typeof value === 'string'){\r\n                        return true;\r\n                    }\r\n                    break;\r\n                case \"integer\":\r\n                    if(!isNaN(parseInt(value)) && parseFloat(value) === parseInt(value)) {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                case \"float\":\r\n                    if(!isNaN(parseFloat(value))) {\r\n                        return true;\r\n                    }\r\n                    break;\r\n            }\r\n            return false;\r\n        };\r\n\r\n\r\n\r\n        core.getValidAspectNames = function(node){\r\n            return core.getPointerNames(MetaAspectsNode(node)) ||[];\r\n        };\r\n\r\n        //additional meta functions for getting meta definitions\r\n        core.getJsonMeta = function(node){\r\n            var meta = {children:{},attributes:{},pointers:{},aspects:{},constraints:{}},\r\n                tempNode,\r\n                names,\r\n                pointer,\r\n                i,j;\r\n\r\n            //fill children part\r\n            tempNode = MetaChildrenNode(node);\r\n\r\n            meta.children.minItems = [];\r\n            meta.children.maxItems = [];\r\n            meta.children.items = core.getMemberPaths(tempNode,\"items\");\r\n            for(i=0;i<meta.children.items.length;i++){\r\n                meta.children.minItems.push(core.getMemberAttribute(tempNode,\"items\",meta.children.items[i],\"min\") || -1);\r\n                meta.children.maxItems.push(core.getMemberAttribute(tempNode,\"items\",meta.children.items[i],\"max\") || -1);\r\n            }\r\n            meta.children.min = core.getAttribute(tempNode,\"min\");\r\n            meta.children.max = core.getAttribute(tempNode,\"max\");\r\n\r\n            //attributes\r\n            names = core.getValidAttributeNames(node);\r\n            for(i=0;i<names.length;i++){\r\n                meta.attributes[names[i]] = core.getAttribute(MetaNode(node),names[i]);\r\n            }\r\n\r\n            //pointers\r\n            names = core.getPointerNames(MetaNode(node));\r\n            for(i=0;i<names.length;i++){\r\n                tempNode = MetaPointerNode(node,names[i]);\r\n                pointer = {};\r\n\r\n                pointer.items = core.getMemberPaths(tempNode,\"items\");\r\n                pointer.min = core.getAttribute(tempNode,\"min\");\r\n                pointer.max = core.getAttribute(tempNode,\"max\");\r\n                pointer.minItems = [];\r\n                pointer.maxItems = [];\r\n\r\n                for(j=0;j<pointer.items.length;j++){\r\n                    pointer.minItems.push(core.getMemberAttribute(tempNode,\"items\",pointer.items[j],\"min\") || -1);\r\n                    pointer.maxItems.push(core.getMemberAttribute(tempNode,\"items\",pointer.items[j],\"max\") || -1);\r\n\r\n                }\r\n\r\n                meta.pointers[names[i]] = pointer;\r\n            }\r\n\r\n            //aspects\r\n            names = core.getValidAspectNames(node);\r\n\r\n            for(i=0;i<names.length;i++){\r\n                tempNode = MetaAspectNode(node,names[i]);\r\n                meta.aspects[names[i]] = core.getMemberPaths(tempNode,'items') || [];\r\n            }\r\n\r\n            //constraints\r\n            names = core.getConstraintNames(node);\r\n            for(i=0;i<names.length;i++){\r\n                meta.constraints[names[i]] = core.getConstraint(node,names[i]);\r\n            }\r\n\r\n            return meta;\r\n        };\r\n\r\n        var getMetaObjectDiff = function(bigger,smaller){\r\n            //TODO this is a specific diff calculation for META rule JSONs\r\n            var diff = {},names, i,\r\n              itemedElementDiff = function(bigItem,smallItem){\r\n                  var diff, diffItems = {}, i,index,names;\r\n                  for(i=0;i<bigItem.items.length;i++){\r\n                      if(smallItem.items.indexOf(bigItem.items[i]) === -1){\r\n                          diffItems[bigItem.items[i]] = true;\r\n                      }\r\n                  }\r\n                  names = Object.keys(diffItems);\r\n                  for(i=0;i<names.length;i++){\r\n                      diff = diff || {items:[],minItems:[],maxItems:[]};\r\n                      index = bigItem.items.indexOf(names[i]);\r\n                      diff.items.push(bigItem.items[index]);\r\n                      diff.minItems.push(bigItem.minItems[index]);\r\n                      diff.maxItems.push(bigItem.maxItems[index]);\r\n                  }\r\n                  if(bigItem.min && ((smallItem.min && bigItem.min !== smallItem.min) || !smallItem.min)){\r\n                      diff = diff || {};\r\n                      diff.min = bigItem.min;\r\n                  }\r\n                  if(bigItem.max && ((smallItem.max && bigItem.max !== smallItem.max) || !smallItem.max)){\r\n                      diff = diff || {};\r\n                      diff.max = bigItem.max;\r\n                  }\r\n                  return diff || {};\r\n              };\r\n            //attributes\r\n            if(smaller.attributes){\r\n                names = Object.keys(bigger.attributes);\r\n                for(i=0;i<names.length;i++){\r\n                    if(smaller.attributes[names[i]]){\r\n                        //they both have the attribute - if it differs we keep the whole of the bigger\r\n                        if(CANON.stringify(smaller.attributes[names[i]] !== CANON.stringify(bigger.attributes[names[i]]))){\r\n                            diff.attributes = diff.attributes || {};\r\n                            diff.attributes[names[i]] = bigger.attributes[names[i]];\r\n                        }\r\n                    } else {\r\n                        diff.attributes = diff.attributes || {};\r\n                        diff.attributes[names[i]] = bigger.attributes[names[i]];\r\n                    }\r\n                }\r\n            } else if(bigger.attributes){\r\n                diff.attributes = bigger.attributes;\r\n            }\r\n            //children\r\n            if(smaller.children){\r\n                diff.children = itemedElementDiff(bigger.children,smaller.children);\r\n                if(Object.keys(diff.children).length < 1){\r\n                    delete diff.children;\r\n                }\r\n            } else if(bigger.children){\r\n                diff.children = bigger.children;\r\n            }\r\n            //pointers\r\n            if(smaller.pointers){\r\n                diff.pointers = {};\r\n                names = Object.keys(bigger.pointers);\r\n                for(i=0;i<names.length;i++){\r\n                    if(smaller.pointers[names[i]]){\r\n                        diff.pointers[names[i]] = itemedElementDiff(bigger.pointers[names[i]],smaller.pointers[names[i]]);\r\n                        if(Object.keys(diff.pointers[names[i]]).length < 1){\r\n                            delete diff.pointers[names[i]];\r\n                        }\r\n                    } else {\r\n                        diff.pointers[names[i]] = bigger.pointers[names[i]];\r\n                    }\r\n                }\r\n            } else if(bigger.pointers){\r\n                diff.pointers = bigger.pointers;\r\n            }\r\n            if(Object.keys(diff.pointers).length < 1){\r\n                delete diff.pointers;\r\n            }\r\n            //aspects\r\n            if(smaller.aspects){\r\n                diff.aspects = {};\r\n                names = Object.keys(bigger.aspects);\r\n                for(i=0;i<names.length;i++){\r\n                    if(smaller.aspects[names[i]]){\r\n                        smaller.aspects[names[i]] = smaller.aspects[names[i]].sort();\r\n                        bigger.aspects[names[i]] = bigger.aspects[names[i]].sort();\r\n                        if(bigger.aspects[names[i]].length > smaller.aspects[names[i]].length){\r\n                            diff.aspects[names[i]] = bigger.aspects[names[i]].slice(smaller.aspects[names[i]].length);\r\n                        }\r\n                    } else {\r\n                        diff.aspects[names[i]] = bigger.aspects[names[i]];\r\n                    }\r\n                }\r\n            } else if(bigger.aspects){\r\n                diff.aspects = bigger.aspects;\r\n            }\r\n\r\n            if(Object.keys(diff.aspects).length < 1){\r\n                delete diff.aspects;\r\n            }\r\n            return diff;\r\n        };\r\n\r\n        core.getOwnJsonMeta = function(node){\r\n            var base = core.getBase(node),\r\n                baseMeta = base ? core.getJsonMeta(base) : {},\r\n                meta = core.getJsonMeta(node);\r\n\r\n            return getMetaObjectDiff(meta,baseMeta);\r\n        };\r\n\r\n        core.clearMetaRules = function(node){\r\n            core.deleteNode(MetaNode(node),true);\r\n        };\r\n\r\n        core.setAttributeMeta = function(node,name,value){\r\n            ASSERT(typeof value === 'object' && typeof name === 'string' && name);\r\n\r\n            core.setAttribute(MetaNode(node),name,value);\r\n        };\r\n        core.delAttributeMeta = function(node,name){\r\n            core.delAttribute(MetaNode(node),name);\r\n        };\r\n        core.getAttributeMeta = function(node,name){\r\n            return core.getAttribute(MetaNode(node),name);\r\n        };\r\n\r\n      core.getValidChildrenPaths = function(node){\r\n        return core.getMemberPaths(MetaChildrenNode(node),'items');\r\n      };\r\n        core.setChildMeta = function(node,child,min,max){\r\n            core.addMember(MetaChildrenNode(node),'items',child);\r\n            min = min || -1;\r\n            max = max || -1;\r\n            core.setMemberAttribute(MetaChildrenNode(node),'items',core.getPath(child),'min',min);\r\n            core.setMemberAttribute(MetaChildrenNode(node),'items',core.getPath(child),'max',max);\r\n        };\r\n        core.delChildMeta = function(node,childPath){\r\n            core.delMember(MetaChildrenNode(node),'items',childPath);\r\n        };\r\n        core.setChildrenMetaLimits = function(node,min,max){\r\n            if(min){\r\n                core.setAttribute(MetaChildrenNode(node),'min',min);\r\n            }\r\n            if(max){\r\n                core.setAttribute(MetaChildrenNode(node),'max',max);\r\n            }\r\n        };\r\n\r\n        core.setPointerMetaTarget = function(node,name,target,min,max){\r\n            core.addMember(_MetaPointerNode(node,name),'items',target);\r\n            min = min || -1;\r\n            core.setMemberAttribute(_MetaPointerNode(node,name),'items',core.getPath(target),'min',min);\r\n            max = max || -1;\r\n            core.setMemberAttribute(_MetaPointerNode(node,name),'items',core.getPath(target),'max',max);\r\n        };\r\n        core.delPointerMetaTarget = function(node,name,targetPath){\r\n            var metaNode = MetaPointerNode(node,name);\r\n            if(metaNode){\r\n                core.delMember(metaNode,'items',targetPath);\r\n            }\r\n        };\r\n        core.setPointerMetaLimits = function(node,name,min,max){\r\n            if(min){\r\n                core.setAttribute(_MetaPointerNode(node,name),'min',min);\r\n            }\r\n            if(max){\r\n                core.setAttribute(_MetaPointerNode(node,name),'max',max);\r\n            }\r\n        };\r\n        core.delPointerMeta = function(node,name){\r\n            core.deletePointer(MetaNode(node),name);\r\n            core.deleteNode(_MetaPointerNode(node,name));\r\n        };\r\n\r\n        core.setAspectMetaTarget = function(node,name,target){\r\n            core.addMember(_MetaAspectNode(node,name),'items',target);\r\n        };\r\n        core.delAspectMetaTarget = function(node,name,targetPath){\r\n            var metaNode = MetaAspectNode(node,name);\r\n            if(metaNode){\r\n                core.delMember(metaNode,'items',targetPath);\r\n            }\r\n        };\r\n        core.delAspectMeta = function(node,name){\r\n            core.deletePointer(MetaAspectsNode(node),name);\r\n            core.deleteNode(_MetaAspectNode(node,name));\r\n        };\r\n\r\n        //type related extra query functions\r\n        var isOnMetaSheet = function(node){\r\n            //MetaAspectSet\r\n            var sets = core.isMemberOf(node);\r\n\r\n            if(sets && sets[\"\"] && sets[\"\"].indexOf(\"MetaAspectSet\") !== -1){ //TODO this is all should be global constant values\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        core.getBaseType = function(node){\r\n            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT\r\n            while(node){\r\n                if(isOnMetaSheet(node)){\r\n                    return node;\r\n                }\r\n                node = core.getBase(node);\r\n            }\r\n            return null;\r\n        };\r\n        core.isInstanceOf = function(node,name){\r\n            //TODO this is name based query - doesn't check the node's own name\r\n            node = core.getBase(node);\r\n            while(node){\r\n                if(core.getAttribute(node,'name') === name){\r\n                    return true;\r\n                }\r\n                node = core.getBase(node);\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        return core;\r\n    };\r\n\r\n    return MetaCore;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\ndefine('core/corediff',['util/canon', 'core/tasync', 'util/assert'], function (CANON, TASYNC, ASSERT) {\r\n  \"use strict\";\r\n\r\n\r\n  function diffCore(_innerCore) {\r\n    var _core = {},\r\n      _yetToCompute = {},\r\n      _DIFF = {},\r\n      _needChecking = true,\r\n      _rounds = 0,\r\n      TODELETESTRING = \"*to*delete*\",\r\n    /*EMPTYGUID = \"00000000-0000-0000-0000-000000000000\",\r\n     EMPTYNODE = _innerCore.createNode({base: null, parent: null, guid: EMPTYGUID}),*/\r\n      toFrom = {}, //TODO should not be global\r\n      fromTo = {}, //TODO should not be global\r\n      _concat_dictionary,\r\n      _concat_result,\r\n      _diff_moves = {},\r\n      _conflict_items = [],\r\n      _conflict_parents = {},\r\n      _conflict_mine,\r\n      _conflict_theirs,\r\n      _concat_base,\r\n      _concat_extension,\r\n      _concat_base_removals,\r\n      _concat_moves,\r\n      _resolve_moves;\r\n\r\n    for (var i in _innerCore) {\r\n      _core[i] = _innerCore[i];\r\n    }\r\n\r\n    function normalize(obj) {\r\n      if (!obj) {\r\n        return obj;\r\n      }\r\n      var keys = Object.keys(obj),\r\n        i;\r\n      for (i = 0; i < keys.length; i++) {\r\n        /*if (Array.isArray(obj[keys[i]])) {\r\n          if (obj[keys[i]].length === 0) {\r\n            delete obj[keys[i]];\r\n          }*/\r\n        if(Array.isArray(obj[keys[i]])) {\r\n          //do nothing, leave the array as is\r\n        } else if(obj[keys[i]] === undefined) {\r\n          delete obj[keys[i]]; //there cannot be undefined in the object\r\n        } else if (typeof obj[keys[i]] === 'object'){\r\n          normalize(obj[keys[i]]);\r\n          if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {\r\n            delete obj[keys[i]];\r\n          }\r\n        }\r\n      }\r\n      keys = Object.keys(obj);\r\n      if(keys.length === 1){\r\n        //it only has the GUID, so the node doesn't changed at all\r\n        delete obj.guid;\r\n      }\r\n    }\r\n\r\n    function attr_diff(source, target) {\r\n      var sNames = _core.getOwnAttributeNames(source),\r\n        tNames = _core.getOwnAttributeNames(target),\r\n        i,\r\n        diff = {};\r\n\r\n      for (i = 0; i < sNames.length; i++) {\r\n        if (tNames.indexOf(sNames[i]) === -1) {\r\n          diff[sNames[i]] = TODELETESTRING;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < tNames.length; i++) {\r\n        if (_core.getAttribute(source, tNames[i]) === undefined) {\r\n          diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\r\n        } else {\r\n          if (CANON.stringify(_core.getAttribute(source, tNames[i])) !== CANON.stringify(_core.getAttribute(target, tNames[i]))) {\r\n            diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\r\n          }\r\n        }\r\n      }\r\n\r\n      return diff;\r\n    }\r\n\r\n    function reg_diff(source, target) {\r\n      var sNames = _core.getOwnRegistryNames(source),\r\n        tNames = _core.getOwnRegistryNames(target),\r\n        i,\r\n        diff = {};\r\n\r\n      for (i = 0; i < sNames.length; i++) {\r\n        if (tNames.indexOf(sNames[i]) === -1) {\r\n          diff[sNames[i]] = TODELETESTRING;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < tNames.length; i++) {\r\n        if (_core.getRegistry(source, tNames[i]) === undefined) {\r\n          diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\r\n        } else {\r\n          if (CANON.stringify(_core.getRegistry(source, tNames[i])) !== CANON.stringify(_core.getRegistry(target, tNames[i]))) {\r\n            diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\r\n          }\r\n        }\r\n      }\r\n\r\n      return diff;\r\n    }\r\n\r\n    function children_diff(source, target) {\r\n      var sRelids = _core.getChildrenRelids(source),\r\n        tRelids = _core.getChildrenRelids(target),\r\n        tHashes = _core.getChildrenHashes(target),\r\n        sHashes = _core.getChildrenHashes(source),\r\n        i,\r\n        diff = {added: [], removed: []};\r\n\r\n      for (i = 0; i < sRelids.length; i++) {\r\n        if (tRelids.indexOf(sRelids[i]) === -1) {\r\n          diff.removed.push({relid: sRelids[i], hash: sHashes[sRelids[i]]});\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < tRelids.length; i++) {\r\n        if (sRelids.indexOf(tRelids[i]) === -1) {\r\n          diff.added.push({relid: tRelids[i], hash: tHashes[tRelids[i]]});\r\n        }\r\n      }\r\n\r\n      return diff;\r\n\r\n    }\r\n\r\n    function pointer_diff(source, target) {\r\n      var getPointerData = function(node){\r\n        var data = {},\r\n        names = _core.getPointerNames(node),\r\n        i;\r\n        for(i=0;i<names.length;i++){\r\n          data[names[i]] = _core.getPointerPath(node,names[i]);\r\n        }\r\n        return data;\r\n      }, \r\n      sPointer = getPointerData(source), \r\n      tPointer = getPointerData(target);\r\n\r\n      if(CANON.stringify(sPointer) !== CANON.stringify(tPointer)){\r\n        return {source: sPointer,target:tPointer};\r\n      }\r\n      return {};\r\n    }\r\n\r\n    function set_diff(source,target){\r\n      var getSetData = function(node){\r\n        var data = {},\r\n        names,targets,keys,i,j,k;\r\n\r\n        names = _core.getSetNames(node);\r\n        for(i=0;i<names.length;i++){\r\n          data[names[i]] = {};\r\n          targets = _core.getMemberPaths(node,names[i]);\r\n          for(j=0;j<targets.length;j++){\r\n            data[names[i]][targets[j]] = {attr:{},reg:{}};\r\n            keys = _core.getMemberOwnAttributeNames(node,names[i],targets[j]);\r\n            for(k=0;k<keys.length;k++){\r\n              data[names[i]][targets[j]].attr[keys[i]] = _core.getMemberAttribute(node,names[i],targets[j],keys[i]);\r\n            }\r\n            keys = _core.getMemberRegistryNames(node,names[i],targets[j]);\r\n            for(k=0;k<keys.length;k++){\r\n              data[names[i]][targets[j]].reg[keys[k]] = _core.getMemberRegistry(node,names[i],targets[j],keys[k]);\r\n            }\r\n          }\r\n        }\r\n\r\n        return data;\r\n\r\n      },\r\n      sSet = getSetData(source),\r\n      tSet = getSetData(target);\r\n\r\n      if(CANON.stringify(sSet) !== CANON.stringify(tSet)){\r\n        return {source:sSet,target:tSet};\r\n      }\r\n      return {};\r\n    }\r\n    function _set_diff(source, target) {\r\n      var sNames = _core.getSetNames(source),\r\n        tNames = _core.getSetNames(target),\r\n        sMembers, tMembers, i, j, memberDiff, sData, tData,\r\n        diff = {},\r\n        getMemberData = function (node, setName, memberPath) {\r\n          var keys,\r\n            data = {attr: {}, reg: {}},\r\n            i;\r\n\r\n          keys = _core.getMemberOwnAttributeNames(node, setName, memberPath);\r\n          for (i = 0; i < keys.length; i++) {\r\n            data.attr[keys[i]] = _core.getMemberAttribute(node, setName, memberPath, keys[i]);\r\n          }\r\n\r\n          keys = _core.getMemberOwnRegistryNames(node, setName, memberPath);\r\n          for (i = 0; i < keys.length; i++) {\r\n            data.attr[keys[i]] = _core.getMemberRegistry(node, setName, memberPath, keys[i]);\r\n          }\r\n\r\n          return data;\r\n        };\r\n\r\n      for (i = 0; i < sNames.length; i++) {\r\n        if (tNames.indexOf(sNames[i]) === -1) {\r\n          diff[sNames[i]] = TODELETESTRING;\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < tNames.length; i++) {\r\n        if (sNames.indexOf(tNames[i]) === -1) {\r\n          sMembers = [];\r\n        } else {\r\n          sMembers = _core.getMemberPaths(source, tNames[i]);\r\n        }\r\n        tMembers = _core.getMemberPaths(target, tNames[i]);\r\n        memberDiff = {};\r\n        for (j = 0; j < sMembers.length; j++) {\r\n          if (tMembers.indexOf(sMembers[j]) === -1) {\r\n            memberDiff[sMembers[j]] = TODELETESTRING;\r\n          }\r\n        }\r\n\r\n        for (j = 0; j < tMembers.length; j++) {\r\n          sData = sMembers.indexOf(tMembers[j]) === -1 ? {} : getMemberData(source, tNames[i], tMembers[j]);\r\n          tData = getMemberData(target, tNames[i], tMembers[j]);\r\n          if (CANON.stringify(sData) !== CANON.stringify(tData)) {\r\n            memberDiff[tMembers[j]] = getMemberData(target, tNames[i], tMembers[j]);\r\n          }\r\n        }\r\n        diff[tNames[i]] = memberDiff;\r\n      }\r\n\r\n      return diff;\r\n    }\r\n    function ovr_diff(source,target){\r\n      var getOvrData = function(node){\r\n        var paths,names,i,j,\r\n        ovr = _core.getProperty(node, 'ovr') || {},\r\n        data = {},\r\n        base = _core.getPath(node);\r\n\r\n        paths = Object.keys(ovr);\r\n        for(i=0;i<paths.length;i++){\r\n          if(paths[i].indexOf('_') === -1){\r\n            data[paths[i]] = {};\r\n            names = Object.keys(ovr[paths[i]]);\r\n            for(j=0;j<names.length;j++){\r\n              if(ovr[paths[i]][names[j]] === \"/_nullptr\"){\r\n                data[paths[i]][names[j]] = null;\r\n              }else if(names[j].slice(-4) !== '-inv' && ovr[paths[i]][names[j]].indexOf('_') === -1){\r\n                data[paths[i]][names[j]] = _core.joinPaths(base,ovr[paths[i]][names[j]]);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return data;\r\n      },\r\n      sOvr = getOvrData(source),\r\n      tOvr = getOvrData(target);\r\n\r\n      if(CANON.stringify(sOvr) !== CANON.stringify(tOvr)){\r\n        return {source:sOvr,target:tOvr};\r\n      }\r\n      return {};\r\n    }\r\n\r\n    function _ovr_diff(source, target) {\r\n      // structure: path:{pointername:\"targetpath\"}\r\n      // diff structure: path:{pointername:{target:path,type:updated/removed/added}}\r\n      var i, j, paths, pNames,\r\n        diff = {},\r\n        basePath = _core.getPath(source),\r\n        sOvr = _core.getProperty(source, 'ovr') || {},\r\n        tOvr = _core.getProperty(target, 'ovr') || {};\r\n\r\n      //removals\r\n      paths = Object.keys(sOvr);\r\n      for (i = 0; i < paths.length; i++) {\r\n        if (paths[i].indexOf(\"_\") === -1) {\r\n          //we do not care about technical relations - sets are handled elsewhere\r\n          pNames = Object.keys(sOvr[paths[i]]);\r\n          for (j = 0; j < pNames.length; j++) {\r\n            if (pNames[j].slice(-4) !== \"-inv\") {\r\n              //we only care about direct pointer changes and to real nodes\r\n              if (sOvr[paths[i]][pNames[j]].indexOf(\"_\") === -1) {\r\n                if (!(tOvr[paths[i]] && tOvr[paths[i]][pNames[j]])) {\r\n                  diff[paths[i]] = diff[paths[i]] || {};\r\n                  diff[paths[i]][pNames[j]] = {target: null, type: \"removed\"};\r\n                }\r\n              }\r\n\r\n            }\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      //updates and additions\r\n      paths = Object.keys(tOvr);\r\n      for (i = 0; i < paths.length; i++) {\r\n        if (paths[i].indexOf(\"_\") === -1) {\r\n          //we do not care about technical relations - sets are handled elsewhere\r\n          pNames = Object.keys(tOvr[paths[i]]);\r\n          for (j = 0; j < pNames.length; j++) {\r\n            if (pNames[j].slice(-4) !== \"-inv\") {\r\n              //we only care about direct pointer changes and to real nodes\r\n              if (tOvr[paths[i]][pNames[j]].indexOf(\"_\") === -1) {\r\n                if (!(sOvr[paths[i]] && sOvr[paths[i]][pNames[j]])) {\r\n                  diff[paths[i]] = diff[paths[i]] || {};\r\n                  diff[paths[i]][pNames[j]] = {target: _core.joinPaths(basePath, tOvr[paths[i]][pNames[j]]), type: \"added\"};\r\n                } else if (sOvr[paths[i]][pNames[j]] !== tOvr[paths[i]][pNames[j]]) {\r\n                  diff[paths[i]] = diff[paths[i]] || {};\r\n                  diff[paths[i]][pNames[j]] = {target: _core.joinPaths(basePath, tOvr[paths[i]][pNames[j]]), type: \"updated\"};\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      return diff;\r\n    }\r\n\r\n    function meta_diff(source, target) {\r\n      var sMeta = _core.getOwnJsonMeta(source),\r\n      tMeta = _core.getOwnJsonMeta(target);\r\n      if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {\r\n        return {source: sMeta, target: tMeta};\r\n      }\r\n      return {};\r\n    }\r\n\r\n    function combineMoveIntoMetaDiff(diff){\r\n      var keys = Object.keys(diff),\r\n      i;\r\n      for(i=0;i<keys.length;i++){\r\n        if(_diff_moves[keys[i]]){\r\n          diff[_diff_moves[keys[i]]] = diff[keys[i]];\r\n          delete diff[keys[i]];\r\n        } else if(typeof diff[keys[i]] === 'object'){\r\n          combineMoveIntoMetaDiff(diff[keys[i]]);\r\n        }\r\n      }\r\n    }\r\n    function combineMoveIntoPointerDiff(diff){\r\n      var keys = Object.keys(diff),\r\n      i;\r\n      for(i=0;i<keys.length;i++){\r\n        if(_diff_moves[diff[keys[i]]]){\r\n         diff[keys[i]] = _diff_moves[diff[keys[i]]];\r\n        }\r\n      }\r\n    }\r\n\r\n    function finalizeDiff(){\r\n      finalizeMetaDiff(_DIFF);\r\n      finalizePointerDiff(_DIFF);\r\n      finalizeSetDiff(_DIFF);\r\n      normalize(_DIFF);\r\n    } \r\n    function finalizeMetaDiff(diff){\r\n      //at this point _DIFF is ready and the _diff_moves is complete...\r\n      var relids = getDiffChildrenRelids(diff),\r\n      i,sMeta,tMeta;\r\n      if(diff.meta){\r\n        sMeta = diff.meta.source || {};\r\n        tMeta = diff.meta.target || {};\r\n        combineMoveIntoMetaDiff(sMeta);\r\n        diff.meta = diffObjects(sMeta,tMeta);  \r\n      }\r\n      for(i=0;i<relids.length;i++){\r\n        finalizeMetaDiff(diff[relids[i]]);\r\n      }\r\n    }\r\n    function finalizePointerDiff(diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n      i,sPointer,tPointer;\r\n      if(diff.pointer){\r\n        sPointer = diff.pointer.source || {};\r\n        tPointer = diff.pointer.target || {};\r\n        /*if(diff.movedFrom && !sPointer.base && tPointer.base){\r\n          delete tPointer.base;\r\n        }*/\r\n        combineMoveIntoPointerDiff(sPointer);\r\n        diff.pointer = diffObjects(sPointer,tPointer);\r\n      }\r\n      for(i=0;i<relids.length;i++){\r\n        finalizePointerDiff(diff[relids[i]]);\r\n      } \r\n    }\r\n    function finalizeSetDiff(diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n      i,sSet,tSet;\r\n      if(diff.set){\r\n        sSet = diff.set.source || {};\r\n        tSet = diff.set.target || {};\r\n        combineMoveIntoMetaDiff(sSet);\r\n        diff.set = diffObjects(sSet,tSet);\r\n      }\r\n      for(i=0;i<relids.length;i++){\r\n        finalizeSetDiff(diff[relids[i]]);\r\n      }\r\n    }\r\n\r\n    function isEmptyDiff(diff) {\r\n      if (diff.removed && diff.removed.length > 0) {\r\n        return false;\r\n      }\r\n      if (diff.added && (diff.added.length > 0 || Object.keys(diff.added).length > 0)) {\r\n        return false;\r\n      }\r\n      if (diff.updated && Object.keys(diff.updated).length > 0) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function isEmptyNodeDiff(diff) {\r\n      if (\r\n        Object.keys(diff.children || {}).length > 0 ||\r\n        Object.keys(diff.attr || {}).length > 0 ||\r\n        Object.keys(diff.reg || {}).length > 0 ||\r\n        Object.keys(diff.pointer || {}).length > 0 ||\r\n        Object.keys(diff.set || {}).length > 0 ||\r\n        diff.meta\r\n        ) {\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    function getPathOfDiff(diff, path) {\r\n      var pathArray = (path || \"\").split('/'),\r\n        i;\r\n      pathArray.shift();\r\n      for (i = 0; i < pathArray.length; i++) {\r\n        diff[pathArray[i]] = diff[pathArray[i]] || {};\r\n        diff = diff[pathArray[i]];\r\n      }\r\n\r\n      return diff;\r\n    }\r\n\r\n    function extendDiffWithOvr(diff,oDiff){\r\n      var i,paths,names, j, tDiff;\r\n      //first extend sources\r\n      paths = Object.keys(oDiff.source || {});\r\n      for(i=0;i<paths.length;i++){\r\n        tDiff = getPathOfDiff(diff, paths[i]);\r\n        if(!tDiff.removed === true){\r\n          tDiff.pointer = tDiff.pointer || {source:{},target:{}};\r\n          names = Object.keys(oDiff.source[paths[i]]);\r\n          for(j=0;j<names.length;j++){\r\n            tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];\r\n          }\r\n        }\r\n      }\r\n      //then targets\r\n      paths = Object.keys(oDiff.target || {});\r\n      for(i=0;i<paths.length;i++){\r\n        tDiff = getPathOfDiff(diff, paths[i]);\r\n        if(!tDiff.removed === true){\r\n          tDiff.pointer = tDiff.pointer || {source:{},target:{}};\r\n          names = Object.keys(oDiff.target[paths[i]]);\r\n          for(j=0;j<names.length;j++){\r\n            tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function _extendDiffWithOvr(diff, oDiff) {\r\n      var i, j, keys = Object.keys(oDiff || {}),\r\n        names, tDiff, oDiffObj;\r\n      for (i = 0; i < keys.length; i++) {\r\n        tDiff = getPathOfDiff(diff, keys[i]);\r\n        if (tDiff.removed !== true) {\r\n          names = Object.keys(oDiff[keys[i]]);\r\n          for (j = 0; j < names.length; j++) {\r\n            oDiffObj = oDiff[keys[i]][names[j]];\r\n            if (oDiffObj.type === 'added' || oDiffObj.type === 'updated') {\r\n              tDiff.pointer = tDiff.pointer || {};\r\n              tDiff.pointer[names[j]] = oDiffObj.target;\r\n            } else if (!tDiff.pointer || !tDiff.pointer[names[j]]) {\r\n              tDiff.pointer = tDiff.pointer || {};\r\n              tDiff.pointer[names[j]] = TODELETESTRING;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function updateDiff(sourceRoot, targetRoot) {\r\n      var sChildrenHashes = _core.getChildrenHashes(sourceRoot),\r\n        tChildrenHAshes = _core.getChildrenHashes(targetRoot),\r\n        sRelids = Object.keys(sChildrenHashes),\r\n        tRelids = Object.keys(tChildrenHAshes),\r\n        diff = _core.nodeDiff(sourceRoot, targetRoot) || {},\r\n        oDiff = ovr_diff(sourceRoot, targetRoot),\r\n        getChild = function (childArray, relid) {\r\n          for (var i = 0; i < childArray.length; i++) {\r\n            if (_core.getRelid(childArray[i]) === relid) {\r\n              return childArray[i];\r\n            }\r\n          }\r\n          return null;\r\n        };\r\n      return TASYNC.call(function (sChildren, tChildren) {\r\n        ASSERT(sChildren.length >= 0 && tChildren.length >= 0);\r\n\r\n        var i, child, done, tDiff, guid, base;\r\n\r\n        tDiff = diff.children ? diff.children.removed || [] : [];\r\n        for (i = 0; i < tDiff.length; i++) {\r\n          diff.childrenListChanged = true;\r\n          child = getChild(sChildren, tDiff[i].relid);\r\n          if(child){\r\n            guid = _core.getGuid(child);\r\n            diff[tDiff[i].relid] = {guid: guid, removed: true, hash: _core.getHash(child)};\r\n            _yetToCompute[guid] = _yetToCompute[guid] || {};\r\n            _yetToCompute[guid].from = child;\r\n            _yetToCompute[guid].fromExpanded = false;\r\n          }\r\n        }\r\n\r\n        tDiff = diff.children ? diff.children.added || [] : [];\r\n        for (i = 0; i < tDiff.length; i++) {\r\n          diff.childrenListChanged = true;\r\n          child = getChild(tChildren, tDiff[i].relid);\r\n          if(child){\r\n            guid = _core.getGuid(child);\r\n            base =_core.getBase(child);\r\n            if(base){\r\n              base = _core.getPath(base);\r\n            }\r\n            diff[tDiff[i].relid] = {guid: guid, removed: false, hash: _core.getHash(child), pointer:{source:{},target:{base:base}}};\r\n            _yetToCompute[guid] = _yetToCompute[guid] || {};\r\n            _yetToCompute[guid].to = child;\r\n            _yetToCompute[guid].toExpanded = false;\r\n          }\r\n        }\r\n\r\n        for (i = 0; i < tChildren.length; i++) {\r\n          child = getChild(sChildren, _core.getRelid(tChildren[i]));\r\n          if (child && _core.getHash(tChildren[i]) !== _core.getHash(child)) {\r\n            done = TASYNC.call(function (cDiff, relid, d) {\r\n              diff[relid] = cDiff;\r\n              return null;\r\n            }, updateDiff(child, tChildren[i]), _core.getRelid(child), done);\r\n          }\r\n        }\r\n        return TASYNC.call(function () {\r\n          delete diff.children;\r\n          extendDiffWithOvr(diff, oDiff);\r\n          normalize(diff);\r\n          if (Object.keys(diff).length > 0) {\r\n            diff.guid = _core.getGuid(targetRoot);\r\n            diff.hash = _core.getHash(targetRoot);\r\n            diff.oGuids = gatherObstructiveGuids(targetRoot);\r\n            return TASYNC.call(function (finalDiff) {\r\n              return finalDiff;\r\n            }, fillMissingGuid(targetRoot, '', diff));\r\n          } else {\r\n            return diff;\r\n          }\r\n\r\n        }, done);\r\n      }, _core.loadChildren(sourceRoot), _core.loadChildren(targetRoot));\r\n    }\r\n\r\n    function gatherObstructiveGuids(node){\r\n      var result = {},\r\n        putParents = function(n){\r\n          while(n){\r\n            result[_core.getGuid(n)] = true;\r\n            n = _core.getParent(n);\r\n          }\r\n        };\r\n      while(node){\r\n        putParents(node);\r\n        node = _core.getBase(node);\r\n      }\r\n      return result;\r\n    }\r\n    function fillMissingGuid(root, path, diff) {\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i,\r\n        done;\r\n\r\n      for (i = 0; i < relids.length; i++) {\r\n        done = TASYNC.call(function (cDiff, relid) {\r\n          diff[relid] = cDiff;\r\n          return null;\r\n        }, fillMissingGuid(root, path + '/' + relids[i], diff[relids[i]]), relids[i]);\r\n      }\r\n      return TASYNC.call(function () {\r\n        if (diff.guid) {\r\n          return diff;\r\n        } else {\r\n          return TASYNC.call(function (child) {\r\n            diff.guid = _core.getGuid(child);\r\n            diff.hash = _core.getHash(child);\r\n            diff.oGuids = gatherObstructiveGuids(child);\r\n            return diff;\r\n          }, _core.loadByPath(root, path));\r\n        }\r\n      }, done);\r\n    }\r\n\r\n    function expandDiff(root, isDeleted) {\r\n      var diff = {\r\n        guid: _core.getGuid(root),\r\n        hash: _core.getHash(root),\r\n        removed: isDeleted === true\r\n      };\r\n      return TASYNC.call(function (children) {\r\n        var guid;\r\n        for (var i = 0; i < children.length; i++) {\r\n          guid = _core.getGuid(children[i]);\r\n          diff[_core.getRelid(children[i])] = {\r\n            guid: guid,\r\n            hash: _core.getHash(children[i]),\r\n            removed: isDeleted === true\r\n          };\r\n\r\n          if (isDeleted) {\r\n            _yetToCompute[guid] = _yetToCompute[guid] || {};\r\n            _yetToCompute[guid].from = children[i];\r\n            _yetToCompute[guid].fromExpanded = false;\r\n          } else {\r\n            _yetToCompute[guid] = _yetToCompute[guid] || {};\r\n            _yetToCompute[guid].to = children[i];\r\n            _yetToCompute[guid].toExpanded = false;\r\n          }\r\n        }\r\n        return diff;\r\n      }, _core.loadChildren(root));\r\n    }\r\n\r\n    function insertIntoDiff(path, diff) {\r\n      var pathArray = path.split('/'),\r\n        relid = pathArray.pop(),\r\n        sDiff = _DIFF,\r\n        i;\r\n      pathArray.shift();\r\n      for (i = 0; i < pathArray.length; i++) {\r\n        sDiff = sDiff[pathArray[i]];\r\n      }\r\n      //sDiff[relid] = diff;\r\n      sDiff[relid] = mergeObjects(sDiff[relid], diff);\r\n    }\r\n\r\n    function diffObjects(source,target) {\r\n      var diff = {},\r\n        sKeys = Object.keys(source),\r\n        tKeys = Object.keys(target),\r\n        tDiff,i;\r\n      for (i = 0; i < sKeys.length; i++) {\r\n        if(tKeys.indexOf(sKeys[i]) === -1){\r\n          diff[sKeys[i]] = TODELETESTRING;\r\n        }\r\n      }\r\n      for (i = 0; i < tKeys.length; i++) {\r\n        if (sKeys.indexOf(tKeys[i]) === -1) {\r\n          diff[tKeys[i]] = target[tKeys[i]];\r\n        } else {\r\n          if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\r\n            typeof target[tKeys[i]] === 'object' &&\r\n            (target[tKeys[i]] !== null && source[tKeys[i]] !== null)) {\r\n            tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);\r\n            if(Object.keys(tDiff).length > 0){\r\n              diff[tKeys[i]] = tDiff;\r\n            }\r\n          } else if(source[tKeys[i]] !== target[tKeys[i]]) {\r\n            diff[tKeys[i]] = target[tKeys[i]];\r\n          }\r\n        }\r\n      }\r\n      return diff;\r\n    }\r\n\r\n    function mergeObjects(source, target) {\r\n      var merged = {},\r\n        sKeys = Object.keys(source),\r\n        tKeys = Object.keys(target),\r\n        i;\r\n      for (i = 0; i < sKeys.length; i++) {\r\n        merged[sKeys[i]] = source[sKeys[i]];\r\n      }\r\n      for (i = 0; i < tKeys.length; i++) {\r\n        if (sKeys.indexOf(tKeys[i]) === -1) {\r\n          merged[tKeys[i]] = target[tKeys[i]];\r\n        } else {\r\n          if (typeof target[tKeys[i]] === typeof source[tKeys[i]] && typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {\r\n            merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);\r\n          } else {\r\n            merged[tKeys[i]] = target[tKeys[i]];\r\n          }\r\n        }\r\n      }\r\n\r\n      return merged;\r\n    }\r\n\r\n    function removePathFromDiff(diff,path){\r\n      var relId,i;\r\n      if(path === ''){\r\n        diff = null;\r\n      } else {\r\n        path = path.split('/');\r\n        path.shift();\r\n        relId = path.pop();\r\n        for(i=0;i<path.length;i++){\r\n          diff = diff[path[i]];\r\n        }\r\n        delete diff[relId];\r\n      }\r\n    }\r\n    function shrinkDiff(rootDiff){\r\n      var _shrink = function(diff){\r\n        if(diff){\r\n          var keys = getDiffChildrenRelids(diff),\r\n            i;\r\n          if(typeof diff.movedFrom === 'string'){\r\n            removePathFromDiff(rootDiff,diff.movedFrom);\r\n          }\r\n\r\n          if(diff.removed !== false || typeof diff.movedFrom === 'string'){\r\n            delete diff.hash;\r\n          }\r\n\r\n          if(diff.removed === true){\r\n            for(i=0;i<keys.length;i++){\r\n              delete diff[keys[i]];\r\n            }\r\n          } else {\r\n\r\n            for(i=0;i<keys.length;i++){\r\n              _shrink(diff[keys[i]]);\r\n            }\r\n          }\r\n        }\r\n      };\r\n      _shrink(rootDiff,false);\r\n    }\r\n    function checkRound() {\r\n      var guids = Object.keys(_yetToCompute),\r\n        done, ytc,\r\n        i;\r\n      if (_needChecking !== true || guids.length < 1) {\r\n        shrinkDiff(_DIFF);\r\n        finalizeDiff();\r\n        return _DIFF;\r\n      }\r\n      _needChecking = false;\r\n      for (i = 0; i < guids.length; i++) {\r\n        ytc = _yetToCompute[guids[i]];\r\n        if (ytc.from && ytc.to) {\r\n          //move\r\n          _needChecking = true;\r\n          delete _yetToCompute[guids[i]];\r\n          done = TASYNC.call(function (mDiff, info) {\r\n            mDiff.guid = _core.getGuid(info.from);\r\n            mDiff.movedFrom = _core.getPath(info.from);\r\n            mDiff.ooGuids = gatherObstructiveGuids(info.from);\r\n            _diff_moves[_core.getPath(info.from)] = _core.getPath(info.to);\r\n            insertAtPath(_DIFF,_core.getPath(info.to),mDiff);\r\n            return null;\r\n          }, updateDiff(ytc.from, ytc.to), ytc);\r\n        } else {\r\n          if (ytc.from && ytc.fromExpanded === false) {\r\n            //expand from\r\n            ytc.fromExpanded = true;\r\n            _needChecking = true;\r\n            done = TASYNC.call(function (mDiff, info) {\r\n              mDiff.hash = _core.getHash(info.from);\r\n              mDiff.removed = true;\r\n              insertIntoDiff(_core.getPath(info.from), mDiff);\r\n              return null;\r\n            }, expandDiff(ytc.from, true), ytc);\r\n          } else if (ytc.to && ytc.toExpanded === false) {\r\n            //expand to\r\n            ytc.toExpanded = true;\r\n            _needChecking = true;\r\n            done = TASYNC.call(function (mDiff, info) {\r\n              if(!mDiff.hash){\r\n                mDiff.hash = _core.getHash(info.to);\r\n              }\r\n              mDiff.removed = false;\r\n              insertIntoDiff(_core.getPath(info.to), mDiff);\r\n              return null;\r\n            }, expandDiff(ytc.to, false), ytc);\r\n          }\r\n        }\r\n      }\r\n      return TASYNC.call(function () {\r\n        return checkRound();\r\n      }, done);\r\n    }\r\n\r\n    _core.nodeDiff = function (source, target) {\r\n      var diff = {\r\n        children: children_diff(source, target),\r\n        attr: attr_diff(source, target),\r\n        reg: reg_diff(source, target),\r\n        pointer: pointer_diff(source, target),\r\n        set: set_diff(source, target),\r\n        meta: meta_diff(source, target)\r\n      };\r\n\r\n      normalize(diff);\r\n      return isEmptyNodeDiff(diff) ? null : diff;\r\n    };\r\n\r\n    _core.generateTreeDiff = function (sRoot, tRoot) {\r\n      _yetToCompute = {};\r\n      _DIFF = {};\r\n      _diff_moves = {};\r\n      _needChecking = true;\r\n      _rounds = 0;\r\n      return TASYNC.call(function (d) {\r\n        _DIFF = d;\r\n        return checkRound();\r\n      }, updateDiff(sRoot, tRoot));\r\n    };\r\n\r\n    _core.generateLightTreeDiff = function (sRoot, tRoot) {\r\n      return updateDiff(sRoot, tRoot);\r\n    };\r\n\r\n    function getDiffChildrenRelids(diff) {\r\n      var keys = Object.keys(diff),\r\n        i,\r\n        filteredKeys = [],\r\n        forbiddenWords = {\r\n          guid: true,\r\n          hash: true,\r\n          attr: true,\r\n          reg: true,\r\n          pointer: true,\r\n          set: true,\r\n          meta: true,\r\n          removed: true,\r\n          movedFrom: true,\r\n          childrenListChanged: true,\r\n          oGuids: true,\r\n          ooGuids: true,\r\n          min: true,\r\n          max: true\r\n        };\r\n      for (i = 0; i < keys.length; i++) {\r\n        if (!forbiddenWords[keys[i]]) {\r\n          filteredKeys.push(keys[i]);\r\n        }\r\n      }\r\n      return filteredKeys;\r\n    }\r\n\r\n    function getMoveSources(diff, path, toFrom, fromTo) {\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i, paths = [];\r\n\r\n      for (i = 0; i < relids.length; i++) {\r\n        getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);\r\n      }\r\n\r\n      if (typeof diff.movedFrom === 'string') {\r\n        toFrom[path] = diff.movedFrom;\r\n        fromTo[diff.movedFrom] = path;\r\n      }\r\n    }\r\n\r\n    function getAncestor(node,path){\r\n      var ownPath = _core.getPath(node),\r\n        ancestorPath='',\r\n        i;\r\n      path=path.split('/');\r\n      ownPath=ownPath.split('/');\r\n      ownPath.shift();\r\n      path.shift();\r\n      for(i=0;i<ownPath.length;i++){\r\n        if(ownPath[i] === path[i]){\r\n          ancestorPath= ancestorPath+'/'+ownPath[i];\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      ownPath = _core.getPath(node);\r\n      while(ownPath !== ancestorPath){\r\n        node = _core.getParent(node);\r\n        ownPath = _core.getPath(node);\r\n      }\r\n      return node;\r\n    }\r\n    function setBaseOfNewNode(node,relid,basePath){\r\n      //TODO this is a kind of low level hack so maybe there should be another way to do this\r\n      var ancestor = getAncestor(node,basePath),\r\n        sourcePath = _core.getPath(node).substr(_core.getPath(ancestor).length),\r\n        targetPath = basePath.substr(_core.getPath(ancestor).length);\r\n      sourcePath = sourcePath+'/'+relid;\r\n      _innerCore.overlayInsert(_core.getChild(ancestor,'ovr'),sourcePath,'base',targetPath);\r\n    }\r\n    function makeInitialContainmentChanges(node,diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i,done,child,moved;\r\n\r\n      for(i=0;i<relids.length;i++){\r\n        moved = false;\r\n        if(diff[relids[i]].movedFrom){\r\n          //moved node\r\n          moved = true;\r\n          child = _core.loadByPath(_core.getRoot(node),diff[relids[i]].movedFrom);\r\n        } else if(diff[relids[i]].removed === false){\r\n          //added node\r\n          //first we hack the pointer, then we create the node\r\n          if(diff[relids[i]].pointer && diff[relids[i]].pointer.base){\r\n            //we can set base if the node has one, otherwise it is 'inheritance internal' node\r\n            setBaseOfNewNode(node,relids[i],diff[relids[i]].pointer.base);\r\n          }\r\n          if(diff[relids[i]].hash){\r\n            _core.setProperty(node,relids[i],diff[relids[i]].hash);\r\n            child = _core.loadChild(node,relids[i]);\r\n          } else {\r\n            child = _core.getChild(node,relids[i]);\r\n            _core.setHashed(child,true);\r\n          }\r\n        } else {\r\n          //simple node\r\n          child = _core.loadChild(node,relids[i]);\r\n        }\r\n\r\n        done = TASYNC.call(function(n,di,p,m,d){\r\n          if(m === true){\r\n            n = _core.moveNode(n,p);\r\n          }\r\n          return makeInitialContainmentChanges(n,di);\r\n        },child,diff[relids[i]],node,moved,done);\r\n      }\r\n\r\n      TASYNC.call(function(d){\r\n        return null;\r\n      },done);\r\n    }\r\n    function createNewNodes(node, diff) {\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i,\r\n        done;\r\n\r\n      for (i = 0; i < relids.length; i++) {\r\n        if (diff[relids[i]].removed === false && !diff[relids[i]].movedFrom) {\r\n          //we have to create the child with the exact hash and then recursively call the function for it\r\n          /*if(!(node.data[relids[i]] && node.data[relids[i]] === diff[relids[i]].hash)){\r\n            //if it is a child of a new node we probably do not have to create it again...\r\n            if(diff[relids[i]].hash){\r\n              _core.setProperty(node,relids[i],diff[relids[i]].hash);\r\n            } else {\r\n              //create an empty child\r\n              var child = _core.getChild(node,relids[i]);\r\n              _core.setHashed(child,true);\r\n            }\r\n          }*/\r\n          if(diff[relids[i]].hash){\r\n            _core.setProperty(node,relids[i],diff[relids[i]].hash);\r\n          } else {\r\n            var child = _core.getChild(node,relids[i]);\r\n            _core.setHashed(child,true);\r\n          }\r\n          if(diff[relids[i]].pointer && diff[relids[i]].pointer.base){\r\n            //we can set base if the node has one, otherwise it is 'inheritance internal' node\r\n            setBaseOfNewNode(node,relids[i],diff[relids[i]].pointer.base);\r\n          }\r\n        }\r\n\r\n        done = TASYNC.call(function (a, b, c) {\r\n          return createNewNodes(a, b);\r\n        }, _core.loadChild(node, relids[i]), diff[relids[i]], done);\r\n\r\n      }\r\n\r\n      return TASYNC.call(function (d) {\r\n        return null;\r\n      },done);\r\n    }\r\n\r\n    function getMovedNode(root, from, to) {\r\n      ASSERT(typeof from === 'string' && typeof to === 'string' && to !== '');\r\n      var parentPath = to.substring(0, to.lastIndexOf('/')),\r\n        parent = _core.loadByPath(root, fromTo[parentPath] || parentPath),\r\n        old = _core.loadByPath(root, from);\r\n\r\n      //clear the directories\r\n      delete fromTo[from];\r\n      delete toFrom[to];\r\n\r\n      return TASYNC.call(function (p, o) {\r\n        return _core.moveNode(o, p);\r\n      }, parent, old);\r\n\r\n    }\r\n\r\n    function applyNodeChange(root, path, nodeDiff) {\r\n      //check for move\r\n      var node;\r\n      node = _core.loadByPath(root, path);\r\n\r\n      TASYNC.call(function (n) {\r\n        var done,\r\n          relids = getDiffChildrenRelids(nodeDiff),\r\n          i;\r\n        if (nodeDiff.removed === true) {\r\n          _core.deleteNode(n);\r\n          return;\r\n        }\r\n        applyAttributeChanges(n, nodeDiff.attr || {});\r\n        applyRegistryChanges(n, nodeDiff.reg || {});\r\n        done = applyPointerChanges(n, nodeDiff.pointer || {});\r\n        done = TASYNC.call(applySetChanges,n, nodeDiff.set || {},done);\r\n        if(nodeDiff.meta){\r\n          delete nodeDiff.meta.empty;\r\n          done = TASYNC.call(applyMetaChanges,n, nodeDiff.meta,done);\r\n        }\r\n        for (i = 0; i < relids.length; i++) {\r\n          done = TASYNC.call(function (d, d2) {\r\n            return null;\r\n          }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);\r\n        }\r\n        TASYNC.call(function (d) {\r\n          return done;\r\n        }, done);\r\n      }, node);\r\n    }\r\n\r\n    function applyAttributeChanges(node, attrDiff) {\r\n      var i, keys;\r\n      keys = Object.keys(attrDiff);\r\n      for (i = 0; i < keys.length; i++) {\r\n        if (attrDiff[keys[i]] === TODELETESTRING) {\r\n          _core.delAttribute(node, keys[i]);\r\n        } else {\r\n          _core.setAttribute(node, keys[i], attrDiff[keys[i]]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function applyRegistryChanges(node, regDiff) {\r\n      var i, keys;\r\n      keys = Object.keys(regDiff);\r\n      for (i = 0; i < keys.length; i++) {\r\n        if (regDiff[keys[i]] === TODELETESTRING) {\r\n          _core.delRegistry(node, keys[i]);\r\n        } else {\r\n          _core.setRegistry(node, keys[i], regDiff[keys[i]]);\r\n        }\r\n      }\r\n    }\r\n\r\n    function setPointer(node, name, target) {\r\n      var targetNode;\r\n      if(target === null){\r\n        targetNode = null;\r\n      } else {\r\n        if(fromTo[target]){\r\n          target = fromTo[target];\r\n        }\r\n        targetNode = _core.loadByPath(_core.getRoot(node),target);\r\n      }\r\n      return TASYNC.call(function (t) {\r\n        //TODO watch if handling of base changes!!!\r\n        _core.setPointer(node, name, t);\r\n        return;\r\n      }, targetNode);\r\n    }\r\n\r\n    function applyPointerChanges(node, pointerDiff) {\r\n      var done,\r\n        keys = Object.keys(pointerDiff),\r\n        i;\r\n      for (i = 0; i < keys.length; i++) {\r\n        if (pointerDiff[keys[i]] === TODELETESTRING) {\r\n          _core.deletePointer(node, keys[i]);\r\n        } else {\r\n          done = setPointer(node, keys[i], pointerDiff[keys[i]]);\r\n        }\r\n      }\r\n\r\n      return TASYNC.call(function (d) {\r\n        return null;\r\n      }, done);\r\n\r\n    }\r\n\r\n    function addMember(node, name, target, data) {\r\n      var memberAttrSetting = function (diff) {\r\n          var keys = _core.getMemberOwnAttributeNames(node, name, target),\r\n            i;\r\n          for (i = 0; i < keys.length; i++) {\r\n            _core.delMemberAttribute(node, name, target, keys[i]);\r\n          }\r\n\r\n          keys = Object.keys(diff);\r\n          for (i = 0; i < keys.length; i++) {\r\n            _core.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);\r\n          }\r\n        },\r\n        memberRegSetting = function (diff) {\r\n          var keys = _core.getMemberOwnRegistryNames(node, name, target),\r\n            i;\r\n          for (i = 0; i < keys.length; i++) {\r\n            _core.delMemberRegistry(node, name, target, keys[i]);\r\n          }\r\n\r\n          keys = Object.keys(diff);\r\n          for (i = 0; i < keys.length; i++) {\r\n            _core.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);\r\n          }\r\n        };\r\n      return TASYNC.call(function (t) {\r\n        _core.addMember(node, name, t);\r\n        memberAttrSetting(data.attr || {});\r\n        memberRegSetting(data.reg || {});\r\n        return;\r\n      }, _core.loadByPath(_core.getRoot(node), target));\r\n    }\r\n\r\n    function applySetChanges(node, setDiff) {\r\n      var done,\r\n        setNames = Object.keys(setDiff),\r\n        elements, i, j;\r\n      for (i = 0; i < setNames.length; i++) {\r\n        if (setDiff[setNames[i]] === TODELETESTRING) {\r\n          _core.deleteSet(node, setNames[i]);\r\n        } else {\r\n          elements = Object.keys(setDiff[setNames[i]]);\r\n          for (j = 0; j < elements.length; j++) {\r\n            if (setDiff[setNames[i]][elements[j]] === TODELETESTRING) {\r\n              _core.delMember(node, setNames[i], elements[j]);\r\n            } else {\r\n              done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]]);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return TASYNC.call(function (d) {\r\n        return null;\r\n      }, done);\r\n\r\n    }\r\n\r\n    function applyMetaAttributes(node,metaAttrDiff){\r\n      var i,keys,newValue;\r\n      if(metaAttrDiff === TODELETESTRING){\r\n        //we should delete all MetaAttributes\r\n        keys = _core.getValidAttributeNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n          _core.delAttributeMeta(node,keys[i]);\r\n        }\r\n      } else {\r\n        keys = Object.keys(metaAttrDiff);\r\n        for(i=0;i<keys.length;i++){\r\n          if(metaAttrDiff[keys[i]] === TODELETESTRING){\r\n            _core.delAttributeMeta(node,keys[i]);\r\n          } else {\r\n            newValue = jsonConcat(_core.getAttributeMeta(node,keys[i]) || {},metaAttrDiff[keys[i]]);\r\n            _core.setAttributeMeta(node,keys[i],newValue);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function applyMetaConstraints(node,metaConDiff){\r\n      var keys,i;\r\n      if(metaConDiff === TODELETESTRING){\r\n        //remove all constraints\r\n        keys = _core.getConstraintNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n          _core.delConstraint(node,keys[i]);\r\n        }\r\n      } else {\r\n        keys = Object.keys(metaConDiff);\r\n        for(i=0;i<keys.length;i++){\r\n          if(metaConDiff[keys[i]] === TODELETESTRING){\r\n            _core.delConstraint(node,keys[i]);\r\n          } else {\r\n            _core.setConstraint(node,keys[i],jsonConcat(_core.getConstraint(node,keys[i]) || {},metaConDiff[keys[i]]));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function applyMetaChildren(node,metaChildrenDiff){\r\n      var keys, i,done,\r\n        setChild = function(target,data,d){\r\n          _core.setChildMeta(node,target,data.min,data.max);\r\n        };\r\n      if(metaChildrenDiff === TODELETESTRING){\r\n        //remove all valid child\r\n        keys = _core.getValidChildrenPaths(node);\r\n        for(i=0;i<keys.length;i++){\r\n          _core.delChildMeta(node,keys[i]);\r\n        }\r\n      } else {\r\n        _core.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);\r\n        delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way\r\n        delete metaChildrenDiff.min;\r\n        keys = Object.keys(metaChildrenDiff);\r\n        for(i=0;i<keys.length;i++){\r\n          if(metaChildrenDiff[keys[i]] === TODELETESTRING){\r\n            _core.delChildMeta(node,keys[i]);\r\n          } else {\r\n            done = TASYNC.call(setChild,_core.loadByPath(_core.getRoot(node),keys[i]),metaChildrenDiff[keys[i]],done);\r\n          }\r\n        }\r\n      }\r\n\r\n      TASYNC.call(function(d){\r\n        return null;\r\n      },done);\r\n    }\r\n\r\n    function applyMetaPointers(node,metaPointerDiff){\r\n      var names,targets, i, j,done,\r\n        setPointer = function(name,target,data,d){\r\n          _core.setPointerMetaTarget(node,name,target,data.min,data.max);\r\n        };\r\n      if(metaPointerDiff === TODELETESTRING){\r\n        //remove all pointers,sets and their targets\r\n        names = _core.getValidPointerNames(node);\r\n        for(i=0;i<names.length;i++){\r\n          _core.delPointerMeta(node,names[i]);\r\n        }\r\n\r\n        names = _core.getValidSetNames(node);\r\n        for(i=0;i<names.length;i++){\r\n          _core.delPointerMeta(node,names[i]);\r\n        }\r\n        return;\r\n      }\r\n\r\n      names = Object.keys(metaPointerDiff);\r\n      for(i=0;i<names.length;i++){\r\n        if(metaPointerDiff[names[i]] === TODELETESTRING){\r\n          _core.delPointerMeta(node,names[i]);\r\n        } else {\r\n          _core.setPointerMetaLimits(node,names[i],metaPointerDiff[names[i]].min,metaPointerDiff[names[i]].max);\r\n          delete metaPointerDiff[names[i]].max; //TODO we do not need it anymore, but maybe there is a better way\r\n          delete metaPointerDiff[names[i]].min;\r\n          targets = Object.keys(metaPointerDiff[names[i]]);\r\n          for(j=0;j<targets.length;j++){\r\n            if(metaPointerDiff[names[i]][targets[j]] === TODELETESTRING){\r\n              _core.delPointerMetaTarget(node,names[i],targets[j]);\r\n            } else {\r\n              done = TASYNC.call(setPointer,names[i],_core.loadByPath(_core.getRoot(node),targets[j]),metaPointerDiff[names[i]][targets[j]],done);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      TASYNC.call(function(d){\r\n        return null;\r\n      },done);\r\n    }\r\n\r\n    function applyMetaAspects(node,metaAspectsDiff){\r\n      var names,targets, i, j,done,\r\n        setAspect = function(name,target,d){\r\n          _core.setAspectMetaTarget(node,name,target);\r\n        };\r\n      if(metaAspectsDiff === TODELETESTRING){\r\n        //remove all aspects\r\n        names = _core.getValidAspectNames(node);\r\n        for(i=0;i<names.length;i++){\r\n          _core.delAspectMeta(node,names[i]);\r\n        }\r\n        return;\r\n      }\r\n\r\n      names = Object.keys(metaAspectsDiff);\r\n      for(i=0;i<names.length;i++){\r\n        if(metaAspectsDiff[names[i]] === TODELETESTRING){\r\n          _core.delAspectMeta(node,names[i]);\r\n        } else {\r\n          targets = Object.keys(metaAspectsDiff[names[i]]);\r\n          for(j=0;j<targets.length;j++){\r\n            if(metaAspectsDiff[names[i]][targets[j]] === TODELETESTRING){\r\n              _core.delAspectMetaTarget(node,names[i],targets[j]);\r\n            } else {\r\n              done = TASYNC.call(setAspect,names[i],_core.loadByPath(_core.getRoot(node),targets[j]),done);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      TASYNC.call(function(d){\r\n        return null;\r\n      },done);\r\n    }\r\n\r\n    function applyMetaChanges(node, metaDiff) {\r\n      var done;\r\n      applyMetaAttributes(node,metaDiff.attributes || TODELETESTRING);\r\n      applyMetaConstraints(node,metaDiff.constraints || TODELETESTRING);\r\n      done = applyMetaChildren(node,metaDiff.children || TODELETESTRING);\r\n      done = TASYNC.call(applyMetaPointers,node,metaDiff.pointers || TODELETESTRING,done);\r\n      done = TASYNC.call(applyMetaAspects,node,metaDiff.aspects || TODELETESTRING,done);\r\n\r\n      TASYNC.call(function(d){\r\n        return null;\r\n      },done);\r\n    }\r\n\r\n    _core.applyTreeDiff = function (root, diff) {\r\n      var done;\r\n\r\n      toFrom = {};\r\n      fromTo = {};\r\n      getMoveSources(diff, '', toFrom, fromTo);\r\n\r\n      done = makeInitialContainmentChanges(root,diff);\r\n      return TASYNC.call(function (d) {\r\n        return applyNodeChange(root, '', diff);\r\n      }, done);\r\n    };\r\n\r\n\r\n    //concat diffs is needed to make 3-way merge\r\n    function getDiffTreeDictionray(treeDiff){\r\n      var dictionary = {pathToGuid:{},guidToPath:{}},\r\n        addElement = function(path,diff){\r\n          var keys = getDiffChildrenRelids(diff),\r\n            i;\r\n          for(i=0;i<keys.length;i++){\r\n            addElement(path+'/'+keys[i],diff[keys[i]]);\r\n          }\r\n          if(diff.guid){\r\n            dictionary.pathToGuid[path] = diff.guid;\r\n            if(!dictionary.guidToPath[diff.guid] || diff.movedFrom){\r\n              dictionary.guidToPath[diff.guid] = path;\r\n            }\r\n          }\r\n        };\r\n\r\n      addElement('',treeDiff);\r\n      return dictionary;\r\n    }\r\n\r\n    function _getNodeByGuid(diff,guid){\r\n      var path = _concat_dictionary.guidToPath[guid],\r\n        object = diff,\r\n        i;\r\n      if(typeof path === 'string'){\r\n        if(path === ''){\r\n          return diff;\r\n        }\r\n\r\n        path = path.split('/');\r\n        path.shift();\r\n        for(i=0;i<path.length;i++){\r\n          object = object[path[i]];\r\n        }\r\n        return object;\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    function getNodeByGuid(diff,guid){\r\n      var relids, i,temp;\r\n      if(diff.guid === guid){\r\n        return diff;\r\n      }\r\n\r\n      relids = getDiffChildrenRelids(diff);\r\n      for(i=0;i<relids.length;i++){\r\n        temp = getNodeByGuid(diff[relids[i]],guid);\r\n        if(temp){\r\n          return temp;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    function insertAtPath(diff,path,object){\r\n      ASSERT(typeof path === 'string');\r\n      var i,base,relid,nodepath;\r\n      if(path === ''){\r\n        _concat_result = JSON.parse(JSON.stringify(object));\r\n        return;\r\n      }\r\n      nodepath = path.match(/\\/\\/.*\\/\\//) || [];\r\n      nodepath = nodepath[0] || \"there is no nodepath in the path\";\r\n      path = path.replace(nodepath,\"/*nodepath*/\");\r\n      nodepath = nodepath.replace(/\\/\\//g,\"/\");\r\n      nodepath = nodepath.slice(0,-1);\r\n      path = path.split('/');\r\n      path.shift();\r\n      if(path.indexOf(\"*nodepath*\") !== -1){\r\n        path[path.indexOf(\"*nodepath*\")] = nodepath;\r\n      }\r\n      relid = path.pop();\r\n      base = diff;\r\n      for(i=0;i<path.length;i++){\r\n        base[path[i]] = base[path[i]] || {};\r\n        base = base[path[i]];\r\n      }\r\n      base[relid] = JSON.parse(JSON.stringify(object));\r\n      return;\r\n    }\r\n    function changeMovedPaths(singleNode){\r\n      var keys,i;\r\n      keys = Object.keys(singleNode);\r\n      for(i=0;i<keys.length;i++){\r\n        if(_concat_moves.fromTo[keys[i]]){\r\n          singleNode[_concat_moves.fromTo[keys[i]]] = singleNode[keys[i]];\r\n          delete singleNode[keys[i]];\r\n          if(typeof singleNode[_concat_moves.fromTo[keys[i]]] === 'object' && singleNode[_concat_moves.fromTo[keys[i]]] !== null){\r\n            changeMovedPaths(singleNode[_concat_moves.fromTo[keys[i]]]);\r\n          }\r\n        } else {\r\n          if(typeof singleNode[keys[i]] === 'string' && keys[i] !== 'movedFrom' && _concat_moves.fromTo[singleNode[keys[i]]]){\r\n            singleNode[keys[i]] = _concat_moves.fromTo[keys[i]];\r\n          }\r\n\r\n          if(typeof singleNode[keys[i]] === 'object' && singleNode[keys[i]] !== null){\r\n            changeMovedPaths(singleNode[keys[i]]);\r\n          }\r\n        }\r\n\r\n      }\r\n      if(typeof singleNode === 'object' && singleNode !== null){\r\n        keys = Object.keys(singleNode);\r\n        for(i=0;i<keys.length;i++){\r\n          if(_concat_moves.fromTo[keys[i]]){\r\n            singleNode[_concat_moves.fromTo[keys[i]]] = singleNode[keys[i]];\r\n            delete singleNode[keys[i]];\r\n          }\r\n        }\r\n      } else if(typeof singleNode === 'string') {\r\n\r\n      }\r\n\r\n    }\r\n    function getSingleNode(node){\r\n      //removes the children from the node\r\n      var result = JSON.parse(JSON.stringify(node)),\r\n        keys = getDiffChildrenRelids(result),\r\n        i;\r\n      for(i=0;i<keys.length;i++){\r\n        delete result[keys[i]];\r\n      }\r\n      //changeMovedPaths(result);\r\n      return result;\r\n    }\r\n    function jsonConcat(base,extension){\r\n      var baseKeys = Object.keys(base),\r\n        extKeys = Object.keys(extension),\r\n        concat = JSON.parse(JSON.stringify(base)),\r\n        i;\r\n      for(i=0;i<extKeys.length;i++){\r\n        if(baseKeys.indexOf(extKeys[i]) === -1){\r\n          concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\r\n        } else {\r\n          if(typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object'){\r\n            concat[extKeys[i]] = jsonConcat(base[extKeys[i]],extension[extKeys[i]]);\r\n          } else { //either from value to object or object from value we go with the extension\r\n            concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\r\n          }\r\n        }\r\n      }\r\n      return concat;\r\n    }\r\n\r\n\r\n\r\n    function getConflictByGuid(conflict,guid){\r\n      var relids,i,result;\r\n      if(conflict.guid === guid){\r\n        return conflict;\r\n      }\r\n      relids = getDiffChildrenRelids(conflict);\r\n      for(i=0;i<relids.length;i++){\r\n        result = getConflictByGuid(conflict[relids[i]],guid);\r\n        if(result){\r\n          return result;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    function getPathByGuid(conflict,guid,path){\r\n      var relids,i,result;\r\n      if(conflict.guid === guid){\r\n        return path;\r\n      }\r\n      relids = getDiffChildrenRelids(conflict);\r\n      for(i=0;i<relids.length;i++){\r\n        result = getPathByGuid(conflict[relids[i]],guid,path+'/'+relids[i]);\r\n        if(result){\r\n          return result;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n    function removedParentGuid(diff,path){\r\n      var i;\r\n      path = (path || \"\").split('/');\r\n      path.shift();\r\n      for (i = 0; i < path.length; i++) {\r\n        if(diff.removed === true){\r\n          return diff.guid;\r\n        }\r\n        if(diff[path[i]]){\r\n          diff = diff[path[i]]\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n      return diff.removed === true ? diff.guid : null;\r\n    }\r\n\r\n    function getGuidsOfDiff(diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i,\r\n        result = [diff.guid];\r\n      for(i=0;i<relids.length;i++){\r\n        result = result.concat(getGuidsOfDiff(diff[relids[i]]));\r\n      }\r\n      return result;\r\n    }\r\n\r\n    function applyToPath(diff,path,value){\r\n      var i,finalPath,keys;\r\n      path = (path || \"\").split('/');\r\n      path.shift();\r\n      finalPath = path.pop();\r\n      for(i=0;i<path.length;i++){\r\n        if(!diff[path[i]]){\r\n          diff[path[i]] = {};\r\n        }\r\n        diff = diff[path[i]];\r\n      }\r\n\r\n      if(typeof value === 'object'){\r\n        keys = Object.keys(value);\r\n        for(i=0;i<keys.length;i++){\r\n          diff[finalPath][keys[i]] = value[keys[i]];\r\n        }\r\n      } else {\r\n        diff[finalPath] = value;\r\n      }\r\n    }\r\n    /*function applyResolutionItem(diff,item){\r\n\r\n      //let's start with the easy ones\r\n      if(item.mine.path === item.theirs.path){\r\n        //we just simply apply it over our own diff\r\n        applyToPath(diff,item.theirs.path,item.theirs.value);\r\n      } else {\r\n        var currentPath = getPathByGuid(diff,item.guid,'');\r\n        if(item.mine.path.indexOf(currentPath) === 0){\r\n          //not yet moved so we move right now\r\n          insertAtPath(diff,item.theirs.path,getNodeByGuid(diff,item.guid));\r\n          //and remove from its original path\r\n          insertAtPath(diff,currentPath,{});\r\n          //with the move there is no data to apply...\r\n        } else {\r\n          //the move have already been made, so it is enough if we apply\r\n          applyToPath(diff,item.theirs.path,item.theirs.value);\r\n        }\r\n      }\r\n\r\n    }\r\n    _core.applyResolution = function(mine,conflicts){\r\n      var i;\r\n      for(i=0;i<conflicts.length;i++){\r\n        if(conflicts[i].selected === 'theirs'){\r\n          applyResolutionItem(mine,conflicts[i]);\r\n        }\r\n      }\r\n      return mine;\r\n    };*/\r\n\r\n    //now we try a different approach, which maybe more simple\r\n    function getCommonPathForConcat(path){\r\n      if(_concat_moves.getExtensionSourceFromDestination[path]){\r\n        path = _concat_moves.getExtensionSourceFromDestination[path];\r\n      }\r\n      if(_concat_moves.getBaseDestinationFromSource[path]){\r\n        path = _concat_moves.getBaseDestinationFromSource[path];\r\n      }\r\n      return path;\r\n    }\r\n    function getConcatBaseRemovals(diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n        i;\r\n      if(diff.removed !== true){\r\n        if(diff.movedFrom){\r\n          if(_concat_base_removals[diff.guid] !== undefined){\r\n            delete _concat_base_removals[diff.guid];\r\n          } else {\r\n            _concat_base_removals[diff.guid] = false;\r\n          }\r\n        }\r\n        for(i=0;i<relids.length;i++){\r\n          getConcatBaseRemovals(diff[relids[i]]);\r\n        }\r\n      } else {\r\n        if(_concat_base_removals[diff.guid] === false){\r\n          delete _concat_base_removals[diff.guid];\r\n        } else {\r\n          _concat_base_removals[diff.guid] = true;\r\n        }\r\n      }\r\n    }\r\n    function getObstructiveGuids(diffNode){\r\n      var result = [],\r\n        keys,i;\r\n      keys = Object.keys(diffNode.oGuids || {});\r\n      for(i=0;i<keys.length;i++){\r\n        if(_concat_base_removals[keys[i]]){\r\n          result.push(keys[i]);\r\n        }\r\n      }\r\n      keys = Object.keys(diffNode.ooGuids || {});\r\n      for(i=0;i<keys.length;i++){\r\n        if(_concat_base_removals[keys[i]]){\r\n          result.push(keys[i]);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function getWhomIObstructGuids(guid){\r\n      //this function is needed when the extension contains a deletion where the base did not delete the node\r\n      var guids = [],\r\n        checkNode = function(diffNode){\r\n          var relids,i;\r\n          if((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])){\r\n            guids.push(diffNode.guid);\r\n          }\r\n\r\n          relids = getDiffChildrenRelids(diffNode);\r\n          for(i=0;i<relids.length;i++){\r\n            checkNode(diffNode[relids[i]]);\r\n          }\r\n        };\r\n      checkNode(_concat_base);\r\n      return guids;\r\n    }\r\n    function gatherFullNodeConflicts(diffNode,mine,path,opposingPath){\r\n      var conflict,\r\n        opposingConflict,\r\n        keys, i,\r\n        createSingleKeyValuePairConflicts = function(pathBase,data){\r\n        var keys, i;\r\n        keys = Object.keys(data);\r\n        for(i=0;i<keys.length;i++){\r\n          conflict[pathBase+'/'+keys[i]] = conflict[pathBase+'/'+keys[i]] || {value:data[keys[i]],conflictingPaths:{}};\r\n          conflict[pathBase+'/'+keys[i]].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[pathBase+'/'+keys[i]] = true;\r\n        }\r\n      };\r\n\r\n      //setting the conflicts\r\n      if(mine === true){\r\n        conflict = _conflict_mine;\r\n        opposingConflict = _conflict_theirs[opposingPath];\r\n      } else {\r\n        conflict = _conflict_theirs;\r\n        opposingConflict = _conflict_mine[opposingPath];\r\n      }\r\n      ASSERT(opposingConflict);\r\n      //if the node was moved we should make a conflict for the whole node as well\r\n      if(diffNode.movedFrom){\r\n        conflict[path] = conflict[path] || {value:path,conflictingPaths:{}};\r\n        conflict[path].conflictingPaths[opposingPath] = true;\r\n        opposingConflict.conflictingPaths[path] = true;\r\n      }\r\n      createSingleKeyValuePairConflicts(path+'/attr',diffNode.attr || {});\r\n      createSingleKeyValuePairConflicts(path+'/reg',diffNode.reg || {});\r\n      createSingleKeyValuePairConflicts(path+'/pointer',diffNode.pointer || {});\r\n\r\n      if(diffNode.set){\r\n        if(diffNode.set === TODELETESTRING){\r\n          conflict[path+'/set'] = conflict[path+'/set'] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          conflict[path+'/set'].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[path+'/set'] = true;\r\n        } else {\r\n          keys = Object.keys(diffNode.set);\r\n          for(i=0;i<keys.length;i++){\r\n            if(diffNode.set[keys[i]] === TODELETESTRING){\r\n              conflict[path+'/set/'+keys[i]] = conflict[path+'/set/'+keys[i]] || {value:TODELETESTRING,conflictingPaths:{}};\r\n              conflict[path+'/set/'+keys[i]].conflictingPaths[opposingPath] = true;\r\n              opposingConflict.conflictingPaths[path+'/set/'+keys[i]] = true;\r\n            } else {\r\n              gatherFullSetConflicts(diffNode.set[keys[i]],mine,path+'/set/'+keys[i],opposingPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if(diffNode.meta){\r\n        gatherFullMetaConflicts(diffNode.meta,mine,path+'/meta',opposingPath);\r\n      }\r\n\r\n      //if the opposing item is theirs, we have to recursively go down in our changes\r\n      if(mine){\r\n        keys = getDiffChildrenRelids(diffNode);\r\n        for(i=0;i<keys.length;i++){\r\n          gatherFullNodeConflicts(diffNode[keys[i]],true,path+'/'+keys[i],opposingPath);\r\n        }\r\n      }\r\n\r\n    }\r\n    function gatherFullSetConflicts(diffSet,mine,path,opposingPath){\r\n      var relids = getDiffChildrenRelids(diffSet),\r\n        i,keys, j,conflict,opposingConflict;\r\n\r\n      //setting the conflicts\r\n      if(mine === true){\r\n        conflict = _conflict_mine;\r\n        opposingConflict = _conflict_theirs[opposingPath];\r\n      } else {\r\n        conflict = _conflict_theirs;\r\n        opposingConflict = _conflict_mine[opposingPath];\r\n      }\r\n      for(i=0;i<relids.length;i++){\r\n        if(diffSet[relids[i]] === TODELETESTRING){\r\n          //single conflict as the element was removed\r\n          conflict[path+'/'+relids[i]+'/'] = conflict[path+'/'+relids[i]+'/'] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          conflict[path+'/'+relids[i]+'/'].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[path+'/'+relids[i]+'/'] = true;\r\n        } else {\r\n          keys = Object.keys(diffSet[relids[i]].attr || {});\r\n          for(j=0;j<keys.length;j++){\r\n            conflict[path+'/'+relids[i]+'//attr/'+keys[j]] = conflict[path+'/'+relids[i]+'//attr/'+keys[j]] || {value:diffSet[relids[i]].attr[keys[j]],conflictingPaths:{}};\r\n            conflict[path+'/'+relids[i]+'//attr/'+keys[j]].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/'+relids[i]+'//attr/'+keys[j]] = true;\r\n          }\r\n          keys = Object.keys(diffSet[relids[i]].reg || {});\r\n          for(j=0;j<keys.length;j++){\r\n            conflict[path+'/'+relids[i]+'//reg/'+keys[j]] = conflict[path+'/'+relids[i]+'//reg/'+keys[j]] || {value:diffSet[relids[i]].reg[keys[j]],conflictingPaths:{}};\r\n            conflict[path+'/'+relids[i]+'//reg/'+keys[j]].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/'+relids[i]+'//reg/'+keys[j]] = true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    function concatSingleKeyValuePairs(path,base,extension){\r\n      var keys, i,temp;\r\n      keys = Object.keys(extension);\r\n      for(i=0;i<keys.length;i++){\r\n        temp = extension[keys[i]];\r\n        if(typeof temp === 'string' && temp !== TODELETESTRING){\r\n          temp = getCommonPathForConcat(temp);\r\n        }\r\n        if(base[keys[i]] && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)){\r\n          //conflict\r\n          _conflict_mine[path+'/'+keys[i]] = {value:base[keys[i]],conflictingPaths:{}};\r\n          _conflict_theirs[path+'/'+keys[i]] = {value:extension[keys[i]],conflictingPaths:{}};\r\n          _conflict_mine[path+'/'+keys[i]].conflictingPaths[path+'/'+keys[i]] = true;\r\n          _conflict_theirs[path+'/'+keys[i]].conflictingPaths[path+'/'+keys[i]] = true;\r\n        } else {\r\n          base[keys[i]] = extension[keys[i]];\r\n        }\r\n      }\r\n    }\r\n    function concatSet(path,base,extension){\r\n      var names = Object.keys(extension),\r\n        members, i, j,memberPath;\r\n\r\n      for(i=0;i<names.length;i++){\r\n        if(base[names[i]]){\r\n          if(base[names[i]] === TODELETESTRING){\r\n            if(extension[names[i]] !== TODELETESTRING){\r\n              //whole set conflict\r\n              _conflict_mine[path+'/'+names[i]]={value:TODELETESTRING,conflictingPaths:{}};\r\n              gatherFullSetConflicts(extension[names[i]],false,path+'/'+names[i],path+'/'+names[i]);\r\n            }\r\n          } else {\r\n            if(extension[names[i]] === TODELETESTRING){\r\n              //whole set conflict\r\n              _conflict_theirs[path+'/'+names[i]]={value:TODELETESTRING,conflictingPaths:{}};\r\n              gatherFullSetConflicts(base[names[i]],true,path+'/'+names[i],path+'/'+names[i]);\r\n            } else {\r\n              //now we can only have member or sub-member conflicts...\r\n              members = getDiffChildrenRelids(extension[names[i]]);\r\n              for(j=0;j<members.length;j++){\r\n                memberPath = getCommonPathForConcat(members[j]);\r\n                if(base[names[i]][memberPath]){\r\n                  if(base[names[i]][memberPath] === TODELETESTRING){\r\n                    if(extension[names[i]][members[j]] !== TODELETESTRING){\r\n                      //whole member conflict\r\n                      _conflict_mine[path+'/'+names[i]+'/'+memberPath+'//'] = {value:TODELETESTRING,conflictingPaths:{}};\r\n                      gatherFullNodeConflicts(extension[names[i]][members[j]],false,path+'/'+names[i]+'/'+memberPath+'//',path+'/'+names[i]+'/'+memberPath+'//');\r\n                    }\r\n                  } else {\r\n                    if(extension[names[i]][members[j]] === TODELETESTRING){\r\n                      //whole member conflict\r\n                      _conflict_theirs[path+'/'+names[i]+'/'+memberPath+'//'] = {value:TODELETESTRING,conflictingPaths:{}};\r\n                      gatherFullNodeConflicts(base[names[i]][memberPath],true,path+'/'+names[i]+'/'+memberPath+'//',path+'/'+names[i]+'/'+memberPath+'//');\r\n                    } else {\r\n                      if(extension[names[i]][members[j]].attr){\r\n                        if(base[names[i]][memberPath].attr){\r\n                          concatSingleKeyValuePairs(path+'/'+names[i]+'/'+memberPath+'/'+'/attr',base[names[i]][memberPath].attr,extension[names[i]][members[j]].attr);\r\n                        } else {\r\n                          base[names[i]][memberPath].attr = extension[names[i]][members[j]].attr;\r\n                        }\r\n                      }\r\n                      if(extension[names[i]][members[j]].reg){\r\n                        if(base[names[i]][memberPath].reg){\r\n                          concatSingleKeyValuePairs(path+'/'+names[i]+'/'+memberPath+'/'+'/reg',base[names[i]][memberPath].reg,extension[names[i]][members[j]].reg);\r\n                        } else {\r\n                          base[names[i]][memberPath].reg = extension[names[i]][members[j]].reg;\r\n                        }\r\n                      }\r\n\r\n                    }\r\n                  }\r\n                } else {\r\n                  //concat\r\n                  base[names[i]][memberPath] = extension[names[i]][members[j]];\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          //simple concatenation\r\n          //TODO the path for members should be replaced here as well...\r\n          base[names[i]] = extension[names[i]];\r\n        }\r\n      }\r\n    }\r\n    function gatherFullMetaConflicts(diffMeta,mine,path,opposingPath){\r\n      var conflict,opposingConflict,\r\n        relids, i, j, keys, tPath;\r\n\r\n      if(mine){\r\n        conflict = _conflict_mine;\r\n        opposingConflict = _conflict_theirs[opposingPath];\r\n      } else {\r\n        conflict = _conflict_theirs;\r\n        opposingConflict = _conflict_mine[opposingPath];\r\n      }\r\n\r\n      if(diffMeta === TODELETESTRING){\r\n        conflict[path] = conflict[path] || {value:TODELETESTRING,conflictingPaths:{}};\r\n        conflict[path].conflictingPaths[opposingPath] = true;\r\n        opposingConflict.conflictingPaths[path] = true;\r\n        return; //there is no other conflict\r\n      }\r\n\r\n      //children\r\n      if(diffMeta.children){\r\n        if(diffMeta.children === TODELETESTRING){\r\n          conflict[path+'/children'] = conflict[path+'/children'] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          conflict[path+'/children'].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[path+'/children'] = true;\r\n        } else {\r\n          if(diffMeta.children.max){\r\n            conflict[path+'/children/max'] = conflict[path+'/children/max'] || {value:diffMeta.children.max,conflictingPaths:{}};\r\n            conflict[path+'/children/max'].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/children/max'] = true;\r\n          }\r\n          if(diffMeta.children.min){\r\n            conflict[path+'/children/min'] = conflict[path+'/children/min'] || {value:diffMeta.children.min,conflictingPaths:{}};\r\n            conflict[path+'/children/min'].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/children/min'] = true;\r\n          }\r\n          relids = getDiffChildrenRelids(diffMeta.children);\r\n          for(i=0;i<relids.length;i++){\r\n            conflict[path+'/children/'+relids[i]] = conflict[path+'/children/'+relids[i]] || {value:diffMeta.children[relids[i]],conflictingPaths:{}};\r\n            conflict[path+'/children/'+relids[i]].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/children/'+relids[i]] = true;\r\n          }\r\n        }\r\n      }\r\n      //attributes\r\n      if(diffMeta.attributes){\r\n        if(diffMeta.attributes === TODELETESTRING){\r\n          conflict[path+'/attributes'] = conflict[path+'/attributes'] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          conflict[path+'/attributes'].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[path+'/attributes'] = true;\r\n        } else {\r\n          keys = Object.keys(diffMeta.attributes);\r\n          for(i=0;i<keys.length;i++){\r\n            conflict[path+'/attributes/'+keys[i]] = conflict[path+'/attributes/'+keys[i]] || {value:diffMeta.attributes[keys[i]],conflictingPaths:{}};\r\n            conflict[path+'/attributes'].conflictingPaths[opposingPath] = true;\r\n            opposingConflict.conflictingPaths[path+'/attributes'] = true;\r\n          }\r\n        }\r\n      }\r\n      //pointers\r\n      if(diffMeta.pointers){\r\n        if(diffMeta.pointers === TODELETESTRING){\r\n          conflict[path+'/pointers'] = conflict[path+'/pointers'] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          conflict[path+'/pointers'].conflictingPaths[opposingPath] = true;\r\n          opposingConflict.conflictingPaths[path+'/pointers'] = true;\r\n        } else {\r\n          keys = Object.keys(diffMeta.pointers);\r\n          for(i=0;i<keys.length;i++){\r\n            if(diffMeta.pointers[keys[i]] === TODELETESTRING){\r\n              conflict[path+'/pointers/'+keys[i]] = conflict[path+'/pointers/'+keys[i]] || {value:TODELETESTRING,conflictingPaths:{}};\r\n              conflict[path+'/pointers/'+keys[i]].conflictingPaths[opposingPath] = true;\r\n              opposingConflict.conflictingPaths[path+'/pointers/'+keys[i]] = true;\r\n            } else {\r\n              if(diffMeta.pointers[keys[i]].max){\r\n                conflict[path+'/pointers/'+keys[i]+'/max'] = conflict[path+'/pointers/'+keys[i]+'/max'] || {value:diffMeta.pointers[keys[i]].max,conflictingPaths:{}};\r\n                conflict[path+'/pointers/'+keys[i]+'/max'].conflictingPaths[opposingPath] = true;\r\n                opposingConflict.conflictingPaths[path+'/pointers/'+keys[i]+'/max'] = true;\r\n              }\r\n              if(diffMeta.pointers[keys[i]].min){\r\n                conflict[path+'/pointers/'+keys[i]+'/min'] = conflict[path+'/pointers/'+keys[i]+'/min'] || {value:diffMeta.pointers[keys[i]].min,conflictingPaths:{}};\r\n                conflict[path+'/pointers/'+keys[i]+'/min'].conflictingPaths[opposingPath] = true;\r\n                opposingConflict.conflictingPaths[path+'/pointers/'+keys[i]+'/min'] = true;\r\n              }\r\n              relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);\r\n              for(j=0;j<relids.length;j++){\r\n                tPath = getCommonPathForConcat(relids[j]);\r\n                conflict[path+'/pointers/'+keys[i]+'/'+tPath+'//'] = conflict[path+'/pointers/'+keys[i]+'/'+tPath+'//'] || {value:diffMeta.pointers[keys[i]][relids[j]],conflictingPaths:{}};\r\n                conflict[path+'/pointers/'+keys[i]+'/'+tPath+'//'].conflictingPaths[opposingPath] = true;\r\n                opposingConflict.conflictingPaths[path+'/pointers/'+keys[i]+'/'+tPath+'//'] = true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      //aspects\r\n      //TODO\r\n    }\r\n    function concatMeta(path,base,extension){\r\n      var keys, i,tPath, j,paths,t2Path,\r\n          mergeMetaItems = function(bPath,bData,eData){\r\n            var bKeys,tKeys, i,tPath,t2Path;\r\n            //delete checks\r\n            if(bData === TODELETESTRING || eData === TODELETESTRING){\r\n              if(CANON.stringify(bData) !== CANON.stringify(eData)){\r\n                _conflict_mine[bPath] = _conflict_mine[bPath] || {value:bData,conflictingPaths:{}};\r\n                _conflict_mine[bPath].conflictingPaths[bPath] = true;\r\n                _conflict_theirs[bPath] = _conflict_theirs[bPath] || {value:eData,conflictingPaths:{}};\r\n                _conflict_theirs[bPath].conflictingPaths[bPath] = true;\r\n              }\r\n            } else {\r\n              //max\r\n              if(eData.max){\r\n                if(bData.max && bData.max !== eData.max){\r\n                  tPath = bPath+'/max';\r\n                  _conflict_mine[tPath] = _conflict_mine[tPath] || {value:bData.max,conflictingPaths:{}};\r\n                  _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                  _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:eData.max,conflictingPaths:{}};\r\n                  _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                } else {\r\n                  bData.max = eData.max;\r\n                }\r\n              }\r\n              //min\r\n              if(eData.min) {\r\n                if (bData.min && bData.min !== eData.min) {\r\n                  tPath = bPath + '/min';\r\n                  _conflict_mine[tPath] = _conflict_mine[tPath] || {value: bData.min, conflictingPaths: {}};\r\n                  _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                  _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value: eData.min, conflictingPaths: {}};\r\n                  _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                } else {\r\n                  bData.max = eData.min;\r\n                }\r\n              }\r\n              //targets\r\n              bKeys = getDiffChildrenRelids(bData);\r\n              tKeys = getDiffChildrenRelids(eData);\r\n              for(i=0;i<tKeys.length;i++){\r\n                tPath = getCommonPathForConcat(tKeys[i]);\r\n                if(bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !== CANON.stringify(eData[tKeys[i]])){\r\n                  t2Path = tPath;\r\n                  tPath = bPath+'/'+tPath+'//';\r\n                  _conflict_mine[tPath] = _conflict_mine[tPath] || {value:bData[t2Path],conflictingPaths:{}};\r\n                  _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                  _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:eData[tKeys[i]],conflictingPaths:{}};\r\n                  _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                } else {\r\n                  bData[tPath] = eData[tKeys[i]];\r\n                }\r\n              }\r\n            }\r\n          };\r\n      if(CANON.stringify(base) !== CANON.stringify(extension)){\r\n        if(base === TODELETESTRING){\r\n          _conflict_mine[path] = _conflict_mine[path] || {value:TODELETESTRING,conflictingPaths:{}};\r\n          gatherFullMetaConflicts(extension,false,path,path);\r\n        } else {\r\n          if(extension === TODELETESTRING){\r\n            _conflict_theirs[path] = _conflict_theirs[path] || {value:TODELETESTRING,conflictingPaths:{}};\r\n            gatherFullMetaConflicts(base,true,path,path);\r\n          } else {\r\n            //now check for sub-meta conflicts\r\n\r\n            //children\r\n            if(extension.children){\r\n              if(base.children){\r\n                mergeMetaItems(path+'/children',base.children,extension.children);\r\n              } else {\r\n                //we just simply merge the extension's\r\n                base.children = extension.children;\r\n              }\r\n            }\r\n            //pointers\r\n            if(extension.pointers){\r\n              if(base.pointers){\r\n                //complete deletion\r\n                if(base.pointers === TODELETESTRING || extension.pointers === TODELETESTRING){\r\n                  if(CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)){\r\n                    tPath = path+'/pointers';\r\n                    _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.pointers,conflictingPaths:{}};\r\n                    _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                    _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.pointers,conflictingPaths:{}};\r\n                    _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                  }\r\n                } else {\r\n                  keys = Object.keys(extension.pointers);\r\n                  for(i=0;i<keys.length;i++){\r\n                    if(base.pointers[keys[i]]){\r\n                      mergeMetaItems(path+'/pointers/'+keys[i],base.pointers[keys[i]],extension.pointers[keys[i]]);\r\n                    } else {\r\n                      base.pointers[keys[i]] = extension.pointers[keys[i]];\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                base.pointers = extension.pointers;\r\n              }\r\n            }\r\n            //attributes\r\n            if(extension.attributes){\r\n              if(base.attributes){\r\n                if(extension.attributes === TODELETESTRING || base.attributes == TODELETESTRING){\r\n                  if(CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)){\r\n                    tPath = path+'/attributes';\r\n                    _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.attributes,conflictingPaths:{}};\r\n                    _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                    _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.attributes,conflictingPaths:{}};\r\n                    _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                  }\r\n                } else {\r\n                  keys = Object.keys(extension.attributes);\r\n                  for(i=0;i<keys.length;i++){\r\n                    if(base.attributes[keys[i]]){\r\n                      if(extension.attributes[keys[i]] === TODELETESTRING || base.attributes[keys[i]] == TODELETESTRING){\r\n                        if(CANON.stringify(base.attributes[keys[i]]) !== CANON.stringify(extension.attributes[keys[i]])){\r\n                          tPath = path+'/attributes/'+[keys[i]];\r\n                          _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.attributes[keys[i]],conflictingPaths:{}};\r\n                          _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                          _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.attributes[keys[i]],conflictingPaths:{}};\r\n                          _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                        }\r\n                      } else {\r\n                        concatSingleKeyValuePairs(path+'/attributes/'+keys[i],base.attributes[keys[i]],extension.attributes[keys[i]]);\r\n                      }\r\n                    } else {\r\n                      base.attributes[keys[i]] = extension.attributes[keys[i]];\r\n                    }\r\n                  }\r\n\r\n                }\r\n              } else {\r\n                base.attributes = extension.attributes;\r\n              }\r\n            }\r\n\r\n            //aspects\r\n            if(extension.aspects){\r\n              if(base.aspects){\r\n                if(extension.aspects === TODELETESTRING || base.aspects == TODELETESTRING){\r\n                  if(CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)){\r\n                    tPath = path+'/aspects';\r\n                    _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.aspects,conflictingPaths:{}};\r\n                    _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                    _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.aspects,conflictingPaths:{}};\r\n                    _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                  }\r\n                } else {\r\n                  keys = Object.keys(extension.aspects);\r\n                  for(i=0;i<keys.length;i++){\r\n                    if(base.aspects[keys[i]]){\r\n                      if(extension.aspects[keys[i]] === TODELETESTRING || base.aspects[keys[i]] == TODELETESTRING){\r\n                        if(CANON.stringify(base.aspects[keys[i]]) !== CANON.stringify(extension.aspects[keys[i]])){\r\n                          tPath = path+'/aspects/'+keys[i];\r\n                          _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.aspects[keys[i]],conflictingPaths:{}};\r\n                          _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                          _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.aspects[keys[i]],conflictingPaths:{}};\r\n                          _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                        }\r\n                      } else {\r\n                        paths = Object.keys(extension.aspects[keys[i]]);\r\n                        for(j=0;j<paths.length;j++){\r\n                          tPath = getCommonPathForConcat(paths[j]);\r\n                          if(base.aspects[keys[i]][tPath]){\r\n                            if(CANON.stringify(base.aspects[keys[i]][tPath]) !== CANON.stringify(extension.aspects[keys[i]][paths[j]])){\r\n                              t2Path = tPath;\r\n                              tPath = path+'/aspects/'+keys[i]+'/'+tPath+'//';\r\n                              _conflict_mine[tPath] = _conflict_mine[tPath] || {value:base.aspects[keys[i]][t2Path],conflictingPaths:{}};\r\n                              _conflict_mine[tPath].conflictingPaths[tPath] = true;\r\n                              _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:extension.aspects[keys[i]][paths[j]],conflictingPaths:{}};\r\n                              _conflict_theirs[tPath].conflictingPaths[tPath] = true;\r\n                            }\r\n                          } else {\r\n                            base.aspects[keys[i]][tPath] = extension.aspects[keys[i]][paths[j]];\r\n                          }\r\n                        }\r\n                      }\r\n                    } else {\r\n                      base.aspects[keys[i]] = extension.aspects[keys[i]];\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                base.aspects = extension.aspects;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    function tryToConcatNodeChange(extNode,path){\r\n      var guid = extNode.guid,\r\n        oGuids =  getObstructiveGuids(extNode),\r\n        baseNode = getNodeByGuid(_concat_base,guid),\r\n        basePath = getPathByGuid(_concat_base,guid,''),\r\n        i,tPath,\r\n        relids = getDiffChildrenRelids(extNode);\r\n\r\n\r\n      if(extNode.removed === true){\r\n        if(baseNode && baseNode.removed !== true){\r\n          tPath = basePath+'/removed';\r\n          _conflict_theirs[tPath] = _conflict_theirs[tPath] || {value:true,conflictingPaths:{}};\r\n          oGuids = getWhomIObstructGuids(guid);\r\n          ASSERT(oGuids.length > 0);\r\n          for(i=0;i<oGuids.length;i++){\r\n            baseNode = getNodeByGuid(_concat_base,oGuids[i]);\r\n            basePath = getPathByGuid(_concat_base,oGuids[i],'');\r\n            gatherFullNodeConflicts(baseNode,true,basePath,tPath);\r\n          }\r\n        } else {\r\n          //we simply concat the deletion\r\n          insertAtPath(_concat_base,path,extNode);\r\n        }\r\n      } else {\r\n        if(oGuids.length > 0){\r\n            for(i=0;i<oGuids.length;i++){\r\n              baseNode = getNodeByGuid(_concat_base,oGuids[i]);\r\n              basePath = getPathByGuid(_concat_base,oGuids[i],'');\r\n              _conflict_mine[basePath+'/removed'] = _conflict_mine[basePath+'/removed'] || {value:true,conflictingPaths:{}};\r\n              gatherFullNodeConflicts(extNode,false,path,basePath+'/removed');\r\n            }\r\n        } else if(baseNode){\r\n          //here we are able to check the sub-node conflicts\r\n          //check double moves - we do not care if they moved under the same parent\r\n          if(extNode.movedFrom){\r\n            if(baseNode.movedFrom && path !== basePath){\r\n              _conflict_mine[basePath] = _conflict_mine[basePath] || {value:\"move\",conflictingPaths:{}};\r\n              _conflict_theirs[path] = _conflict_theirs[path] || {value:\"move\",conflictingPaths:{}};\r\n              _conflict_mine[basePath].conflictingPaths[path]=true;\r\n              _conflict_theirs[path].conflictingPaths[basePath] = true;\r\n              //we keep the node where it is, but synchronize the paths\r\n              path = basePath;\r\n            } else if(path !== basePath){\r\n              //first we move the base object to its new path\r\n              //we copy the moved from information right here\r\n              baseNode.movedFrom = extNode.movedFrom;\r\n              insertAtPath(_concat_base,path,baseNode);\r\n              removePathFromDiff(_concat_base,basePath);\r\n              baseNode = getNodeByGuid(_concat_base,guid);\r\n              basePath = getPathByGuid(_concat_base,guid,'');\r\n              ASSERT(path === basePath);\r\n            }\r\n          }\r\n\r\n          ASSERT(basePath === path || baseNode.movedFrom === path);\r\n          path = basePath; //the base was moved\r\n\r\n\r\n          //and now the sub-node conflicts\r\n          if(extNode.attr){\r\n            if(baseNode.attr){\r\n              concatSingleKeyValuePairs(path+'/attr',baseNode.attr,extNode.attr);\r\n            } else {\r\n              insertAtPath(_concat_base,path+'/attr',extNode.attr);\r\n            }\r\n          }\r\n          if(extNode.reg){\r\n            if(baseNode.reg){\r\n              concatSingleKeyValuePairs(path+'/reg',baseNode.reg,extNode.reg);\r\n            } else {\r\n              insertAtPath(_concat_base,path+'/reg',extNode.reg);\r\n            }\r\n          }\r\n          if(extNode.pointer){\r\n            if(baseNode.pointer){\r\n              concatSingleKeyValuePairs(path+'/pointer',baseNode.pointer,extNode.pointer);\r\n            } else {\r\n              insertAtPath(_concat_base,path+'/pointer',extNode.pointer);\r\n            }\r\n          }\r\n          if(extNode.set){\r\n            if(baseNode.set){\r\n              concatSet(path+'/set',baseNode.set,extNode.set);\r\n            } else {\r\n              insertAtPath(_concat_base,path+'/set',extNode.set);\r\n            }\r\n          }\r\n          if(extNode.meta){\r\n            if(baseNode.meta){\r\n              concatMeta(path+'/meta',baseNode.meta,extNode.meta);\r\n            } else {\r\n              insertAtPath(_concat_base,path+'/meta',extNode.meta);\r\n            }\r\n          }\r\n        } else {\r\n          //there is no basenode so we can concat the whole node\r\n          insertAtPath(_concat_base,path,getSingleNode(extNode));\r\n        }\r\n      }\r\n\r\n      //here comes the recursion\r\n      for(i=0;i<relids.length;i++){\r\n        tryToConcatNodeChange(extNode[relids[i]],path+'/'+relids[i]);\r\n      }\r\n\r\n    }\r\n\r\n    function generateConflictItems(){\r\n      var items = [],\r\n        keys, i, j,conflicts;\r\n      keys = Object.keys(_conflict_mine);\r\n\r\n      for(i=0;i<keys.length;i++){\r\n        conflicts = Object.keys(_conflict_mine[keys[i]].conflictingPaths || {});\r\n        ASSERT(conflicts.length > 0);\r\n        for(j=0;j<conflicts.length;j++){\r\n          items.push({\r\n            selected:\"mine\",\r\n            mine:{\r\n              path: keys[i],\r\n              info: keys[i].replace(/\\//g,\" / \"),\r\n              value: _conflict_mine[keys[i]].value\r\n            },\r\n            theirs:{\r\n              path:conflicts[j],\r\n              info:conflicts[j].replace(/\\//g,\" / \"),\r\n              value:_conflict_theirs[conflicts[j]].value\r\n            }\r\n          });\r\n        }\r\n      }\r\n      return items;\r\n    }\r\n    function harmonizeConflictPaths(diff){\r\n      var relids = getDiffChildrenRelids(diff),\r\n        keys, i,members,j;\r\n\r\n      keys = Object.keys(diff.pointer || {});\r\n      for(i=0;i<keys.length;i++){\r\n        diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);\r\n      }\r\n      keys = Object.keys(diff.set || {});\r\n      for(i=0;i<keys.length;i++){\r\n        members = Object.keys(diff.set[keys[i]] || {});\r\n        for(j=0;j<members.length;j++){\r\n          if(members[j] !== getCommonPathForConcat(members[j])){\r\n            diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];\r\n            delete diff.set[keys[i]][members[j]];\r\n          }\r\n        }\r\n      }\r\n\r\n      //TODO we have to do the meta as well\r\n      for(i=0;i<relids.length;i++){\r\n        harmonizeConflictPaths(diff[relids[i]]);\r\n      }\r\n    }\r\n\r\n    _core.tryToConcatChanges = function(base,extension){\r\n      var result = {};\r\n      _conflict_items = [];\r\n      _conflict_mine = {};\r\n      _conflict_theirs = {};\r\n      _concat_base = base;\r\n      _concat_extension = extension;\r\n      _concat_base_removals = {};\r\n      _concat_moves = {\r\n        getBaseSourceFromDestination : {},\r\n        getBaseDestinationFromSource : {},\r\n        getExtensionSourceFromDestination : {},\r\n        getExtensionDestinationFromSource : {}\r\n      };\r\n      getMoveSources(base,'',_concat_moves.getBaseSourceFromDestination,_concat_moves.getBaseDestinationFromSource);\r\n      getMoveSources(extension,'',_concat_moves.getExtensionSourceFromDestination,_concat_moves.getExtensionDestinationFromSource);\r\n      getConcatBaseRemovals(base);\r\n      tryToConcatNodeChange(_concat_extension,'');\r\n\r\n      result.items = generateConflictItems();\r\n      result.mine = _conflict_mine;\r\n      result.theirs = _conflict_theirs;\r\n      result.merge = _concat_base;\r\n      harmonizeConflictPaths(result.merge);\r\n      return result;\r\n    };\r\n\r\n    function depthOfPath(path){\r\n      ASSERT(typeof path === \"string\");\r\n      return path.split('/').length;\r\n    }\r\n    function resolveMoves(resolveObject){\r\n      var i,moves = {},filteredItems=[],path,\r\n        moveBaseOfPath = function(path){\r\n          var keys = Object.keys(moves),\r\n            i,maxDepth = -1,base=null;\r\n          for(i=0;i<keys.length;i++){\r\n            if(path.indexOf(keys[i]) === 1 && depthOfPath(keys[i])>maxDepth){\r\n              base = keys[i];\r\n              maxDepth = depthOfPath(keys[i]);\r\n            }\r\n          }\r\n          return base;\r\n        };\r\n      for(i=0;i<resolveObject.items.length;i++){\r\n        if(resolveObject.items[i].selected === \"theirs\" && resolveObject.items[i].theirs.value === \"move\"){\r\n          moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;\r\n          //and we also make the move\r\n          insertAtPath(resolveObject.merge,resolveObject.items[i].theirs.path,getPathOfDiff(resolveObject.merge,resolveObject.items[i].mine.path));\r\n          removePathFromDiff(resolveObject.merge,resolveObject.items[i].mine.path);\r\n        } else {\r\n          filteredItems.push(resolveObject.items[i]);\r\n        }\r\n      }\r\n      resolveObject.items = filteredItems;\r\n\r\n      //in a second run we modify all sub-path of the moves paths\r\n      for(i=0;i<resolveObject.items.length;i++){\r\n        if(resolveObject.items[i].selected === \"theirs\"){\r\n          path = moveBaseOfPath(resolveObject.items[i].theirs.path);\r\n          if(path){\r\n            resolveObject.items[i].theirs.path = resolveObject.items[i].theirs.path.replace(path,moves[path]);\r\n          }\r\n          path = moveBaseOfPath(resolveObject.items[i].mine.path);\r\n          if(path){\r\n            resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path,moves[path]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    /*function resolveConflictItem(diff,conflictItem){\r\n\r\n      //let's start with the easy ones :)\r\n\r\n      //if the two path is equal, the we can simply replace the base value\r\n      if(conflictItem.mine.path === conflictItem.theirs.path){\r\n        insertAtPath(diff,conflictItem.theirs.path,conflictItem.theirs.value);\r\n      }\r\n    }*/\r\n\r\n    _core.applyResolution = function(conflictObject){\r\n      //we apply conflict items to the merge and return it as a diff\r\n      var i;\r\n      resolveMoves(conflictObject);\r\n      for(i=0;i<conflictObject.items.length;i++){\r\n        if(conflictObject.items[i].selected !== \"mine\"){\r\n          removePathFromDiff(conflictObject.merge,conflictObject.items[i].mine.path);\r\n          insertAtPath(conflictObject.merge,conflictObject.items[i].theirs.path,conflictObject.items[i].theirs.value);\r\n        }\r\n      }\r\n\r\n      return conflictObject.merge;\r\n    };\r\n\r\n\r\n    //we remove some low level functions as they should not be used on high level\r\n    delete _core.overlayInsert;\r\n\r\n    return _core;\r\n  }\r\n\r\n  return diffCore;\r\n});\r\n\n",
    "/**\r\n * Created by tkecskes on 12/11/2014.\r\n */\r\ndefine('core/coretreeloader',[ \"util/assert\", \"core/core\", \"core/tasync\" ], function(ASSERT, Core, TASYNC) {\r\n  \"use strict\";\r\n\r\n  // ----------------- CoreTreeLoader -----------------\r\n\r\n  var MetaCore = function (innerCore) {\r\n    var core = {},\r\n      key;\r\n    for ( key in innerCore) {\r\n      core[key] = innerCore[key];\r\n    }\r\n\r\n    //adding load functions\r\n    core.loadSubTree = function(root){\r\n      var loadSubTrees = function(nodes){\r\n        for (var i = 0; i < nodes.length; i++) {\r\n          nodes[i] = core.loadSubTree(nodes[i]);\r\n        }\r\n        return TASYNC.lift(nodes);\r\n\r\n      };\r\n      return TASYNC.call(function(children){\r\n        if(children.length<1){\r\n          return [root];\r\n        } else {\r\n          return TASYNC.call(function(subArrays){\r\n            var nodes = [],\r\n              i;\r\n            for(i=0;i<subArrays.length;i++){\r\n              nodes = nodes.concat(subArrays[i]);\r\n            }\r\n            nodes.unshift(root);\r\n            return nodes;\r\n          },loadSubTrees(children));\r\n        }\r\n      },core.loadChildren(root));\r\n    };\r\n    core.loadTree = function(rootHash) {\r\n      return TASYNC.call(core.loadSubTree, core.loadRoot(rootHash));\r\n    };\r\n\r\n    return core;\r\n  };\r\n  return MetaCore;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('core/core',[\r\n'core/corerel',\r\n'core/setcore',\r\n'core/guidcore',\r\n'core/nullpointercore',\r\n'core/coreunwrap',\r\n'core/descriptorcore',\r\n'core/coretype',\r\n'core/constraintcore',\r\n'core/coretree',\r\n'core/metacore',\r\n'core/corediff',\r\n'core/coretreeloader'],\r\nfunction (CoreRel, Set, Guid, NullPtr, UnWrap, Descriptor, Type, Constraint, CoreTree, MetaCore, Diff, TreeLoader)\r\n{\r\n    \"use strict\";\r\n\r\n    function core(storage,options){\r\n        options = options || {};\r\n        options.usetype = options.usertype || 'nodejs';\r\n\r\n        var coreCon = new TreeLoader(new Diff(new MetaCore(new Constraint(new Descriptor(new Guid(new Set(new NullPtr(new Type(new NullPtr(new CoreRel(new CoreTree(storage, options))))))))))));\r\n\r\n        if(options.usertype === 'tasync'){\r\n            return coreCon;\r\n        } else {\r\n            return new UnWrap(coreCon);\r\n        }\r\n    }\r\n\r\n    return core;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/client',[ \"util/assert\", \"util/guid\" ], function (ASSERT, GUID) {\r\n  \"use strict\";\r\n\r\n  function Database(options) {\r\n    ASSERT(typeof options === \"object\");\r\n\r\n    options.type = options.type || \"browser\";\r\n    options.timeout = options.timeout || 100000;\r\n\r\n    var _hostAddress = null;\r\n    if (options.type === \"browser\") {\r\n      _hostAddress = options.host || window.location.protocol + '//' + window.location.host;\r\n    } else {\r\n      _hostAddress = options.host + (options.port ? ':' + options.port : \"\");\r\n    }\r\n\r\n\r\n    var socketConnected = false,\r\n      socket = null,\r\n      status = null,\r\n      reconnect = false,\r\n      getDbStatusCallbacks = {},\r\n      callbacks = {},\r\n      getBranchHashCallbacks = {},\r\n      IO = null,\r\n      projects = {},\r\n      references = {},\r\n      ERROR_DISCONNECTED = 'The socket.io is disconnected',\r\n      ERROR_TIMEOUT = \"no valid response arrived in time\",\r\n      STATUS_NETWORK_DISCONNECTED = \"socket.io is disconnected\";\r\n\r\n    function clearDbCallbacks() {\r\n      var myCallbacks = [];\r\n      for (var i in getDbStatusCallbacks) {\r\n        myCallbacks.push(getDbStatusCallbacks[i]);\r\n        clearTimeout(getDbStatusCallbacks[i].to);\r\n      }\r\n      getDbStatusCallbacks = {};\r\n      for (i = 0; i < myCallbacks.length; i++) {\r\n        myCallbacks[i].cb(null, status);\r\n      }\r\n    }\r\n\r\n    function clearCallbacks() {\r\n      var myCallbacks = [];\r\n      for (var i in callbacks) {\r\n        myCallbacks.push(callbacks[i]);\r\n        clearTimeout(callbacks[i].to);\r\n      }\r\n      callbacks = {};\r\n      for (i = 0; i < myCallbacks.length; i++) {\r\n        myCallbacks[i].cb(ERROR_DISCONNECTED);\r\n      }\r\n    }\r\n\r\n    function reSendGetBranches() {\r\n      //this function should be called after reconnecting\r\n      for (var i in getBranchHashCallbacks) {\r\n        projects[getBranchHashCallbacks[i].project].getBranchHash(i, getBranchHashCallbacks[i].oldhash, getBranchHashCallbacks[i].cb);\r\n      }\r\n    }\r\n\r\n    function callbackTimeout(guid) {\r\n      var cb = null, oldhash = \"\";\r\n      if (callbacks[guid]) {\r\n        cb = callbacks[guid].cb;\r\n        delete callbacks[guid];\r\n        cb(new Error(ERROR_TIMEOUT));\r\n      } else if (getDbStatusCallbacks[guid]) {\r\n        cb = getDbStatusCallbacks[guid].cb;\r\n        delete getDbStatusCallbacks[guid];\r\n        cb(null, status);\r\n      } else if (getBranchHashCallbacks[guid]) {\r\n        cb = getBranchHashCallbacks[guid].cb;\r\n        oldhash = getBranchHashCallbacks[guid].oldhash;\r\n        delete getBranchHashCallbacks[guid];\r\n        cb(new Error(ERROR_TIMEOUT), null, null);\r\n      }\r\n    }\r\n\r\n    function registerProject(id, name) {\r\n      if (!references[name]) {\r\n        references[name] = [];\r\n      }\r\n      if (references[name].indexOf(id) === -1) {\r\n        references[name].push(id);\r\n      }\r\n    }\r\n\r\n    function unRegisterProject(id, name) {\r\n      if (references[name]) {\r\n        var index = references[name].indexOf(id);\r\n        if (index > -1) {\r\n          references[name].splice(index, 1);\r\n          if (references[name].length === 0) {\r\n            delete references[name];\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function openDatabase(callback) {\r\n      ASSERT(typeof callback === \"function\");\r\n\r\n      if (socket) {\r\n        if (socketConnected) {\r\n          callback(null);\r\n        } else {\r\n          //we should try to reconnect\r\n          callback(null);\r\n          socket.socket.reconnect();\r\n        }\r\n      } else {\r\n        var guid = GUID(), firstConnection = true;\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n\r\n        var IOReady = function () {\r\n          socket = IO.connect(_hostAddress, {\r\n            'connect timeout': 10,\r\n            'reconnection delay': 1,\r\n            'force new connection': true,\r\n            'reconnect': false,\r\n            'query': \"webGMESessionId=\" + options.webGMESessionId\r\n          });\r\n\r\n          socket.on('connect', function () {\r\n            socketConnected = true;\r\n            if (firstConnection) {\r\n              firstConnection = false;\r\n              socket.emit('openDatabase', function (err) {\r\n                if (!err) {\r\n                  socket.emit('getDatabaseStatus', null, function (err, newstatus) {\r\n                    if (!err && newstatus) {\r\n                      status = newstatus;\r\n                    }\r\n                    if (callbacks[guid]) {\r\n                      clearTimeout(callbacks[guid].to);\r\n                      delete callbacks[guid];\r\n                      callback(err);\r\n                    }\r\n                  });\r\n                } else {\r\n                  socket.emit('disconnect');\r\n                  socket = null;\r\n                  if (callbacks[guid]) {\r\n                    clearTimeout(callbacks[guid].to);\r\n                    delete callbacks[guid];\r\n                    callback(err);\r\n                  }\r\n                }\r\n              });\r\n            } else {\r\n              socket.emit('getDatabaseStatus', status, function (err, newstatus) {\r\n                if (!err && newstatus) {\r\n                  status = newstatus;\r\n                  clearDbCallbacks();\r\n                  reSendGetBranches();\r\n                }\r\n              });\r\n            }\r\n          });\r\n\r\n          socket.on('disconnect', function () {\r\n            status = STATUS_NETWORK_DISCONNECTED;\r\n            socketConnected = false;\r\n            clearDbCallbacks();\r\n            clearCallbacks();\r\n            //socket.socket.reconnect();\r\n          });\r\n        };\r\n\r\n        if (options.type === 'browser') {\r\n          require([ _hostAddress + \"/socket.io/socket.io.js\" ], function () {\r\n            IO = io;\r\n            IOReady();\r\n          });\r\n        } else {\r\n          /*IO = require(\"socket.io-client\");\r\n           IOReady();*/\r\n          require([ 'socket.io-client' ], function (io) {\r\n            IO = io;\r\n            IOReady();\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function closeDatabase(callback) {\r\n      callback = callback || function () {\r\n      };\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('closeDatabase', function (err) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function fsyncDatabase(callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('fsyncDatabase', function (err) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function getDatabaseStatus(oldstatus, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (status !== oldstatus) {\r\n        callback(null, status);\r\n      } else {\r\n        var guid = GUID();\r\n        getDbStatusCallbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        if (status !== STATUS_NETWORK_DISCONNECTED) {\r\n          socket.emit('getDatabaseStatus', oldstatus, function (err, newstatus) {\r\n            if (!err && newstatus) {\r\n              status = newstatus;\r\n            }\r\n            if (callbacks[guid]) {\r\n              clearTimeout(getDbStatusCallbacks[guid].to);\r\n              delete getDbStatusCallbacks[guid];\r\n              callback(err, newstatus);\r\n              //TODO why this common error check is missing and what was redo meant???\r\n              /*commonErrorCheck(err, function (err2, needRedo) {\r\n               if (needRedo) {\r\n               getDatabaseStatus(oldstatus, callback);\r\n               } else {\r\n               callback(err2, newstatus);\r\n               }\r\n               });*/\r\n            }\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    function getProjectNames(callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('getProjectNames', function (err, names) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, names);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function getAllowedProjectNames(callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('getAllowedProjectNames', function (err, names) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, names);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function getAuthorizationInfo(name, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('getAuthorizationInfo', name, function (err, authInfo) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, authInfo);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function deleteProject(project, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('deleteProject', project, function (err) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function getNextServerEvent(latestGuid, callback) {\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, options.timeout, guid)\r\n        };\r\n        socket.emit('getNextServerEvent', latestGuid, function (err, newGuid, eventParams) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, newGuid, eventParams);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    function openProject(project, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      var ownId = GUID();\r\n      if (projects[project]) {\r\n        registerProject(ownId, project);\r\n        callback(null, projects[project]);\r\n      } else {\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('openProject', project, function (err) {\r\n            if (!err) {\r\n              registerProject(ownId, project);\r\n              if (callbacks[guid]) {\r\n                clearTimeout(callbacks[guid].to);\r\n                delete callbacks[guid];\r\n                projects[project] = {\r\n                  fsyncDatabase: fsync,\r\n                  getDatabaseStatus: getDatabaseStatus,\r\n                  closeProject: closeProject,\r\n                  loadObject: loadObject,\r\n                  insertObject: insertObject,\r\n                  getInfo: getInfo,\r\n                  setInfo: setInfo,\r\n                  findHash: findHash,\r\n                  dumpObjects: dumpObjects,\r\n                  getBranchNames: getBranchNames,\r\n                  getBranchHash: getBranchHash,\r\n                  setBranchHash: setBranchHash,\r\n                  getCommits: getCommits,\r\n                  makeCommit: makeCommit,\r\n                  getCommonAncestorCommit: getCommonAncestorCommit,\r\n                  ID_NAME: \"_id\"\r\n                };\r\n                callback(null, projects[project]);\r\n              }\r\n            } else {\r\n              callback(err, null);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      //functions\r\n            function fsync(callback){\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n                    flushSaveBucket();\r\n          socket.emit('fsyncDatabase', function (err) {\r\n            if(callbacks[guid]){\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function getDatabaseStatus(oldstatus, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (status !== oldstatus) {\r\n          callback(null, status);\r\n        } else {\r\n          var guid = GUID();\r\n          getDbStatusCallbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          if (socketConnected) {\r\n            socket.emit('getDatabaseStatus', oldstatus, function (err, newstatus) {\r\n              if (getDbStatusCallbacks[guid]) {\r\n                clearTimeout(getDbStatusCallbacks[guid].to);\r\n                delete getDbStatusCallbacks[guid];\r\n                if (!err && newstatus) {\r\n                  status = newstatus;\r\n                }\r\n                callback(err, newstatus);\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      function closeProject(callback) {\r\n        callback = callback || function () {\r\n        };\r\n        if (unRegisterProject(ownId, project)) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('closeProject', project, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(null);\r\n        }\r\n      }\r\n\r\n      function _loadObject(hash, callback) {\r\n        socket.emit('loadObject', project, hash, callback);\r\n      }\r\n\r\n      function loadObject(hash, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          if (loadBucketSize === 0) {\r\n            ++loadBucketSize;\r\n            loadBucket.push({hash: hash, cb: callback});\r\n            loadBucketTimer = setTimeout(function () {\r\n              var myBucket = loadBucket;\r\n              loadBucket = [];\r\n              loadBucketTimer = null;\r\n              loadBucketSize = 0;\r\n              loadObjects(myBucket);\r\n            }, 10);\r\n          } else if (loadBucketSize === 99) {\r\n            loadBucket.push({hash: hash, cb: callback});\r\n            var myBucket = loadBucket;\r\n            loadBucket = [];\r\n            clearTimeout(loadBucketTimer);\r\n            loadBucketTimer = null;\r\n            loadBucketSize = 0;\r\n            loadObjects(myBucket);\r\n          } else {\r\n            loadBucket.push({hash: hash, cb: callback});\r\n            ++loadBucketSize;\r\n          }\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      var loadBucket = [],\r\n        loadBucketSize = 0,\r\n        loadBucketTimer;\r\n\r\n      function loadObjects(hashedObjects) {\r\n        var hashes = {}, i;\r\n        for (i = 0; i < hashedObjects.length; i++) {\r\n          hashes[hashedObjects[i].hash] = true;\r\n        }\r\n        hashes = Object.keys(hashes);\r\n        socket.emit('loadObjects', project, hashes, function (err, results) {\r\n          for (i = 0; i < hashedObjects.length; i++) {\r\n            hashedObjects[i].cb(err, results[hashedObjects[i].hash]);\r\n          }\r\n        });\r\n\r\n      }\r\n\r\n      function insertObject(object, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          if (saveBucketSize === 0) {\r\n            ++saveBucketSize;\r\n            saveBucket.push({object: object, cb: callback});\r\n            saveBucketTimer = setTimeout(function () {\r\n              flushSaveBucket();\r\n            }, 10);\r\n          } else if (saveBucketSize === 99) {\r\n            saveBucket.push({object: object, cb: callback});\r\n              flushSaveBucket();\r\n          } else {\r\n            ++saveBucketSize;\r\n            saveBucket.push({object: object, cb: callback});\r\n          }\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      var saveBucket = [],\r\n        saveBucketSize = 0,\r\n        saveBucketTimer;\r\n\r\n            function flushSaveBucket(){\r\n                var myBucket = saveBucket;\r\n                saveBucket = [];\r\n                try{\r\n                    clearTimeout(saveBucketTimer);\r\n                } catch(e){\r\n                    //TODO there is no task to do here\r\n                }\r\n                saveBucketTimer = null;\r\n                saveBucketSize = 0;\r\n                if(myBucket.length > 0){\r\n                    insertObjects(myBucket);\r\n                }\r\n            }\r\n\r\n      function insertObjects(objects) {\r\n        var storeObjects = [], i;\r\n        for (i = 0; i < objects.length; i++) {\r\n          storeObjects.push(objects[i].object);\r\n        }\r\n        socket.emit('insertObjects', project, storeObjects, function (err) {\r\n          for (i = 0; i < objects.length; i++) {\r\n            objects[i].cb(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      function _insertObject(object, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('insertObject', project, object, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n            function getInfo(callback){\r\n                ASSERT(typeof callback === 'function');\r\n                if (socketConnected) {\r\n                    var guid = GUID();\r\n                    callbacks[guid] = {\r\n                        cb: callback,\r\n                        to: setTimeout(callbackTimeout, options.timeout, guid)\r\n                    };\r\n                    socket.emit('getInfo', project, function (err,info) {\r\n                        if (callbacks[guid]) {\r\n                            clearTimeout(callbacks[guid].to);\r\n                            delete callbacks[guid];\r\n                            callback(err,info);\r\n                        }\r\n                    });\r\n                } else {\r\n                    callback(new Error(ERROR_DISCONNECTED));\r\n                }\r\n            }\r\n            function setInfo(info,callback){\r\n                ASSERT(typeof info === 'object' && typeof callback === 'function');\r\n                if (socketConnected) {\r\n                    var guid = GUID();\r\n                    callbacks[guid] = {\r\n                        cb: callback,\r\n                        to: setTimeout(callbackTimeout, options.timeout, guid)\r\n                    };\r\n                    socket.emit('setInfo', project, info, function (err) {\r\n                        if (callbacks[guid]) {\r\n                            clearTimeout(callbacks[guid].to);\r\n                            delete callbacks[guid];\r\n                            callback(err);\r\n                        }\r\n                    });\r\n                } else {\r\n                    callback(new Error(ERROR_DISCONNECTED));\r\n                }\r\n            }\r\n\r\n      function findHash(beginning, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('findHash', project, beginning, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function dumpObjects(callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('dumpObjects', project, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function getBranchNames(callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('getBranchNames', project, function (err, names) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err, names);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function getBranchHash(branch, oldhash, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        var guid = GUID();\r\n        if (getBranchHashCallbacks[branch]) {\r\n          //internal hack for recalling\r\n          guid = branch;\r\n          branch = getBranchHashCallbacks[guid].branch;\r\n        } else {\r\n          getBranchHashCallbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid),\r\n            branch: branch,\r\n            oldhash: oldhash,\r\n            project: project\r\n          };\r\n        }\r\n\r\n        if (socketConnected) {\r\n          socket.emit('getBranchHash', project, branch, oldhash, function (err, newhash, forkedhash) {\r\n            if (getBranchHashCallbacks[guid]) {\r\n              clearTimeout(getBranchHashCallbacks[guid].to);\r\n              delete getBranchHashCallbacks[guid];\r\n              callback(err, newhash, forkedhash);\r\n            }\r\n          });\r\n        }\r\n\r\n      }\r\n\r\n      function setBranchHash(branch, oldhash, newhash, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n                    flushSaveBucket();\r\n          socket.emit('setBranchHash', project, branch, oldhash, newhash, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function getCommits(before, number, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('getCommits', project, before, number, function (err, commits) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err, commits);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function makeCommit(parents, roothash, msg, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('makeCommit', project, parents, roothash, msg, function (err) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n\r\n      function getCommonAncestorCommit(commitA, commitB, callback) {\r\n        ASSERT(typeof callback === 'function');\r\n        if (socketConnected) {\r\n          var guid = GUID();\r\n          callbacks[guid] = {\r\n            cb: callback,\r\n            to: setTimeout(callbackTimeout, options.timeout, guid)\r\n          };\r\n          socket.emit('getCommonAncestorCommit', project, commitA, commitB, function (err, commit) {\r\n            if (callbacks[guid]) {\r\n              clearTimeout(callbacks[guid].to);\r\n              delete callbacks[guid];\r\n              callback(err, commit);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error(ERROR_DISCONNECTED));\r\n        }\r\n      }\r\n    }\r\n\r\n    function simpleRequest(parameters, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, 100 * options.timeout, guid)\r\n        };\r\n        socket.emit('simpleRequest', parameters, function (err, resId) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, resId);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function simpleResult(resultId, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, 100 * options.timeout, guid)\r\n        };\r\n        socket.emit('simpleResult', resultId, function (err, result) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, result);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function simpleQuery(workerId, parameters, callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, 100 * options.timeout, guid)\r\n        };\r\n        socket.emit('simpleQuery', workerId, parameters, function (err, result) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, result);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    function getToken(callback) {\r\n      ASSERT(typeof callback === 'function');\r\n      if (socketConnected) {\r\n        var guid = GUID();\r\n        callbacks[guid] = {\r\n          cb: callback,\r\n          to: setTimeout(callbackTimeout, 100 * options.timeout, guid)\r\n        };\r\n        socket.emit('getToken', function (err, result) {\r\n          if (callbacks[guid]) {\r\n            clearTimeout(callbacks[guid].to);\r\n            delete callbacks[guid];\r\n            callback(err, result);\r\n          }\r\n        });\r\n      } else {\r\n        callback(new Error(ERROR_DISCONNECTED));\r\n      }\r\n    }\r\n\r\n    return {\r\n      openDatabase: openDatabase,\r\n      closeDatabase: closeDatabase,\r\n      fsyncDatabase: fsyncDatabase,\r\n      getDatabaseStatus: getDatabaseStatus,\r\n      getProjectNames: getProjectNames,\r\n      getAllowedProjectNames: getAllowedProjectNames,\r\n      getAuthorizationInfo: getAuthorizationInfo,\r\n      deleteProject: deleteProject,\r\n      openProject: openProject,\r\n      simpleRequest: simpleRequest,\r\n      simpleResult: simpleResult,\r\n      simpleQuery: simpleQuery,\r\n      getNextServerEvent: getNextServerEvent,\r\n      getToken: getToken\r\n    };\r\n  }\r\n\r\n  return Database;\r\n});\r\n\r\n/**\r\n * Created by tkecskes on 5/10/2014.\r\n */\r\n;\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/failsafe',[\"util/assert\", \"util/guid\"], function (ASSERT, GUID) {\r\n  \"use strict\";\r\n  var BRANCH_OBJ_ID = '*branch*';\r\n  var BRANCH_STATES = {\r\n    SYNC: 'sync',\r\n    FORKED: 'forked',\r\n    DISCONNECTED: 'disconnected',\r\n    AHEAD: 'ahead'\r\n  };\r\n\r\n  function Database(_database, options) {\r\n    ASSERT(typeof options === \"object\" && typeof _database === \"object\");\r\n    options.failsafe = options.failsafe || \"memory\";\r\n    options.failsafefrequency = options.failsafefrequency || 10000;\r\n    options.timeout = options.timeout || 10000;\r\n\r\n    var exceptionErrors = [], fsId = \"FS\", dbId = options.database || \"noID\", SEPARATOR = \"$\", STATUS_CONNECTED = \"connected\", pendingStorage = {}, storage = null;\r\n\r\n    function loadPending() {\r\n      for (var i = 0; i < storage.length; i++) {\r\n        if (storage.key(i).indexOf(fsId) === 0) {\r\n          var keyArray = storage.key(i).split(SEPARATOR);\r\n          ASSERT(keyArray.length === 4);\r\n          if (keyArray[1] === dbId) {\r\n            var object = JSON.parse(storage.getItem(storage.key(i)));\r\n            pendingStorage[keyArray[2]] = object;\r\n          }\r\n        }\r\n      }\r\n      for (i in pendingStorage) {\r\n        if (!pendingStorage[i][BRANCH_OBJ_ID]) {\r\n          pendingStorage[i][BRANCH_OBJ_ID] = {};\r\n        }\r\n      }\r\n    }\r\n\r\n    function savePending() {\r\n      //TODO maybe some check would be good, but not necessarily\r\n      for (var i in pendingStorage) {\r\n        storage.setItem(fsId + SEPARATOR + dbId + SEPARATOR + i, JSON.stringify(pendingStorage[i]));\r\n      }\r\n    }\r\n\r\n    function openDatabase(callback) {\r\n      if (options.failsafe === \"local\" && localStorage) {\r\n        storage = localStorage;\r\n      } else if (options.failsafe === \"session\" && sessionStorage) {\r\n        storage = sessionStorage;\r\n      } else if (options.failsafe === \"memory\") {\r\n        storage = {\r\n          length: 0,\r\n          keys: [],\r\n          data: {},\r\n          getItem: function (key) {\r\n            ASSERT(typeof key === \"string\");\r\n            return this.data[key];\r\n          },\r\n          setItem: function (key, object) {\r\n            ASSERT(typeof key === \"string\" && typeof object === \"string\");\r\n            this.data[key] = object;\r\n            this.keys.push(key);\r\n            this.length++;\r\n          },\r\n          key: function (index) {\r\n            return this.keys[index];\r\n          }\r\n        };\r\n      }\r\n\r\n      if (storage) {\r\n        loadPending();\r\n        setInterval(savePending, options.failsafefrequency);\r\n        _database.openDatabase(callback);\r\n      } else {\r\n        callback(new Error('cannot initialize fail safe storage'));\r\n      }\r\n    }\r\n\r\n    function openProject(projectName, callback) {\r\n      var project = null;\r\n      var inSync = true;\r\n      _database.openProject(projectName, function (err, proj) {\r\n        if (!err && proj) {\r\n          project = proj;\r\n          if (!pendingStorage[projectName]) {\r\n            pendingStorage[projectName] = {};\r\n            pendingStorage[projectName][BRANCH_OBJ_ID] = {};\r\n          }\r\n          callback(null, {\r\n            fsyncDatabase: project.fsyncDatabase,\r\n            getDatabaseStatus: project.getDatabaseStatus,\r\n            closeProject: project.closeProject,\r\n            loadObject: loadObject,\r\n            insertObject: insertObject,\r\n            getInfo: project.getInfo,\r\n            setInfo: project.setInfo,\r\n            findHash: project.findHash,\r\n            dumpObjects: project.dumpObjects,\r\n            getBranchNames: getBranchNames,\r\n            getBranchHash: getBranchHash,\r\n            setBranchHash: setBranchHash,\r\n            getCommits: project.getCommits,\r\n            makeCommit: project.makeCommit,\r\n            getCommonAncestorCommit: project.getCommonAncestorCommit,\r\n            ID_NAME: project.ID_NAME\r\n          });\r\n        } else {\r\n          callback(err, project);\r\n        }\r\n      });\r\n\r\n      function synchronise(callback) {\r\n        if (pendingStorage[projectName]) {\r\n          var objects = [];\r\n          var count = 0;\r\n          var savingObject = function (object, cb) {\r\n            project.insertObject(object, function (err) {\r\n              if (err) {\r\n                if (!pendingStorage[projectName]) {\r\n                  pendingStorage[projectName] = {};\r\n                }\r\n                pendingStorage[projectName][object._id] = object;\r\n              }\r\n              cb();\r\n            });\r\n          };\r\n          var objectProcessed = function () {\r\n            if (--count === 0) {\r\n              callback();\r\n            }\r\n          };\r\n\r\n          for (var i in pendingStorage[projectName]) {\r\n            if (i !== BRANCH_OBJ_ID) {\r\n              objects.push(pendingStorage[projectName][i]);\r\n            }\r\n          }\r\n          var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID];\r\n          pendingStorage[projectName] = {};\r\n          pendingStorage[projectName][BRANCH_OBJ_ID] = branchObj;\r\n\r\n          //synchronizing the branches\r\n          var aheadBranches = [];\r\n          for (i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n            if (pendingStorage[projectName][BRANCH_OBJ_ID][i].state === BRANCH_STATES.DISCONNECTED) {\r\n              if (pendingStorage[projectName][BRANCH_OBJ_ID][i].local.length > 0) {\r\n                pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.AHEAD;\r\n                //we try to save our local head\r\n                aheadBranches.push(i);\r\n              } else {\r\n                pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.SYNC;\r\n              }\r\n            }\r\n          }\r\n\r\n          count = objects.length + aheadBranches.length;\r\n          for (i = 0; i < aheadBranches.length; i++) {\r\n            synchroniseBranch(aheadBranches[i], objectProcessed);\r\n          }\r\n          for (i = 0; i < objects.length; i++) {\r\n            savingObject(objects[i], objectProcessed);\r\n          }\r\n          if (objects.length === 0) {\r\n            callback();\r\n          }\r\n        } else {\r\n          callback();\r\n        }\r\n      }\r\n\r\n      function synchroniseBranch(branchname, callback) {\r\n        var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branchname];\r\n        project.getBranchHash(branchname, branchObj.local[0], function (err, newhash, forked) {\r\n          if (!err && newhash) {\r\n            if (branchObj.local.indexOf(newhash) !== -1) {\r\n              project.setBranchHash(branchname, newhash, branchObj.local[0], callback);\r\n            } else {\r\n              //we forked\r\n              branchObj.state = BRANCH_STATES.FORKED;\r\n              branchObj.fork = newhash;\r\n              callback(null);\r\n            }\r\n          } else {\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      function errorMode() {\r\n        if (inSync) {\r\n          inSync = false;\r\n          for (var i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n            if (pendingStorage[projectName][BRANCH_OBJ_ID][i].state !== BRANCH_STATES.FORKED) {\r\n              pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.DISCONNECTED;\r\n            }\r\n          }\r\n          var checkIfAvailable = function (err, newstate) {\r\n            if (newstate === STATUS_CONNECTED) {\r\n              synchronise(function () {\r\n                inSync = true;\r\n              });\r\n            } else {\r\n              project.getDatabaseStatus(newstate, checkIfAvailable);\r\n            }\r\n          };\r\n          project.getDatabaseStatus(null, checkIfAvailable);\r\n        }\r\n      }\r\n\r\n      function loadObject(hash, callback) {\r\n        project.loadObject(hash, function (err, object) {\r\n          if (!err && object) {\r\n            callback(null, object);\r\n          } else {\r\n            errorMode();\r\n            if (exceptionErrors.indexOf(err) !== -1) {\r\n              callback(err, object);\r\n            } else {\r\n              if (pendingStorage[projectName] && pendingStorage[projectName][hash]) {\r\n                callback(null, pendingStorage[projectName][hash]);\r\n              } else {\r\n                callback(err, object);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      function insertObject(object, callback) {\r\n        project.insertObject(object, function (err) {\r\n          if (err) {\r\n            errorMode();\r\n            if (exceptionErrors.indexOf(err) !== -1) {\r\n              callback(err);\r\n            } else {\r\n              //TODO have to check if the id is already taken...\r\n              if (!pendingStorage[projectName]) {\r\n                pendingStorage[projectName] = {};\r\n              }\r\n              pendingStorage[projectName][object._id] = object;\r\n              callback(null);\r\n            }\r\n          } else {\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      function getBranchNames(callback) {\r\n        project.getBranchNames(function (err, names) {\r\n          //we need the locally stored names either way\r\n          var locals = {};\r\n          for (var i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n            if (pendingStorage[projectName][BRANCH_OBJ_ID][i].local.length > 0) {\r\n              locals[i] = pendingStorage[projectName][BRANCH_OBJ_ID][i].local[0];\r\n            } else if (pendingStorage[projectName][BRANCH_OBJ_ID][i].fork === null && pendingStorage[projectName][BRANCH_OBJ_ID][i].remote !== null) {\r\n              locals[i] = pendingStorage[projectName][BRANCH_OBJ_ID][i].remote;\r\n            }\r\n          }\r\n\r\n          if (err) {\r\n            errorMode();\r\n            if (exceptionErrors.indexOf(err) !== -1) {\r\n              callback(err);\r\n            } else {\r\n              callback(null, locals);\r\n            }\r\n          } else {\r\n            for (i in names) {\r\n              if (!locals[i]) {\r\n                locals[i] = names[i];\r\n              } else if (locals[i] === pendingStorage[projectName][BRANCH_OBJ_ID][i].remote) {\r\n                locals[i] = names[i];\r\n              }\r\n            }\r\n            callback(err, locals);\r\n          }\r\n        });\r\n      }\r\n\r\n      function getBranchHash(branch, oldhash, callback) {\r\n        if (!pendingStorage[projectName][BRANCH_OBJ_ID][branch]) {\r\n          pendingStorage[projectName][BRANCH_OBJ_ID][branch] = {\r\n            local: [],\r\n            fork: null,\r\n            state: BRANCH_STATES.SYNC,\r\n            remote: null\r\n          };\r\n        }\r\n        var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branch];\r\n\r\n        if (branchObj.state === BRANCH_STATES.SYNC || branchObj.state === BRANCH_STATES.AHEAD) {\r\n          project.getBranchHash(branch, oldhash, function (err, newhash, forkedhash) {\r\n            if (!err && newhash) {\r\n              branchObj.remote = newhash;\r\n            }\r\n            switch (branchObj.state) {\r\n              case BRANCH_STATES.SYNC:\r\n                callback(err, newhash, forkedhash);\r\n                break;\r\n              case BRANCH_STATES.AHEAD:\r\n                if (err) {\r\n                  callback(err, newhash, forkedhash);\r\n                } else {\r\n                  if (newhash && branchObj.local.indexOf(newhash) !== -1) {\r\n                    callback(err, newhash, forkedhash);\r\n                  } else {\r\n                    //we forked!!!\r\n                    branchObj.state = BRANCH_STATES.FORKED;\r\n                    branchObj.fork = newhash;\r\n                    callback(null, branchObj.local[0], branchObj.fork);\r\n                  }\r\n                }\r\n                break;\r\n              case BRANCH_STATES.DISCONNECTED:\r\n                callback(null, branchObj.local[0], branchObj.fork);\r\n                break;\r\n              default://forked\r\n                callback(null, branchObj.local[0], branchObj.fork);\r\n                break;\r\n            }\r\n          });\r\n        } else {\r\n          //served locally\r\n          ASSERT((branchObj.local[0] && branchObj.local[0] !== \"\") || branchObj.remote);\r\n          var myhash = null;\r\n          if (branchObj.local[0]) {\r\n            myhash = branchObj.local[0];\r\n          } else {\r\n            myhash = branchObj.remote;\r\n          }\r\n\r\n          if (myhash === oldhash) {\r\n            setTimeout(function () {\r\n              callback(null, oldhash, branchObj.fork);\r\n            }, options.timeout);\r\n          } else {\r\n            callback(null, myhash, branchObj.fork);\r\n          }\r\n\r\n        }\r\n      }\r\n\r\n      function setBranchHash(branch, oldhash, newhash, callback) {\r\n        ASSERT(typeof oldhash === 'string' && typeof newhash === 'string');\r\n        if (!pendingStorage[projectName][BRANCH_OBJ_ID][branch]) {\r\n          pendingStorage[projectName][BRANCH_OBJ_ID][branch] = {\r\n            local: [],\r\n            fork: null,\r\n            state: BRANCH_STATES.SYNC\r\n          };\r\n        }\r\n        var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branch];\r\n\r\n        var returnFunction = function (err) {\r\n          if (!err) {\r\n            var index = branchObj.local.indexOf(newhash);\r\n            ASSERT(index !== -1);\r\n            branchObj.local.splice(index, branchObj.local.length - index);\r\n            if (branchObj.local.length === 0) {\r\n              branchObj.state = BRANCH_STATES.SYNC;\r\n            }\r\n          } else {\r\n            /*//we go to disconnected state\r\n             ASSERT(branchObj.local.length > 0);\r\n             if(branchObj.state !== BRANCH_STATES.DISCONNECTED){\r\n             branchObj.state = BRANCH_STATES.DISCONNECTED;\r\n             var reSyncBranch = function(err,newhash,forkedhash){\r\n             if(!err && newhash){\r\n             if(branchObj.local.indexOf(newhash) === -1){\r\n             //we forked\r\n             branchObj.fork = newhash;\r\n             branchObj.state = BRANCH_STATES.FORKED;\r\n             } else {\r\n             setBranchHash(branch,newhash,branchObj.local[0],function(){});\r\n             }\r\n             } else {\r\n             //timeout or something not correct, so we should retry\r\n             project.getBranchHash(branch,branchObj.local[0],reSyncBranch);\r\n             }\r\n             };\r\n             project.getBranchHash(branch,branchObj.local[0],reSyncBranch);\r\n             }*/\r\n            //we have ancountered an error\r\n            errorMode();\r\n          }\r\n        };\r\n\r\n        switch (branchObj.state) {\r\n          case BRANCH_STATES.SYNC:\r\n            ASSERT(branchObj.local.length === 0);\r\n            branchObj.state = BRANCH_STATES.AHEAD;\r\n            branchObj.local = [newhash, oldhash];\r\n            project.setBranchHash(branch, oldhash, newhash, returnFunction);\r\n            callback(null);\r\n            return;\r\n          case BRANCH_STATES.AHEAD:\r\n            ASSERT(branchObj.local.length > 0);\r\n            if (oldhash === branchObj.local[0]) {\r\n              branchObj.local.unshift(newhash);\r\n              project.setBranchHash(branch, oldhash, newhash, returnFunction);\r\n              callback(null);\r\n            } else {\r\n              callback(new Error(\"branch hash mismatch\"));\r\n            }\r\n            return;\r\n          case BRANCH_STATES.DISCONNECTED:\r\n            /*ASSERT(branchObj.local.length > 0 || branchObj.remote);\r\n             if(oldhash === branchObj.local[0] || oldhash === branchObj.remote){\r\n             if(branchObj.local.length === 0){\r\n             branchObj.local = [newhash,oldhash];\r\n             } else {\r\n             branchObj.local.unshift(newhash);\r\n             }\r\n             callback(null);\r\n             } else {\r\n             callback(new Error(\"branch hash mismatch\"));\r\n             }*/\r\n            if (branchObj.local.length === 0) {\r\n              branchObj.local = [newhash, oldhash];\r\n              callback(null);\r\n            } else {\r\n              if (oldhash === branchObj.local[0]) {\r\n                branchObj.local.unshift(newhash);\r\n                callback(null);\r\n              } else {\r\n                callback(new Error(\"branch hash mismatch\"));\r\n              }\r\n            }\r\n            return;\r\n          default: //BRANCH_STATES.FORKED\r\n            ASSERT(branchObj.local.length > 0 && branchObj.fork);\r\n            if (oldhash === branchObj.local[0]) {\r\n              if (branchObj.fork === newhash) {\r\n                //clearing the forked leg\r\n                branchObj.fork = null;\r\n                branchObj.state = BRANCH_STATES.SYNC;\r\n                branchObj.local = [];\r\n              } else {\r\n                branchObj.local.unshift(newhash);\r\n              }\r\n              callback(null);\r\n            } else {\r\n              callback(new Error(\"branch hash mismatch\"));\r\n            }\r\n            return;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      openDatabase: openDatabase,\r\n      closeDatabase: _database.closeDatabase,\r\n      fsyncDatabase: _database.fsyncDatabase,\r\n      getProjectNames: _database.getProjectNames,\r\n      getAllowedProjectNames: _database.getAllowedProjectNames,\r\n      getAuthorizationInfo: _database.getAuthorizationInfo,\r\n      getDatabaseStatus: _database.getDatabaseStatus,\r\n      openProject: openProject,\r\n      deleteProject: _database.deleteProject,\r\n      simpleRequest: _database.simpleRequest,\r\n      simpleResult: _database.simpleResult,\r\n      simpleQuery: _database.simpleQuery,\r\n      getNextServerEvent: _database.getNextServerEvent,\r\n      getToken: _database.getToken\r\n    };\r\n  }\r\n\r\n  return Database;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/hashcheck',[ \"util/assert\", \"util/zssha1\", \"util/canon\" ], function (ASSERT, SHA1, CANON) {\r\n  \"use strict\";\r\n\r\n  var zsSHA = new SHA1();\r\n\r\n  function Database(_innerDb, options) {\r\n    ASSERT(typeof options === \"object\" && typeof _innerDb === \"object\");\r\n    var database = {};\r\n    for (var i in _innerDb) {\r\n      database[i] = _innerDb[i];\r\n    }\r\n\r\n    //we have to modify the openProject function\r\n    database.openProject = function (projectName, callback) {\r\n      _innerDb.openProject(projectName, function (err, innerProject) {\r\n        if (!err && innerProject) {\r\n          var project = {};\r\n          for (var i in innerProject) {\r\n            project[i] = innerProject[i];\r\n          }\r\n\r\n          //we add the hash check to insertObject\r\n          project.insertObject = function (object, cb) {\r\n            var inHash = object[project.ID_NAME];\r\n            object[project.ID_NAME] = \"\";\r\n            var checkHash = \"#\" + zsSHA.getHash(CANON.stringify(object));\r\n            object[project.ID_NAME] = inHash;\r\n\r\n            if (inHash !== checkHash) {\r\n              cb(\"wrong hash: expeced - \" + checkHash + \", received - \" + inHash);\r\n            } else {\r\n              innerProject.insertObject(object, cb);\r\n            }\r\n          };\r\n\r\n          callback(null, project);\r\n\r\n        } else {\r\n          callback(err);\r\n        }\r\n      });\r\n    };\r\n\r\n    return database;\r\n  }\r\n\r\n  return Database;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n * \r\n * Author: Miklos Maroti\r\n */\r\n\r\ndefine('storage/cache',[ \"util/assert\" ], function (ASSERT) {\r\n\t\"use strict\";\r\n\r\n\tvar Lock = function () {\r\n\t\tvar waiters = [];\r\n\r\n\t\treturn {\r\n\t\t\tlock: function (func) {\r\n\t\t\t\twaiters.push(func);\r\n\t\t\t\tif (waiters.length === 1) {\r\n\t\t\t\t\tfunc();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tunlock: function () {\r\n                waiters.shift();\r\n\t\t\t\tif (waiters.length >= 1) {\r\n\t\t\t\t\tvar func = waiters[0];\r\n\t\t\t\t\tfunc();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\tvar Database = function (database, options) {\r\n\t\tASSERT(typeof database === \"object\" && typeof options === \"object\");\r\n\r\n\t\toptions.cache = options.cache || 2000;\r\n\r\n\t\tvar projects = {};\r\n\t\tvar dlock = new Lock();\r\n\r\n\t\tfunction openProject (name, callback) {\r\n\t\t\tASSERT(typeof name === \"string\" && typeof callback === \"function\");\r\n\r\n\t\t\tdlock.lock(function () {\r\n\t\t\t\tif (typeof projects[name] !== \"undefined\") {\r\n\t\t\t\t\tprojects[name].reopenProject(callback);\r\n\t\t\t\t\tdlock.unlock();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdatabase.openProject(name, function (err, project) {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\tcallback(err);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tproject = wrapProject(name, project);\r\n\t\t\t\t\t\t\tprojects[name] = project;\r\n\t\t\t\t\t\t\tproject.reopenProject(callback);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdlock.unlock();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction closeDatabase (callback) {\r\n\t\t\tdlock.lock(function () {\r\n\t\t\t\tvar n;\r\n\t\t\t\tfor (n in projects) {\r\n\t\t\t\t\tprojects[n].abortProject();\r\n\t\t\t\t}\r\n\t\t\t\tprojects = {};\r\n\t\t\t\tdatabase.closeDatabase(callback);\r\n\t\t\t\tdlock.unlock();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction deleteProject (name, callback) {\r\n\t\t\tif (typeof projects[name] !== \"undefined\") {\r\n\t\t\t\tprojects[name].deleteProject();\r\n\t\t\t}\r\n\r\n\t\t\tdatabase.deleteProject(name, callback);\r\n\t\t}\r\n\r\n\t\tfunction wrapProject (name, project) {\r\n\t\t\tvar ID_NAME = project.ID_NAME;\r\n\r\n\t\t\tvar refcount = 0;\r\n\t\t\tvar branches = {};\r\n\t\t\tvar missing = {};\r\n\t\t\tvar backup = {};\r\n\t\t\tvar cache = {};\r\n\t\t\tvar cacheSize = 0;\r\n\r\n\t\t\tfunction tryFreeze(o) {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tObject.freeze(o);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e){\r\n\t\t\t\t\t//TODO find the proper answer why this can occur\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction maybeFreeze(o) {\r\n\t\t\t\tif (o !== null && typeof o === \"object\") {\r\n\t\t\t\t\tdeepFreeze(o);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction deepFreeze (obj) {\r\n\t\t\t\tASSERT(typeof obj === \"object\");\r\n\r\n\t\t\t\ttryFreeze(obj);\r\n\r\n\t\t\t\tvar key;\r\n\t\t\t\tfor (key in obj) {\r\n\t\t\t\t\tmaybeFreeze(obj[key]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction cacheInsert (key, obj) {\r\n\t\t\t\tASSERT(typeof cache[key] === \"undefined\" && obj[ID_NAME] === key);\r\n\r\n\t\t\t\tdeepFreeze(obj);\r\n\t\t\t\tcache[key] = obj;\r\n\r\n\t\t\t\tif (++cacheSize >= options.cache) {\r\n\t\t\t\t\tbackup = cache;\r\n\t\t\t\t\tcache = {};\r\n\t\t\t\t\tcacheSize = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction loadObject (key, callback) {\r\n\t\t\t\tASSERT(typeof key === \"string\" && typeof callback === \"function\");\r\n\t\t\t\tASSERT(project !== null);\r\n\r\n\t\t\t\tvar obj = cache[key];\r\n\t\t\t\tif (typeof obj === \"undefined\") {\r\n\t\t\t\t\tobj = backup[key];\r\n\t\t\t\t\tif (typeof obj === \"undefined\") {\r\n\t\t\t\t\t\tobj = missing[key];\r\n\t\t\t\t\t\tif (typeof obj === \"undefined\") {\r\n\t\t\t\t\t\t\tobj = [ callback ];\r\n\t\t\t\t\t\t\tmissing[key] = obj;\r\n\t\t\t\t\t\t\tproject.loadObject(key, function (err, obj2) {\r\n\t\t\t\t\t\t\t\tASSERT(typeof obj2 === \"object\" || typeof obj2 === \"undefined\");\r\n\r\n\t\t\t\t\t\t\t\tif (obj.length !== 0) {\r\n\t\t\t\t\t\t\t\t\tASSERT(missing[key] === obj);\r\n\r\n\t\t\t\t\t\t\t\t\tdelete missing[key];\r\n\t\t\t\t\t\t\t\t\tif (!err && obj2) {\r\n\t\t\t\t\t\t\t\t\t\tcacheInsert(key, obj2);\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tvar cb;\r\n\t\t\t\t\t\t\t\t\twhile ((cb = obj.pop())) {\r\n\t\t\t\t\t\t\t\t\t\tcb(err, obj2);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tobj.push(callback);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcacheInsert(key, obj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tASSERT(typeof obj === \"object\" && obj !== null && obj[ID_NAME] === key);\r\n\t\t\t\tcallback(null, obj);\r\n\t\t\t}\r\n\r\n\t\t\tfunction insertObject (obj, callback) {\r\n\t\t\t\tASSERT(typeof obj === \"object\" && obj !== null && typeof callback === \"function\");\r\n\r\n\t\t\t\tvar key = obj[ID_NAME];\r\n\t\t\t\tASSERT(typeof key === \"string\");\r\n\r\n\t\t\t\tif (typeof cache[key] !== \"undefined\") {\r\n\t\t\t\t\tcallback(null);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar item = backup[key];\r\n\t\t\t\t\tcacheInsert(key, obj);\r\n\r\n\t\t\t\t\tif (typeof item !== \"undefined\") {\r\n\t\t\t\t\t\tcallback(null);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\titem = missing[key];\r\n\t\t\t\t\t\tif (typeof item !== \"undefined\") {\r\n\t\t\t\t\t\t\tdelete missing[key];\r\n\r\n\t\t\t\t\t\t\tvar cb;\r\n\t\t\t\t\t\t\twhile ((cb = item.pop())) {\r\n\t\t\t\t\t\t\t\tcb(null, obj);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tproject.insertObject(obj, callback);\r\n\t\t\t}\r\n\r\n\t\t\tfunction abortProject (callback) {\r\n\t\t\t\tif (project !== null) {\r\n\t\t\t\t\tvar p = project;\r\n\t\t\t\t\tproject = null;\r\n\t\t\t\t\tdelete projects[name];\r\n\t\t\t\t\tdeleteProject();\r\n\t\t\t\t\tp.closeProject(callback);\r\n\t\t\t\t} else if (typeof callback === \"function \") {\r\n\t\t\t\t\tcallback(null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction closeProject (callback) {\r\n\t\t\t\tASSERT(refcount >= 1);\r\n\r\n\t\t\t\tif (--refcount === 0) {\r\n\t\t\t\t\tabortProject(callback);\r\n\t\t\t\t} else if (typeof callback === \"function\") {\r\n\t\t\t\t\tcallback(null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction deleteProject () {\r\n\t\t\t\tvar key, callbacks, cb, err = new Error(\"cache closed\");\r\n\t\t\t\tfor (key in missing) {\r\n\t\t\t\t\tcallbacks = missing[key];\r\n\t\t\t\t\twhile ((cb = callbacks.pop())) {\r\n\t\t\t\t\t\tcb(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (key in branches) {\r\n\t\t\t\t\tcallbacks = branches[key];\r\n\t\t\t\t\twhile ((cb = callbacks.pop())) {\r\n\t\t\t\t\t\tcb(err);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbranches = {};\r\n\t\t\t\tmissing = {};\r\n\t\t\t\tbackup = {};\r\n\t\t\t\tcache = {};\r\n\t\t\t\tcacheSize = 0;\r\n\t\t\t}\r\n\r\n\t\t\tfunction getBranchHash (name, oldhash, callback) {\r\n\t\t\t\tASSERT(typeof name === \"string\" && typeof callback === \"function\");\r\n\t\t\t\tASSERT(typeof oldhash === \"string\" || oldhash === null);\r\n\r\n\t\t\t\tvar tag = name + \"@\" + oldhash;\r\n\t\t\t\tvar branch = branches[tag];\r\n\t\t\t\tif (typeof branch === \"undefined\") {\r\n\t\t\t\t\tbranch = [ callback ];\r\n\t\t\t\t\tbranches[tag] = branch;\r\n\r\n\t\t\t\t\tproject.getBranchHash(name, oldhash, function (err, newhash, forkedhash) {\r\n\t\t\t\t\t\tif (branches[tag] === branch) {\r\n\t\t\t\t\t\t\tvar cb;\r\n\t\t\t\t\t\t\tdelete branches[tag];\r\n\r\n\t\t\t\t\t\t\twhile ((cb = branch.pop())) {\r\n\t\t\t\t\t\t\t\tcb(err, newhash, forkedhash);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbranch.push(callback);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction setBranchHash (name, oldhash, newhash, callback) {\r\n\t\t\t\tASSERT(typeof name === \"string\" && typeof oldhash === \"string\");\r\n\t\t\t\tASSERT(typeof newhash === \"string\" && typeof callback === \"function\");\r\n\r\n\t\t\t\tproject.setBranchHash(name, oldhash, newhash, function (err) {\r\n\t\t\t\t\tif (!err) {\r\n\t\t\t\t\t\tvar prefix = name + \"@\", tag;\r\n\t\t\t\t\t\tfor (tag in branches) {\r\n\t\t\t\t\t\t\tif (tag.substr(0, prefix.length) === prefix) {\r\n\t\t\t\t\t\t\t\tvar cb, branch = branches[tag];\r\n\t\t\t\t\t\t\t\tdelete branches[tag];\r\n\r\n\t\t\t\t\t\t\t\twhile ((cb = branch.pop())) {\r\n\t\t\t\t\t\t\t\t\tcb(err, newhash, null);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcallback(err);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tfunction reopenProject (callback) {\r\n\t\t\t\tASSERT(project !== null && refcount >= 0 && typeof callback === \"function\");\r\n\r\n\t\t\t\t++refcount;\r\n\t\t\t\tcallback(null, {\r\n\t\t\t\t\tfsyncDatabase: project.fsyncDatabase,\r\n\t\t\t\t\tgetDatabaseStatus: project.getDatabaseStatus,\r\n\t\t\t\t\tcloseProject: closeProject,\r\n\t\t\t\t\tloadObject: loadObject,\r\n\t\t\t\t\tinsertObject: insertObject,\r\n\t\t\t\t\tgetInfo: project.getInfo,\r\n\t\t\t\t\tsetInfo: project.setInfo,\r\n\t\t\t\t\tfindHash: project.findHash,\r\n\t\t\t\t\tdumpObjects: project.dumpObjects,\r\n\t\t\t\t\tgetBranchNames: project.getBranchNames,\r\n\t\t\t\t\tgetBranchHash: getBranchHash,\r\n\t\t\t\t\tsetBranchHash: setBranchHash,\r\n          //getBranchHash: project.getBranchHash,\r\n          //setBranchHash: project.setBranchHash,\r\n\t\t\t\t\tgetCommits: project.getCommits,\r\n\t\t\t\t\tmakeCommit: project.makeCommit,\r\n          getCommonAncestorCommit: project.getCommonAncestorCommit,\r\n\t\t\t\t\tID_NAME: project.ID_NAME\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\treopenProject: reopenProject,\r\n\t\t\t\tabortProject: abortProject,\r\n\t\t\t\tdeleteProject: deleteProject\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\topenDatabase: database.openDatabase,\r\n\t\t\tcloseDatabase: closeDatabase,\r\n\t\t\tfsyncDatabase: database.fsyncDatabase,\r\n\t\t\tgetDatabaseStatus: database.getDatabaseStatus,\r\n\t\t\tgetProjectNames: database.getProjectNames,\r\n            getAllowedProjectNames: database.getAllowedProjectNames,\r\n            getAuthorizationInfo: database.getAuthorizationInfo,\r\n\t\t\topenProject: openProject,\r\n\t\t\tdeleteProject: deleteProject,\r\n            simpleRequest: database.simpleRequest,\r\n            simpleResult: database.simpleResult,\r\n            simpleQuery: database.simpleQuery,\r\n            getNextServerEvent: database.getNextServerEvent,\r\n            getToken: database.getToken\r\n\t\t};\r\n\t};\r\n\r\n\treturn Database;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/commit',[ \"util/assert\", \"util/key\", \"util/canon\" ], function (ASSERT, GENKEY, CANON) {\r\n  \"use strict\";\r\n  var HASH_REGEXP = new RegExp(\"^#[0-9a-zA-Z_]*$\");\r\n\r\n  function Database(_database, _options) {\r\n    _options = _options || {};\r\n    ASSERT(typeof _database === \"object\");\r\n\r\n    function openProject(projectName, callback) {\r\n\r\n      var _project = null;\r\n      _database.openProject(projectName, function (err, proj) {\r\n        if (!err && proj) {\r\n          _project = proj;\r\n          callback(null, {\r\n            fsyncDatabase: _project.fsyncDatabase,\r\n            closeProject: _project.closeProject,\r\n            loadObject: _project.loadObject,\r\n            insertObject: _project.insertObject,\r\n\t\t\t\t\t\tgetInfo: _project.getInfo,\r\n\t\t\t\t\t\tsetInfo: _project.setInfo,\r\n            findHash: _project.findHash,\r\n            dumpObjects: _project.dumpObjects,\r\n            getBranchNames: _project.getBranchNames,\r\n            getBranchHash: _project.getBranchHash,\r\n            setBranchHash: _project.setBranchHash,\r\n            getCommits: _project.getCommits,\r\n            getCommonAncestorCommit: _project.getCommonAncestorCommit,\r\n            makeCommit: makeCommit,\r\n            setUser: setUser,\r\n            ID_NAME: _project.ID_NAME\r\n          });\r\n        } else {\r\n          callback(err, proj);\r\n        }\r\n      });\r\n\r\n      function makeCommit(parents, roothash, msg, callback) {\r\n        ASSERT(HASH_REGEXP.test(roothash));\r\n        ASSERT(typeof callback === 'function');\r\n\r\n        parents = parents || [];\r\n        msg = msg || \"n/a\";\r\n\r\n        var commitObj = {\r\n          root: roothash,\r\n          parents: parents,\r\n          updater: [ _options.user ],\r\n          time: (new Date()).getTime(),\r\n          message: msg,\r\n          type: \"commit\"\r\n        };\r\n\r\n\t\t\t\tvar id = '#' + GENKEY(commitObj);\r\n        commitObj[_project.ID_NAME] = id;\r\n\r\n        _project.insertObject(commitObj, function (err) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            callback(null, id);\r\n          }\r\n        });\r\n\r\n        return id;\r\n      }\r\n\r\n      function setUser(userId) {\r\n        if (typeof userId === 'string') {\r\n          _options.user = userId;\r\n        }\r\n        ;\r\n      }\r\n    }\r\n\r\n    return {\r\n      openDatabase: _database.openDatabase,\r\n      closeDatabase: _database.closeDatabase,\r\n      fsyncDatabase: _database.fsyncDatabase,\r\n      getProjectNames: _database.getProjectNames,\r\n      getAllowedProjectNames: _database.getAllowedProjectNames,\r\n      getAuthorizationInfo: _database.getAuthorizationInfo,\r\n      getDatabaseStatus: _database.getDatabaseStatus,\r\n      openProject: openProject,\r\n      deleteProject: _database.deleteProject,\r\n      simpleRequest: _database.simpleRequest,\r\n      simpleResult: _database.simpleResult,\r\n      simpleQuery: _database.simpleQuery,\r\n      getNextServerEvent: _database.getNextServerEvent,\r\n      getToken: _database.getToken\r\n    };\r\n  }\r\n\r\n  return Database;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012-2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/log',[ \"util/assert\" ], function (ASSERT) {\r\n  \"use strict\";\r\n\r\n  function Database(_database, options) {\r\n    ASSERT(typeof options === \"object\" && typeof _database === \"object\");\r\n    options.log = options.log || {\r\n      debug: function (msg) {\r\n        console.log(\"DEBUG - \" + msg);\r\n      },\r\n      error: function (msg) {\r\n        console.log(\"ERROR - \" + msg);\r\n      }\r\n    };\r\n    var logger = options.log;\r\n\r\n    function openDatabase(callback) {\r\n      logger.debug('openDatabase()');\r\n      _database.openDatabase(callback);\r\n    }\r\n\r\n    function closeDatabase(callback) {\r\n      logger.debug('closeDatabase()');\r\n      _database.closeDatabase(callback);\r\n    }\r\n\r\n    function fsyncDatabase(callback) {\r\n      logger.debug('fsyncDatabase()');\r\n      _database.fsyncDatabase(callback);\r\n    }\r\n\r\n    function getProjectNames(callback) {\r\n      logger.debug('getProjectNames()');\r\n      _database.getProjectNames(callback);\r\n    }\r\n\r\n    function getAllowedProjectNames(callback) {\r\n      logger.debug('getAllowedProjectNames()');\r\n      _database.getAllowedProjectNames(callback);\r\n    }\r\n\r\n    function getAuthorizationInfo(name, callback) {\r\n      logger.debug('getAuthorizationInfo(' + name + ')');\r\n      _database.getAuthorizationInfo(name, callback);\r\n    }\r\n\r\n    function deleteProject(project, callback) {\r\n      logger.debug('deleteProject(' + project + \")\");\r\n      _database.deleteProject(project, callback);\r\n    }\r\n\r\n    function getDatabaseStatus(oldstatus, callback) {\r\n      logger.debug('getDatabaseStatus(' + oldstatus + \")\");\r\n      _database.getDatabaseStatus(oldstatus, callback);\r\n    }\r\n\r\n    function openProject(projectName, callback) {\r\n      logger.debug('openProject(' + projectName + \")\");\r\n      var project = null;\r\n      _database.openProject(projectName, function (err, proj) {\r\n        if (!err && proj) {\r\n          project = proj;\r\n          callback(null, {\r\n            fsyncDatabase: fsyncDatabase,\r\n            closeProject: closeProject,\r\n            loadObject: loadObject,\r\n\t\t\t\t\t\tgetInfo: getInfo,\r\n\t\t\t\t\t\tsetInfo: setInfo,\r\n            insertObject: insertObject,\r\n            findHash: findHash,\r\n            dumpObjects: dumpObjects,\r\n            getBranchNames: getBranchNames,\r\n            getBranchHash: getBranchHash,\r\n            setBranchHash: setBranchHash,\r\n            getCommits: getCommits,\r\n            getCommonAncestorCommit: getCommonAncestorCommit,\r\n            makeCommit: makeCommit,\r\n            setUser: project.setUser,\r\n            ID_NAME: project.ID_NAME\r\n          });\r\n        } else {\r\n          callback(err, proj);\r\n        }\r\n      });\r\n\r\n      function fsyncDatabase(callback) {\r\n        logger.debug(projectName + '.fsyncDatabase()');\r\n        project.fsyncDatabase(callback);\r\n      }\r\n\r\n      function closeProject(callback) {\r\n        logger.debug(projectName + '.closeProject()');\r\n        project.closeProject(callback);\r\n      }\r\n\r\n      function insertObject(object, callback) {\r\n        logger.debug(projectName + '.insertObject(' + object[project.ID_NAME] + \")\");\r\n        project.insertObject(object, callback);\r\n      }\r\n\r\n      function loadObject(hash, callback) {\r\n        logger.debug(projectName + '.loadObject(' + hash + \")\");\r\n        project.loadObject(hash, callback);\r\n\t\t\t}\r\n\r\n\t\t\tfunction getInfo (callback){\r\n\t\t\t\tlogger.debug(projectName + '.getInfo()');\r\n\t\t\t\tproject.getInfo(callback);\r\n\t\t\t}\r\n\r\n\t\t\tfunction setInfo (info,callback){\r\n\t\t\t\tlogger.debug(projectName + '.setInfo('+JSON.stringify(info)+')');\r\n\t\t\t\tproject.setInfo(info,callback);\r\n      }\r\n\r\n      function findHash(beginning, callback) {\r\n        logger.debug(projectName + \".findHash(\" + beginning + \")\");\r\n        project.findHash(beginning, callback);\r\n      }\r\n\r\n      function dumpObjects(callback) {\r\n        logger.debug(projectName + \"dumpObjects()\");\r\n        project.dumpObjects(callback);\r\n      }\r\n\r\n      function getBranchNames(callback) {\r\n        logger.debug(projectName + '.getBranchNames()');\r\n        project.getBranchNames(callback);\r\n      }\r\n\r\n      function getBranchHash(branch, oldhash, callback) {\r\n        logger.debug(projectName + '.getBranchHash(' + branch + ',' + oldhash + ')');\r\n        project.getBranchHash(branch, oldhash, function (err, newhash, forked) {\r\n          logger.debug(projectName + '.getBranchHash(' + branch + ',' + oldhash + ')->(' + JSON.stringify(err) + ',' + newhash + ',' + forked + ')');\r\n          callback(err, newhash, forked);\r\n        });\r\n      }\r\n\r\n      function setBranchHash(branch, oldhash, newhash, callback) {\r\n        logger.debug(projectName + '.setBranchHash(' + branch + ',' + oldhash + ',' + newhash + ')');\r\n        project.setBranchHash(branch, oldhash, newhash, function (err) {\r\n          logger.debug(projectName + '.setBranchHash(' + branch + ',' + oldhash + ',' + newhash + ') ->(' + JSON.stringify(err) + ')');\r\n          callback(err);\r\n        });\r\n      }\r\n\r\n      function getCommits(before, number, callback) {\r\n        logger.debug(projectName + '.getCommits(' + before + ',' + number + ')');\r\n        project.getCommits(before, number, callback);\r\n      }\r\n\r\n      function makeCommit(parents, roothash, msg, callback) {\r\n        logger.debug(projectName + '.makeCommit(' + parents + ',' + roothash + ',' + msg + ')');\r\n        return project.makeCommit(parents, roothash, msg, callback);\r\n      }\r\n\r\n      function getCommonAncestorCommit(commitA, commitB, callback) {\r\n        logger.debug(projectName + '.getCommonAncestorCommit(' + commitA + ',' + commitB + ')');\r\n        project.getCommonAncestorCommit(commitA, commitB, function (err, commit) {\r\n          logger.debug(projectName + '.getCommonAncestorCommit(' + commitA + ',' + commitB + ') ->(' + JSON.stringify(err) + ',' + commit + ')');\r\n          callback(err, commit);\r\n        });\r\n      }\r\n    }\r\n\r\n    function simpleRequest(parameters, callback) {\r\n      logger.debug('simpleRequest()');\r\n      _database.simpleRequest(parameters, callback);\r\n    }\r\n\r\n    function simpleResult(resultId, callback) {\r\n      logger.debug('simpleResult(' + resultId + ')');\r\n      _database.simpleResult(resultId, callback);\r\n    }\r\n\r\n    function simpleQuery(workerId, parameters, callback) {\r\n      logger.debug('simpleQuery(' + workerId + ',' + parameters + ')');\r\n      _database.simpleResult(resultId, callback);\r\n    }\r\n\r\n    function getToken(callback) {\r\n      logger.debug('getToken()');\r\n      _database.getToken(callback);\r\n    }\r\n\r\n    function getNextServerEvent(latestGuid, callback) {\r\n      logger.debug('getNextServerEvent(' + latestGuid + \")\");\r\n      _database.getNextServerEvent(latestGuid, callback);\r\n    }\r\n\r\n    return {\r\n      openDatabase: openDatabase,\r\n      closeDatabase: closeDatabase,\r\n      fsyncDatabase: fsyncDatabase,\r\n      getProjectNames: getProjectNames,\r\n      getAllowedProjectNames: getAllowedProjectNames,\r\n      getAuthorizationInfo: getAuthorizationInfo,\r\n      getDatabaseStatus: getDatabaseStatus,\r\n      openProject: openProject,\r\n      deleteProject: deleteProject,\r\n      simpleRequest: simpleRequest,\r\n      simpleResult: simpleResult,\r\n      simpleQuery: simpleQuery,\r\n      getNextServerEvent: getNextServerEvent,\r\n      getToken: getToken\r\n    };\r\n  }\r\n\r\n  return Database;\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\n\r\ndefine('storage/clientstorage',['storage/client', 'storage/failsafe', 'storage/hashcheck', 'storage/cache', 'storage/commit', 'storage/log'], function (Client, Failsafe, Hashcheck, Cache, Commit, Log) {\r\n  \"use strict\";\r\n  function client(options) {\r\n    //return  new Log(new Commit(new Cache(new Failsafe(new Client(options),options),options),options),options);\r\n    return  new Commit(new Cache(new Failsafe(new Client(options), options), options), options);\r\n  }\r\n\r\n\r\n  return client;\r\n});\r\n\r\n\r\n\n",
    "/*\r\n * Copyright (C) 2012 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Robert Kereskenyi\r\n */\r\n\"use strict\";\r\n\r\n/*\r\n * -------- LOGMANAGER -------\r\n */\r\n\r\ndefine('logManager',[], function () {\r\n\r\n\tvar logLevels = {\r\n\t\t\"ALL\": 5,\r\n\t\t\"DEBUG\": 4,\r\n\t\t\"INFO\": 3,\r\n\t\t\"WARNING\": 2,\r\n\t\t\"ERROR\": 1,\r\n\t\t\"OFF\": 0\r\n\t},\r\n    logColors = {\r\n\t\t\"DEBUG\": \"90\",\r\n\t\t\"INFO\": \"36\",\r\n\t\t\"WARNING\": \"33\",\r\n\t\t\"ERROR\": \"31\"\r\n\t},\r\n    currentLogLevel = logLevels.WARNING,\r\n    useColors = false,\r\n    excludedComponents = [],\r\n    FS = null,\r\n    logFilePath = null,\r\n    logFileBuffer = [],\r\n    Logger,\r\n    isComponentAllowedToLog,\r\n    printLogMessageToFile,\r\n    logMessage;\r\n\r\n\tisComponentAllowedToLog = function (componentName) {\r\n\t\tvar i, excludedComponentName;\r\n\r\n\t\tfor (i = 0; i < excludedComponents.length; i += 1) {\r\n\t\t\texcludedComponentName = excludedComponents[i];\r\n\r\n\t\t\tif (excludedComponentName.substr(-1) === \"*\") {\r\n\t\t\t\texcludedComponentName = excludedComponentName.substring(0, excludedComponentName.length - 1);\r\n\r\n\t\t\t\tif (componentName.substring(0, excludedComponentName.length) === excludedComponentName) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (excludedComponentName === componentName) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tprintLogMessageToFile = function () {\r\n\t\tvar message = logFileBuffer[0];\r\n\t\tif (message) {\r\n\t\t\tFS.appendFile(logFilePath, message, function (err) {\r\n\t\t\t\tlogFileBuffer.shift();\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\t//something wrong so we should fallback to console logging\r\n\t\t\t\t\tlogFilePath = null;\r\n\t\t\t\t\tlogFileBuffer = [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (logFileBuffer.length > 0) {\r\n\t\t\t\t\t\tprintLogMessageToFile();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tlogMessage = function (level, componentName, msg) {\r\n\t\tvar logTime = new Date(), logTimeStr = (logTime.getHours() < 10) ? \"0\" + logTime.getHours() : logTime.getHours(), levelStr = level, concreteLogger = console.log;\r\n\r\n\t\t//logTimeString\r\n\t\tlogTimeStr += \":\";\r\n\t\tlogTimeStr += (logTime.getMinutes() < 10) ? \"0\" + logTime.getMinutes() : logTime.getMinutes();\r\n\t\tlogTimeStr += \":\";\r\n\t\tlogTimeStr += (logTime.getSeconds() < 10) ? \"0\" + logTime.getSeconds() : logTime.getSeconds();\r\n\t\tlogTimeStr += \".\";\r\n\t\tlogTimeStr += (logTime.getMilliseconds() < 10) ? \"00\" + logTime.getMilliseconds() : ((logTime.getMilliseconds() < 100) ? \"0\" + logTime.getMilliseconds() : logTime.getMilliseconds());\r\n\r\n\t\t//levelStr\r\n\t\tif (useColors === true && logFilePath === null) {\r\n\t\t\tlevelStr = '\\u001B[' + logColors[level] + 'm' + level + '\\u001B[39m';\r\n\t\t}\r\n\r\n\t\tif (isComponentAllowedToLog(componentName) === true) {\r\n\t\t\tif (logFilePath) {\r\n\t\t\t\tmsg = levelStr + \" - \" + logTimeStr + \" [\" + componentName + \"] - \" + msg + \"\\n\";\r\n\t\t\t\tif (logFileBuffer.length === 0) {\r\n\t\t\t\t\tlogFileBuffer.push(msg);\r\n\t\t\t\t\tprintLogMessageToFile();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlogFileBuffer.push(msg);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t//console logging\r\n\t\t\t\t//log only what meets configuration\r\n\t\t\t\tif (logLevels[level] <= currentLogLevel) {\r\n\t\t\t\t\t//see whether console exists\r\n\t\t\t\t\tif (console && console.log) {\r\n\r\n\t\t\t\t\t\tif ((logLevels[level] === logLevels.ERROR) && (console.error)) {\r\n\t\t\t\t\t\t\tconcreteLogger = console.error;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ((logLevels[level] === logLevels.WARNING) && (console.warn)) {\r\n\t\t\t\t\t\t\tconcreteLogger = console.warn;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ((logLevels[level] === logLevels.INFO) && (console.info)) {\r\n\t\t\t\t\t\t\tconcreteLogger = console.info;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tconcreteLogger.call(console, levelStr + \" - \" + logTimeStr + \" [\" + componentName + \"] - \" + msg);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tLogger = function (componentName) {\r\n\t\tthis.debug = function (msg) {\r\n\t\t\tlogMessage(\"DEBUG\", componentName, msg);\r\n\t\t};\r\n\r\n\t\tthis.info = function (msg) {\r\n\t\t\tlogMessage(\"INFO\", componentName, msg);\r\n\t\t};\r\n\r\n\t\tthis.warning = function (msg) {\r\n\t\t\tlogMessage(\"WARNING\", componentName, msg);\r\n\t\t};\r\n\r\n\t\tthis.warn = function (msg) {\r\n\t\t\tlogMessage(\"WARNING\", componentName, msg);\r\n\t\t};\r\n\r\n\t\tthis.error = function (msg) {\r\n\t\t\tlogMessage(\"ERROR\", componentName, msg);\r\n\t\t};\r\n\t};\r\n\r\n    var _setLogLevel = function (level) {\r\n        if ((level >= 0) && (level <= logLevels.ALL)) {\r\n            currentLogLevel = level;\r\n        }\r\n    };\r\n\r\n    var _getLogLevel = function () {\r\n        return currentLogLevel;\r\n    };\r\n\r\n    var _setFileLogPath = function (logPath) {\r\n        if (FS === null) {\r\n            try {\r\n                FS = require('fs');\r\n                if (FS.appendFile) {\r\n                    logFilePath = logPath;\r\n                }\r\n            } catch (e) {\r\n                FS = {};\r\n                logFilePath = null;\r\n            }\r\n        } else {\r\n            if (FS.appendFile) {\r\n                logFilePath = logPath;\r\n            }\r\n        }\r\n    };\r\n\r\n    var _getFileLogPath = function () {\r\n        return logFilePath;\r\n    };\r\n\r\n    var _useColors = function (enabled) {\r\n        if ((enabled === true) || (enabled === false)) {\r\n            useColors = enabled;\r\n        } else {\r\n            useColors = false;\r\n        }\r\n    };\r\n\r\n    var _excludeComponent = function (componentName) {\r\n        if (excludedComponents.indexOf(componentName) === -1) {\r\n            excludedComponents.push(componentName);\r\n        }\r\n    };\r\n\r\n\treturn {\r\n\t\tlogLevels: logLevels,\r\n\t\tsetLogLevel: _setLogLevel,\r\n\t\tgetLogLevel: _getLogLevel,\r\n\r\n\t\t// this function is only for server side!!!\r\n\t\tsetFileLogPath:_setFileLogPath,\r\n\t\tgetFileLogPath: _getFileLogPath,\r\n\r\n\t\tuseColors: _useColors,\r\n        excludeComponent: _excludeComponent,\r\n\r\n\t\tcreate: function (componentName) {\r\n\t\t\treturn new Logger(componentName);\r\n\t\t}\r\n\t};\r\n});\r\n\n",
    "define('util/url',[],function(){\r\n    function decodeUrl(url){\r\n        var start = url.indexOf('%');\r\n        while(start>-1){\r\n            var char = String.fromCharCode(parseInt(url.substr(start+1, 2), 16));\r\n            url=url.replace(url.substr(start, 3),char);\r\n            start = url.indexOf('%');\r\n        }\r\n        return url;\r\n    }\r\n    function parseCookie(cookie){\r\n        cookie = decodeUrl(cookie);\r\n        var parsed = {};\r\n        var elements = cookie.split(/[;,] */);\r\n        for(var i=0;i<elements.length;i++){\r\n            var pair = elements[i].split('=');\r\n            parsed[pair[0]] = pair[1];\r\n        }\r\n        return parsed;\r\n    }\r\n    function removeSpecialChars(text){\r\n        text = text.replace(/%23/g,'#');\r\n        text = text.replace(/%2f/g,'/');text = text.replace(/%2F/g,'/');\r\n        return text;\r\n    }\r\n    function addSpecialChars(text){\r\n        if(text === undefined){\r\n            return text;\r\n        }\r\n        text = text.replace(/#/g,'%23');\r\n        text = text.replace(/\\//g,'%2F');\r\n        return text;\r\n    }\r\n    function urlToRefObject(url){\r\n        return {\r\n            '$ref':url\r\n        };\r\n    }\r\n    return {\r\n        decodeUrl : decodeUrl,\r\n        parseCookie : parseCookie,\r\n        removeSpecialChars : removeSpecialChars,\r\n        addSpecialChars : addSpecialChars,\r\n        urlToRefObject : urlToRefObject\r\n    };\r\n});\r\n\n",
    "/*\r\n * Copyright (C) 2013 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Tamas Kecskes\r\n */\r\ndefine('coreclient/meta',[], function () {\r\n    \"use strict\";\r\n\r\n    function metaStorage () {\r\n        var _core = null,\r\n            _nodes = null,\r\n            _save = function(){},\r\n            _initialized = false;\r\n\r\n        function initialize(core,nodes,save){\r\n            _core = core;\r\n            _nodes = nodes;\r\n            _save = save;\r\n            _initialized = true;\r\n        }\r\n\r\n        function isValidMeta(meta){\r\n            /*if( typeof meta === 'object'){\r\n                if(\r\n                    //children\r\n                    typeof meta.children === 'object' &&\r\n                    (meta.children.types === null || typeof meta.children.types === 'array') &&\r\n                    (typeof meta.children.min === 'undefined' || typeof meta.children.min === 'number') &&\r\n                    (typeof meta.children.max === 'undefined' || typeof meta.children.max === 'number')){\r\n\r\n                    //attributes\r\n                }\r\n            }\r\n\r\n            return false;*/\r\n            //TODO implement it :)\r\n            return true;\r\n        }\r\n\r\n        function isValidAttributeSchema(atrSchema){\r\n            //TODO implement :)\r\n            return true;\r\n        }\r\n\r\n        //TODO this may change\r\n        function pathToRefObject(path){\r\n            var ref = {};\r\n            ref['$ref'] = path;\r\n            return ref;\r\n        }\r\n\r\n        //TODO this may change\r\n        function refObjectToPath(ref){\r\n            if(typeof ref['$ref'] === 'string'){\r\n                return ref['$ref']/*.substring(1)*/;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        //getter setter functions\r\n        function getMeta(path){\r\n            var meta = {children:{},attributes:{},pointers:{},aspects:{}};\r\n            if(_nodes === null || _nodes === undefined){\r\n                return meta;\r\n            }\r\n            var node = _nodes[path] || null;\r\n            if(node){\r\n                var metaNode = _core.getChild(node,\"_meta\");\r\n                var childrenNode = _core.getChild(metaNode,\"children\");\r\n                //children\r\n                meta.children = {};\r\n                meta.children.minItems = [];\r\n                meta.children.maxItems = [];\r\n                meta.children.items = _core.getMemberPaths(childrenNode,\"items\");\r\n                for(var i=0;i<meta.children.items.length;i++){\r\n                    meta.children.minItems.push(_core.getMemberAttribute(childrenNode,\"items\",meta.children.items[i],\"min\") || -1);\r\n                    meta.children.maxItems.push(_core.getMemberAttribute(childrenNode,\"items\",meta.children.items[i],\"max\") || -1);\r\n                    meta.children.items[i] = pathToRefObject(meta.children.items[i]);\r\n                }\r\n                meta.children.min = _core.getAttribute(childrenNode,\"min\");\r\n                meta.children.max = _core.getAttribute(childrenNode,\"max\");\r\n\r\n                //attributes - they are simple json objects from our point of view\r\n                var atrNames = _core.getAttributeNames(metaNode);\r\n                for(var i=0;i<atrNames.length;i++){\r\n                    meta.attributes[atrNames[i]] = JSON.parse(JSON.stringify(_core.getAttribute(metaNode,atrNames[i])));\r\n                }\r\n\r\n                //pointers and pointer lists\r\n                var pointerNames = _core.getPointerNames(metaNode) || [];\r\n                for(var i=0;i<pointerNames.length;i++){\r\n                    var pointerNode = _core.getChild(metaNode,\"_p_\"+pointerNames[i]);\r\n                    var pointer = {};\r\n                    pointer.items = _core.getMemberPaths(pointerNode,\"items\");\r\n                    pointer.min = _core.getAttribute(pointerNode,\"min\");\r\n                    pointer.max = _core.getAttribute(pointerNode,\"max\");\r\n                    pointer.minItems = [];\r\n                    pointer.maxItems = [];\r\n\r\n                    for(var j=0;j<pointer.items.length;j++){\r\n                        pointer.minItems.push(_core.getMemberAttribute(pointerNode,\"items\",pointer.items[j],\"min\") || -1);\r\n                        pointer.maxItems.push(_core.getMemberAttribute(pointerNode,\"items\",pointer.items[j],\"max\") || -1);\r\n                        pointer.items[j] = pathToRefObject(pointer.items[j]);\r\n\r\n                    }\r\n\r\n                    meta.pointers[pointerNames[i]] = pointer;\r\n                }\r\n\r\n                //aspects\r\n                var aspectsNode = _core.getChild(metaNode,\"aspects\");\r\n                var aspectNames = _core.getPointerNames(aspectsNode);\r\n                if (aspectNames.length > 0){\r\n                    meta.aspects = {};\r\n                    for(var i=0;i<aspectNames.length;i++){\r\n                        var aspectNode = _core.getChild(aspectsNode,\"_a_\"+aspectNames[i]);\r\n                        meta.aspects[aspectNames[i]] = {items:[]};\r\n                        var items = _core.getMemberPaths(aspectNode,\"items\");\r\n                        for(var j=0;j<items.length;j++){\r\n                            meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return meta;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        function setMeta(path,meta){\r\n            if(!isValidMeta){\r\n                return;\r\n            }\r\n            var node = _nodes[path] || null;\r\n            if(node){\r\n                var metaNode = _core.getChild(node,\"_meta\");\r\n                _core.deleteNode(metaNode,true);\r\n                metaNode = _core.getChild(node,\"_meta\");\r\n                if(meta.children){\r\n                    var childrenNode = _core.getChild(metaNode,\"children\");\r\n                    if(meta.children.items && meta.children.items.length){\r\n                        if(meta.children.min){\r\n                            _core.setAttribute(childrenNode,\"min\",meta.children.min);\r\n                        }\r\n                        if(meta.children.max){\r\n                            _core.setAttribute(childrenNode,\"max\",meta.children.max);\r\n                        }\r\n\r\n                        for(var i=0;i<meta.children.items.length;i++){\r\n                            var targetPath = refObjectToPath(meta.children.items[i]);\r\n                            if(typeof targetPath ==='string' && _nodes[targetPath]){\r\n                                _core.addMember(childrenNode,\"items\",_nodes[targetPath]);\r\n                                if(meta.children.minItems[i] !== -1){\r\n                                    _core.setMemberAttribute(childrenNode,\"items\",targetPath,\"min\",meta.children.minItems[i]);\r\n                                }\r\n                                if(meta.children.maxItems[i] !== -1){\r\n                                    _core.setMemberAttribute(childrenNode,\"items\",targetPath,\"max\",meta.children.maxItems[i]);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    } else {\r\n                        _core.deleteNode(childrenNode,true);\r\n                    }\r\n                }\r\n\r\n                if(meta.attributes){\r\n                    for(var i in meta.attributes){\r\n                        _core.setAttribute(metaNode,i,meta.attributes[i]);\r\n                    }\r\n                }\r\n\r\n                if(meta.pointers){\r\n                    for(var i in meta.pointers){\r\n                        _core.setPointer(metaNode,i,null);\r\n                        var pointerNode = _core.getChild(metaNode,\"_p_\"+i);\r\n                        if(meta.pointers[i].items && meta.pointers[i].items.length){\r\n                            if(meta.pointers[i].min){\r\n                                _core.setAttribute(pointerNode,\"min\",meta.pointers[i].min);\r\n                            }\r\n                            if(meta.pointers[i].max){\r\n                                _core.setAttribute(pointerNode,\"max\",meta.pointers[i].max);\r\n                            }\r\n\r\n                            for(var j=0;j<meta.pointers[i].items.length;j++){\r\n                                var targetPath = refObjectToPath(meta.pointers[i].items[j]);\r\n                                if(typeof targetPath === 'string' && _nodes[targetPath]){\r\n                                    _core.addMember(pointerNode,\"items\",_nodes[targetPath]);\r\n                                    if(meta.pointers[i].minItems[j] !== -1){\r\n                                        _core.setMemberAttribute(pointerNode,\"items\",targetPath,\"min\",meta.pointers[i].minItems[j]);\r\n                                    }\r\n                                    if(meta.pointers[i].maxItems[j] !== -1){\r\n                                        _core.setMemberAttribute(pointerNode,\"items\",targetPath,\"max\",meta.pointers[i].maxItems[j]);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(meta.aspects){\r\n                    var aspectsNode = _core.getChild(metaNode,\"aspects\"),\r\n                        aspectNames = [];\r\n                    for(var i in meta.aspects){\r\n                        _core.setPointer(aspectsNode,i,null);\r\n                        var aspectNode = _core.getChild(aspectsNode,\"_a_\"+i);\r\n                        if(meta.aspects[i].items){\r\n                            for(j=0;j<meta.aspects[i].items.length;j++){\r\n                                var member = _nodes[refObjectToPath(meta.aspects[i].items[j])];\r\n                                if(member){\r\n                                    _core.addMember(aspectNode,\"items\",member);\r\n                                }\r\n                            }\r\n                        }\r\n                        aspectNames.push(i);\r\n                    }\r\n                    if (aspectNames.length > 0){\r\n                        meta.aspects = {};\r\n                        for(var i=0;i<aspectNames.length;i++){\r\n                            var aspectNode = _core.getChild(aspectsNode,\"_a_\"+aspectNames[i]);\r\n                            meta.aspects[aspectNames[i]] = {items:[]};\r\n                            var items = _core.getMemberPaths(aspectNode,\"items\");\r\n                            for(var j=0;j<items.length;j++){\r\n                                meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var meta_event = _core.getRegistry(node,\"_meta_event_\") || 0;\r\n                    _core.setRegistry(node,\"_meta_event_\",meta_event+1);\r\n                _save(\"setMeta(\"+path+\")\");\r\n            }\r\n        }\r\n\r\n\r\n        //validation functions\r\n        function getBaseChain(path){\r\n            var chain = [];\r\n            var node = _nodes[path];\r\n            if(node){\r\n                while(node !== null){\r\n                    chain.push(_core.getPath(node));\r\n                    node = _core.getBase(node);\r\n                }\r\n            }\r\n            return chain;\r\n        }\r\n        function isTypeOf(path,typePath){\r\n            var node = _nodes[path];\r\n            if(node){\r\n                var chain = getBaseChain(path);\r\n                if(chain.indexOf(typePath) !== -1){\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        function isValidTypeOfArray(path,typePathArray){\r\n            var i=0, isGood=false;\r\n            while(i<typePathArray.length && !isGood){\r\n                isGood = isTypeOf(path,typePathArray[i]);\r\n                i++;\r\n            }\r\n            return isGood;\r\n        }\r\n\r\n        function isValidChild(path,childPath){\r\n            var node = _nodes[path];\r\n            var child = _nodes[childPath];\r\n            if(node && child){\r\n                var metaNode = _core.getChild(node,\"_meta\");\r\n                var childrenNode = _core.getChild(metaNode,\"children\");\r\n                var items = _core.getMemberPaths(childrenNode,\"items\");\r\n                return isValidTypeOfArray(childPath,items);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isValidTarget(path,name,targetPath){\r\n            var node = _nodes[path];\r\n            var target = _nodes[targetPath];\r\n            if(node && target){\r\n                var meta = _core.getChild(node,\"_meta\");\r\n                var pointer = _core.getChild(meta,\"_p_\"+name);\r\n                var items = _core.getMemberPaths(pointer,\"items\");\r\n                return isValidTypeOfArray(targetPath,items);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isValidAttribute(path,name,attribute){\r\n            //TODO we should check against schema\r\n            return true;\r\n        }\r\n\r\n        function getValidChildrenTypes(path){\r\n            var node = _nodes[path];\r\n            if(node){\r\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node,\"_meta\"),\"children\"),\"items\");\r\n            }\r\n            return [];\r\n        }\r\n\r\n        function getValidTargetTypes(path,name){\r\n            var node = _nodes[path];\r\n            if(node){\r\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node,\"_meta\"),\"_p_\"+name),\"items\");\r\n            }\r\n            return [];\r\n        }\r\n\r\n        function hasOwnMetaRules(path){\r\n            var node = _nodes[path];\r\n            if(node){\r\n                var own = getMeta(path);\r\n                var base = getMeta(_core.getPath(_core.getBase(node)));\r\n                return own === base;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function filterValidTarget(path,name,paths){\r\n            var targets = [];\r\n            for(var i=0;i<paths.length;i++){\r\n                if(isValidTarget(path,name,paths[i])){\r\n                    targets.push(paths[i]);\r\n                }\r\n            }\r\n            return targets;\r\n        }\r\n\r\n        function getOwnValidChildrenTypes(path){\r\n            var node = _nodes[path];\r\n            var items = [];\r\n            if(node){\r\n                var own = getValidChildrenTypes(path);\r\n                var base = getValidChildrenTypes(_core.getPath(_core.getBase(node)));\r\n                for(var i= 0;i<own.length;i++){\r\n                    if(base.indexOf(own[i]) === -1){\r\n                        items.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n\r\n        function getOwnValidTargetTypes(path,name){\r\n            var node = _nodes[path];\r\n            var items = [];\r\n            if(node){\r\n                var own = getValidTargetTypes(path,name);\r\n                var base = getValidTargetTypes(_core.getPath(_core.getBase(node)),name);\r\n                for(var i= 0;i<own.length;i++){\r\n                    if(base.indexOf(own[i]) === -1){\r\n                        items.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n\r\n        function getValidAttributeNames(path){\r\n            var rawMeta = getMeta(path),\r\n                names = [];\r\n            if( rawMeta ){\r\n                for(var i in rawMeta.attributes){\r\n                    names.push(i);\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function getOwnValidAttributeNames(path){\r\n            var names = [],\r\n                node = _nodes[path];\r\n\r\n            if(node){\r\n                var own = getValidAttributeNames(path);\r\n                var base = getValidAttributeNames(_core.getPath(_core.getBase(node)));\r\n                for(var i=0;i<own.length;i++){\r\n                    if(base.indexOf(own[i]) === -1){\r\n                        names.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function indexOfPathInRefObjArray(array,path){\r\n            var index = 0;\r\n            while(index < array.length){\r\n                if(path === refObjectToPath(array[index])){\r\n                    return index;\r\n                }\r\n                index++;\r\n            }\r\n            return -1;\r\n        }\r\n        function getChildrenMeta(path){\r\n            //the returned object structure is : {\"min\":0,\"max\":0,\"items\":[{\"id\":path,\"min\":0,\"max\":0},...]}\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                var childrenMeta = {};\r\n                childrenMeta.min = rawMeta.children.min;\r\n                childrenMeta.max = rawMeta.children.max;\r\n                childrenMeta.items = rawMeta.children.items;\r\n                if(childrenMeta.items !== null){\r\n                    for(var i=0;i<childrenMeta.items.length;i++){\r\n                        var child = {};\r\n                        child.id = refObjectToPath(childrenMeta.items[i]);\r\n                        if(rawMeta.children.minItems){\r\n                            child.min = rawMeta.children.minItems[i] === -1 ? undefined : rawMeta.children.minItems[i];\r\n                        }\r\n                        if(rawMeta.children.maxItems){\r\n                            child.max = rawMeta.children.maxItems[i] === -1 ? undefined : rawMeta.children.maxItems[i];\r\n                        }\r\n\r\n                        childrenMeta.items[i] = child;\r\n                    }\r\n                }\r\n\r\n                return childrenMeta;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function getChildrenMetaAttribute(path,attrName){\r\n            var childrenMeta = getChildrenMeta(path);\r\n            if(childrenMeta){\r\n                return childrenMeta.attrName;\r\n            }\r\n            return null;\r\n        }\r\n        function setChildrenMetaAttribute(path,attrName,value){\r\n            if(attrName !== \"items\"){\r\n                var rawMeta = getMeta(path);\r\n                rawMeta.children[attrName] = value;\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function getValidChildrenItems(path){\r\n            var childrenMeta = getChildrenMeta(path);\r\n            if(childrenMeta){\r\n                return childrenMeta.items;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function updateValidChildrenItem(path,newTypeObj){\r\n            if(newTypeObj && newTypeObj.id){\r\n                var rawMeta = getMeta(path);\r\n                if(rawMeta){\r\n                    if(rawMeta.children.minItems === null || rawMeta.children.minItems == undefined){\r\n                        rawMeta.children.minItems = [];\r\n                        for(var i=0;i<rawMeta.children.items.length;i++){\r\n                            rawMeta.children.minItems.push(-1);\r\n                        }\r\n                    }\r\n                    if(rawMeta.children.maxItems === null || rawMeta.children.maxItems == undefined){\r\n                        rawMeta.children.maxItems = [];\r\n                        for(var i=0;i<rawMeta.children.items.length;i++){\r\n                            rawMeta.children.maxItems.push(-1);\r\n                        }\r\n                    }\r\n                    var refObj = pathToRefObject(newTypeObj.id);\r\n                    var index = indexOfPathInRefObjArray(rawMeta.children.items,newTypeObj.id);\r\n                    if(index === -1){\r\n                        index = rawMeta.children.items.length;\r\n                        rawMeta.children.items.push(refObj);\r\n                        rawMeta.children.minItems.push(-1);\r\n                        rawMeta.children.maxItems.push(-1);\r\n                    }\r\n                    (newTypeObj.min === null || newTypeObj.min === undefined) ? rawMeta.children.minItems[index] = -1 : rawMeta.children.minItems[index] = newTypeObj.min;\r\n                    (newTypeObj.max === null || newTypeObj.max === undefined) ? rawMeta.children.maxItems[index] = -1 : rawMeta.children.maxItems[index] = newTypeObj.max;\r\n\r\n                    setMeta(path,rawMeta);\r\n                }\r\n            }\r\n        }\r\n        function removeValidChildrenItem(path,typeId){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                var refObj = pathToRefObject(typeId);\r\n                var index = indexOfPathInRefObjArray(rawMeta.children.items,typeId);\r\n                if(index !== -1){\r\n                    rawMeta.children.items.splice(index,1);\r\n                    if(rawMeta.children.minItems){\r\n                        rawMeta.children.minItems.splice(index,1);\r\n                    }\r\n                    if(rawMeta.children.maxItems){\r\n                        rawMeta.children.maxItems.splice(index,1);\r\n                    }\r\n                    setMeta(path,rawMeta);\r\n                }\r\n            }\r\n        }\r\n\r\n        function getAttributeSchema(path,name){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                if(rawMeta.attributes[name]){\r\n                    return rawMeta.attributes[name];\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function setAttributeSchema(path,name,schema){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                //TODO check schema validity - but it is also viable to check it only during setMeta\r\n                rawMeta.attributes[name] = schema;\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function removeAttributeSchema(path,name){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                delete rawMeta.attributes[name];\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function getPointerMeta(path,name){\r\n            //the returned object structure is : {\"min\":0,\"max\":0,\"items\":[{\"id\":path,\"min\":0,\"max\":0},...]}\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta && rawMeta.pointers[name]){\r\n                var pointerMeta = {};\r\n                pointerMeta.min = rawMeta.pointers[name].min;\r\n                pointerMeta.max = rawMeta.pointers[name].max;\r\n                pointerMeta.items = rawMeta.pointers[name].items;\r\n                if(pointerMeta.items !== null){\r\n                    for(var i=0;i<pointerMeta.items.length;i++){\r\n                        var child = {};\r\n                        child.id = refObjectToPath(pointerMeta.items[i]);\r\n                        if(rawMeta.pointers[name].minItems){\r\n                            child.min = rawMeta.pointers[name].minItems[i] === -1 ? undefined : rawMeta.pointers[name].minItems[i];\r\n                        }\r\n                        if(rawMeta.pointers[name].maxItems){\r\n                            child.max = rawMeta.pointers[name].maxItems[i] === -1 ? undefined : rawMeta.pointers[name].maxItems[i];\r\n                        }\r\n                        pointerMeta.items[i] = child;\r\n                    }\r\n                }\r\n                return pointerMeta;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function getValidTargetItems(path,name){\r\n            var pointerMeta = getPointerMeta(path,name);\r\n            if(pointerMeta){\r\n                return pointerMeta.items;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function updateValidTargetItem(path,name,targetObj){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta && targetObj && targetObj.id){\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if(pointer === null){\r\n                    rawMeta.pointers[name] = {\"items\":[],\"minItems\":[],\"maxItems\":[]};\r\n                    pointer = rawMeta.pointers[name];\r\n                }\r\n                var refObj = pathToRefObject(targetObj.id);\r\n                var index = indexOfPathInRefObjArray(pointer.items,targetObj.id);\r\n                if(index === -1){\r\n                    index = pointer.items.length;\r\n                    pointer.items.push(refObj);\r\n                    pointer.minItems.push(-1);\r\n                    pointer.maxItems.push(-1);\r\n                }\r\n\r\n                (targetObj.min === null || targetObj.min === undefined) ? pointer.minItems[index] = -1 : pointer.minItems[index] = targetObj.min;\r\n                (targetObj.max === null || targetObj.max === undefined) ? pointer.maxItems[index] = -1 : pointer.maxItems[index] = targetObj.max;\r\n\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function removeValidTargetItem(path,name,targetId){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if(pointer !== null){\r\n                    var refObj = pathToRefObject(targetId);\r\n                    var index = indexOfPathInRefObjArray(pointer.items,targetId);\r\n                    if(index !== -1){\r\n                        pointer.items.splice(index,1);\r\n                        if(pointer.minItems){\r\n                            pointer.minItems.splice(index,1);\r\n                        }\r\n                        if(pointer.maxItems){\r\n                            pointer.maxItems.splice(index,1);\r\n                        }\r\n                        setMeta(path,rawMeta);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function deleteMetaPointer(path,name){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                delete rawMeta.pointers[name];\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function setPointerMeta(path,name,meta){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if(pointer === null){\r\n                    rawMeta.pointers[name] = {\"items\":[],\"minItems\":[],\"maxItems\":[]};\r\n                    pointer = rawMeta.pointers[name];\r\n                }\r\n                pointer.min = meta.min;\r\n                pointer.max = meta.max;\r\n                if(meta.items && meta.items.length){\r\n                    for(var i=0;i<meta.items.length;i++){\r\n                        pointer.items.push(pathToRefObject(meta.items[i].id));\r\n                        pointer.minItems.push(meta.items[i].min || -1);\r\n                        pointer.maxItems.push(meta.items[i].max || -1);\r\n                    }\r\n                }\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function setChildrenMeta(path,name,meta){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                var children = rawMeta.children;\r\n\r\n                children.min = meta.min;\r\n                children.max = meta.max;\r\n                if(meta.items && meta.items.length){\r\n                    for(var i=0;i<meta.items.length;i++){\r\n                        children.items.push(pathToRefObject(meta.items[i].id));\r\n                        children.minItems.push(meta.items[i].min || -1);\r\n                        children.maxItems.push(meta.items[i].max || -1);\r\n                    }\r\n                }\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function getMetaAspectNames(path){\r\n            var rawMeta = getMeta(path),\r\n                names = [];\r\n\r\n            if(rawMeta && rawMeta.aspects){\r\n                for(var i in rawMeta.aspects){\r\n                    names.push(i);\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function getOwnMetaAspectNames(path){\r\n            var names = getMetaAspectNames(path),\r\n                ownNames = [];\r\n            if(_nodes[path]){\r\n                var baseNames = getMetaAspectNames(_core.getPath(_core.getBase(_nodes[path])));\r\n                for(var i=0;i<names.length;i++){\r\n                    if(baseNames.indexOf(names[i]) === -1){\r\n                        ownNames.push(names[i]);\r\n                    }\r\n                }\r\n            }\r\n            return ownNames;\r\n        }\r\n\r\n        function getMetaAspect(path,name){\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta){\r\n                if(rawMeta.aspects[name]){\r\n                    var aspect = {items:[]};\r\n                    for(var i=0;i<rawMeta.aspects[name].items.length;i++){\r\n                        aspect.items.push(refObjectToPath(rawMeta.aspects[name].items[i]));\r\n                    }\r\n                    if (aspect.items.length === 0){\r\n                        delete aspect.items;\r\n                    }\r\n                    return aspect;\r\n                }\r\n                return null;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function setMetaAspect(path,name,aspect){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n\r\n                rawMeta.aspects = rawMeta.aspects || {};\r\n                rawMeta.aspects[name] = {'items': []};\r\n                for(var i=0;i<aspect.items.length;i++){\r\n                    rawMeta.aspects[name].items.push(pathToRefObject(aspect.items[i]));\r\n                }\r\n                setMeta(path,rawMeta);\r\n            }\r\n        }\r\n\r\n        function getAspectTerritoryPattern(path,name){\r\n            var aspect = getMetaAspect(path,name);\r\n            if( aspect !== null){\r\n                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future\r\n                return aspect;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function deleteMetaAspect(path,name){\r\n            var rawMeta = getMeta(path);\r\n            if(rawMeta){\r\n                if(rawMeta.aspects && rawMeta.aspects[name]){\r\n                    delete rawMeta.aspects[name];\r\n                    setMeta(path,rawMeta);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            refObjectToPath : refObjectToPath,\r\n            pathToRefObject : pathToRefObject,\r\n\r\n\r\n\r\n\r\n\r\n            initialize      : initialize,\r\n            getMeta         : getMeta,\r\n            setMeta         : setMeta,\r\n            isTypeOf        : isTypeOf,\r\n            hasOwnMetaRules : hasOwnMetaRules,\r\n\r\n            //containment\r\n            isValidChild             : isValidChild,\r\n            getChildrenMeta          : getChildrenMeta,\r\n            setChildrenMeta          : setChildrenMeta,\r\n            getChildrenMetaAttribute : getChildrenMetaAttribute,\r\n            setChildrenMetaAttribute : setChildrenMetaAttribute,\r\n            getValidChildrenTypes    : getValidChildrenTypes,\r\n            getOwnValidChildrenTypes : getOwnValidChildrenTypes,\r\n            getValidChildrenItems    : getValidChildrenItems,\r\n            updateValidChildrenItem  : updateValidChildrenItem,\r\n            removeValidChildrenItem  : removeValidChildrenItem,\r\n\r\n            //attribute\r\n            isValidAttribute          : isValidAttribute,\r\n            getAttributeSchema        : getAttributeSchema,\r\n            setAttributeSchema        : setAttributeSchema,\r\n            removeAttributeSchema     : removeAttributeSchema,\r\n            getValidAttributeNames    : getValidAttributeNames,\r\n            getOwnValidAttributeNames : getOwnValidAttributeNames,\r\n\r\n            //pointer\r\n            isValidTarget          : isValidTarget,\r\n            getPointerMeta         : getPointerMeta,\r\n            setPointerMeta         : setPointerMeta,\r\n            getValidTargetItems    : getValidTargetItems,\r\n            getValidTargetTypes    : getValidTargetTypes,\r\n            getOwnValidTargetTypes : getOwnValidTargetTypes,\r\n            filterValidTarget      : filterValidTarget,\r\n            updateValidTargetItem  : updateValidTargetItem,\r\n            removeValidTargetItem  : removeValidTargetItem,\r\n            deleteMetaPointer      : deleteMetaPointer,\r\n\r\n            //aspect\r\n            getMetaAspectNames        : getMetaAspectNames,\r\n            getOwnMetaAspectNames     : getOwnMetaAspectNames,\r\n            getMetaAspect             : getMetaAspect,\r\n            setMetaAspect             : setMetaAspect,\r\n            getAspectTerritoryPattern : getAspectTerritoryPattern,\r\n            deleteMetaAspect          : deleteMetaAspect\r\n\r\n        };\r\n    }\r\n\r\n    return metaStorage;\r\n});\r\n\n",
    "define('coreclient/tojson',[\r\n    'coreclient/meta',\r\n    'util/url'\r\n],function(\r\n    BaseMeta,\r\n    URL\r\n    ){\r\n\r\n    var _refTypes = {\r\n        'url':'url',\r\n        'path':'path',\r\n        'guid':'guid'\r\n    };\r\n    var META = new BaseMeta();\r\n\r\n    var changeRefObjects = function(refType,urlPrefix,object,core,root,callback){\r\n        if(typeof object === 'object'){\r\n            var needed = 0,\r\n                neededNames = [],\r\n                error = null;\r\n            for(var i in object){\r\n                if(object[i] !== null && typeof object[i] === 'object'){\r\n                    needed++;\r\n                    neededNames.push(i);\r\n                }\r\n            }\r\n            if(needed > 0){\r\n                for(var i=0;i<neededNames.length;i++){\r\n                    if(object[neededNames[i]]['$ref']){\r\n                        //refrence object\r\n                        pathToRefObjAsync(refType,urlPrefix,object[neededNames[i]]['$ref']/*.substring(1)*/,core,root,function(err,refObj){\r\n                            error = error || err;\r\n                            object[neededNames[i]] = refObj;\r\n                            if(--needed === 0){\r\n                                callback(error);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        changeRefObjects(refType,urlPrefix,object[neededNames[i]],core,root,function(err){\r\n                            error = error || err;\r\n                            if(--needed === 0){\r\n                                callback(error);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        } else {\r\n            callback(null);\r\n        }\r\n    };\r\n    var pathToRefObj = function(refType,urlPrefix,path){\r\n        switch (refType){\r\n            case _refTypes.url:\r\n                if(path === null){\r\n                    return URL.urlToRefObject(null);\r\n                }\r\n                return URL.urlToRefObject(urlPrefix+'&path='+URL.addSpecialChars(path));\r\n                break;\r\n            case _refTypes.path:\r\n                return URL.urlToRefObject(path);\r\n                break;\r\n            default:\r\n                return URL.urlToRefObject(null);\r\n        }\r\n    };\r\n    var getParentRefObject = function(refType,urlPrefix,core,node){\r\n        var parent = core.getParent(node),\r\n            path = null;\r\n        if(parent){\r\n            path = core.getPath(parent);\r\n        }\r\n        switch (refType){\r\n            case _refTypes.url:\r\n                if(path === null){\r\n                    return URL.urlToRefObject(null);\r\n                }\r\n                return URL.urlToRefObject(urlPrefix+'&path='+URL.addSpecialChars(path));\r\n                break;\r\n            case _refTypes.path:\r\n                return URL.urlToRefObject(path);\r\n            case _refTypes.guid:\r\n                if(path === null){\r\n                    return URL.urlToRefObject(null);\r\n                } else {\r\n                    var refObj = URL.urlToRefObject(path);\r\n                    refObj.GUID = core.getGuid(parent);\r\n                    return refObj;\r\n                }\r\n        }\r\n    };\r\n    var pathToRefObjAsync = function(refType,urlPrefix,path,core,root,callback){\r\n        switch (refType){\r\n            case _refTypes.url:\r\n                if(path === null){\r\n                    callback(null,URL.urlToRefObject(null));\r\n                }\r\n                callback(null,URL.urlToRefObject(urlPrefix+'&path='+URL.addSpecialChars(path)));\r\n                break;\r\n            case _refTypes.path:\r\n                callback(null,URL.urlToRefObject(path));\r\n                break;\r\n            case _refTypes.guid:\r\n                core.loadByPath(root,path,function(err,node){\r\n                    if(err){\r\n                        callback(err,null);\r\n                    } else {\r\n                        var refObj = URL.urlToRefObject(path);\r\n                        refObj.GUID = core.getGuid(node);\r\n                        callback(null,refObj);\r\n                    }\r\n                });\r\n                break;\r\n            default:\r\n                callback(null,URL.urlToRefObject(null));\r\n        }\r\n    };\r\n    var getChildrenGuids = function(core,node,callback){\r\n        var GUIDHash = {};\r\n        core.loadChildren(node,function(err,children){\r\n            if(err){\r\n                callback(err,null);\r\n            } else {\r\n                for(var i=0;i<children.length;i++){\r\n                    GUIDHash[core.getPath(children[i])] = core.getGuid(children[i]);\r\n                }\r\n                callback(null,GUIDHash);\r\n            }\r\n        });\r\n    };\r\n    var getMetaOfNode = function(core,node,urlPrefix,refType,callback){\r\n        var meta = META.getMeta(core.getPath(node));\r\n        changeRefObjects(refType,urlPrefix,meta,core,core.getRoot(node),function(err){\r\n            callback(err,meta);\r\n        });\r\n    };\r\n    var getChildrenOfNode = function(core,node,urlPrefix,refType,callback){\r\n        if(refType === _refTypes.guid){\r\n            getChildrenGuids(core,node,function(err,gHash){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    //TODO possibly it needs some ordering\r\n                    var children = [];\r\n                    for(var i in gHash){\r\n                        var refObj = URL.urlToRefObject(i);\r\n                        refObj.GUID = gHash[i];\r\n                        children.push(refObj);\r\n                    }\r\n                    callback(null,children);\r\n                }\r\n            });\r\n        } else {\r\n            var paths = core.getChildrenPaths(node);\r\n            var children = [];\r\n            for(var i=0;i<paths.length;i++){\r\n                children.push(pathToRefObj(refType,urlPrefix,paths[i]));\r\n            }\r\n            callback(null,children);\r\n        }\r\n    };\r\n    var getSetAttributesAndRegistry = function(core,node,setName,setOwnerPath,callback){\r\n        var path = core.getPath(node);\r\n        core.loadByPath(core.getRoot(node),setOwnerPath,function(err,owner){\r\n            if(err){\r\n                callback(err);\r\n            } else {\r\n                if(owner){\r\n                    var atrAndReg = {attributes:{},registry:{}};\r\n                    var names = core.getMemberAttributeNames(owner,setName,path);\r\n                    for(var i=0;i<names.length;i++){\r\n                        atrAndReg.attributes[names[i]] = core.getMemberAttribute(owner,setName,path,names[i]);\r\n                    }\r\n                    names = core.getMemberRegistryNames(owner,setName,path);\r\n                    for(var i=0;i<names.length;i++){\r\n                        atrAndReg.registry[names[i]] = core.getMemberRegistry(owner,setName,path,names[i]);\r\n                    }\r\n                    callback(null,atrAndReg);\r\n                } else {\r\n                    callback('internal error',null);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    var getMemberAttributesAndRegistry = function(core,node,setName,memberPath){\r\n        var retObj = {attributes:{},registry:{}};\r\n        var names,i;\r\n        names = core.getMemberAttributeNames(node,setName,memberPath);\r\n        for(i=0;i<names.length;i++){\r\n            retObj.attributes[names[i]] = core.getMemberAttribute(node,setName,memberPath,names[i]);\r\n        }\r\n        names = core.getMemberRegistryNames(node,setName,memberPath);\r\n        for(i=0;i<names.length;i++){\r\n            retObj.registry[names[i]] = core.getMemberRegistry(node,setName,memberPath,names[i]);\r\n        }\r\n        return retObj;\r\n    };\r\n    var getSetsOfNode = function(core,node,urlPrefix,refType,callback){\r\n        var setsInfo = {};\r\n        var createOneSetInfo = function(setName,callback){\r\n            var needed,\r\n                members = (core.getMemberPaths(node,setName)).sort(), //TODO we should remove the sort part at some point\r\n                info = {from:[],to:[],set:true},\r\n                i,\r\n                error = null,\r\n                containers = [],\r\n                collectSetInfo = function(nodePath,container,callback){\r\n                    if(container === true){\r\n                        pathToRefObjAsync(refType,urlPrefix,nodePath,core,core.getRoot(node),function(err,refObj){\r\n                            if(!err && refObj !== undefined && refObj !== null){\r\n                                getSetAttributesAndRegistry(core,node,setName,nodePath,function(err,atrAndReg){\r\n                                    if(atrAndReg){\r\n                                        for(var j in atrAndReg){\r\n                                            refObj[j] = atrAndReg[j];\r\n                                        }\r\n                                    }\r\n                                    callback(err,refObj);\r\n                                });\r\n                            } else {\r\n                                callback(err,null);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        //member\r\n                        pathToRefObjAsync(refType,urlPrefix,nodePath,core,core.getRoot(node),function(err,refObj){\r\n                            if(refObj !== undefined && refObj !== null){\r\n                                var atrAndReg = getMemberAttributesAndRegistry(core,node,setName,nodePath);\r\n                                for(var j in atrAndReg){\r\n                                    refObj[j] = atrAndReg[j];\r\n                                }\r\n                                callback(err,refObj);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n\r\n            for(i in memberOfInfo){\r\n                if(memberOfInfo[i].indexOf(setName) !== -1){\r\n                    containers.push(i);\r\n                }\r\n            }\r\n\r\n            needed = members.length + containers.length;\r\n            if(needed > 0){\r\n                for(i=0;i<members.length;i++){\r\n                    collectSetInfo(members[i],false,function(err,refObj){\r\n                        error = error || err;\r\n                        if(refObj !== undefined && refObj !== null){\r\n                            info.to.push(refObj);\r\n                        }\r\n\r\n                        if(--needed === 0){\r\n                            if(error === null){\r\n                                setsInfo[setName] = info;\r\n                            }\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                for(i=0;i<containers.length;i++){\r\n                    collectSetInfo(containers[i],true,function(err,refObj){\r\n                        error = error || err;\r\n                        if(refObj !== undefined && refObj !== null){\r\n                            info.from.push(refObj);\r\n                        }\r\n\r\n                        if(--needed === 0){\r\n                            if(error === null){\r\n                                setsInfo[setName] = info;\r\n                            }\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        };\r\n\r\n        var tArray = core.getSetNames(node),\r\n            memberOfInfo = core.isMemberOf(node),\r\n            i, j, needed, error = null;\r\n        for(j in memberOfInfo){\r\n            for(i=0;i<memberOfInfo[j].length;i++){\r\n                if(tArray.indexOf(memberOfInfo[j][i]) === -1){\r\n                    tArray.push(memberOfInfo[j][i]);\r\n                }\r\n            }\r\n        }\r\n        needed = tArray.length;\r\n        if(needed>0){\r\n            for(i=0;i<tArray.length;i++){\r\n                createOneSetInfo(tArray[i],function(err){\r\n                    error = error || err;\r\n                    if(--needed === 0){\r\n                        callback(error,setsInfo);\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            callback(null,setsInfo);\r\n        }\r\n    };\r\n    var getPointersGUIDs = function(core,node,callback){\r\n        var gHash = {},\r\n            pointerNames = core.getPointerNames(node),\r\n            collectionNames = core.getCollectionNames(node),\r\n            needed = pointerNames.length+collectionNames.length,\r\n            error = null;\r\n        if(needed > 0){\r\n            //pointers\r\n            for(var i=0;i<pointerNames.length;i++){\r\n                core.loadPointer(node,pointerNames[i],function(err,pointer){\r\n                    error = error || err;\r\n                    if(pointer){\r\n                        if(gHash[core.getPath(pointer)] === undefined){\r\n                            gHash[core.getPath(pointer)] = core.getGuid(pointer);\r\n                        }\r\n                    }\r\n\r\n                    if(--needed === 0){\r\n                        callback(error,gHash);\r\n                    }\r\n                });\r\n            }\r\n            //collections\r\n            for(var i=0;i<collectionNames.length;i++){\r\n                core.loadCollection(node,collectionNames[i],function(err,collection){\r\n                    error = error || err;\r\n                    if(collection){\r\n                        for(var j=0;j<collection.length;j++){\r\n                            if(gHash[core.getPath(collection[j])] === undefined){\r\n                                gHash[core.getPath(collection[j])] = core.getGuid(collection[j]);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(--needed === 0){\r\n                        callback(error,gHash);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            callback(error,gHash);\r\n        }\r\n    };\r\n    var getPointersOfNode = function(core,node,urlPrefix,refType,callback){\r\n        var GUIDHash = {};\r\n        var getRefObj = function(path){\r\n            if(refType === _refTypes.guid){\r\n                var refObj = URL.urlToRefObject(path);\r\n                refObj.GUID = GUIDHash[path];\r\n                return refObj;\r\n            } else {\r\n                return pathToRefObj(refType,urlPrefix,path);\r\n            }\r\n        };\r\n        var initialized = function(){\r\n            var pointers = {},\r\n                tArray = core.getPointerNames(node),\r\n                t2Array = core.getCollectionNames(node);\r\n            for(var i=0;i<t2Array.length;i++){\r\n                if(tArray.indexOf(t2Array[i]) === -1){\r\n                    tArray.push(t2Array[i]);\r\n                }\r\n            }\r\n            for(var i=0;i<tArray.length;i++){\r\n                var coll = core.getCollectionPaths(node,tArray[i]);\r\n                var pointer = {to:[],from:[],set:false},\r\n                    pPath = core.getPointerPath(node,tArray[i]);\r\n                if(pPath !== undefined){\r\n                    pointer.to.push(getRefObj(pPath));\r\n                }\r\n                for(var j=0;j<coll.length;j++){\r\n                    pointer.from.push(getRefObj(coll[j]));\r\n                }\r\n                pointers[tArray[i]] = pointer;\r\n            }\r\n            callback(null,pointers);\r\n        };\r\n\r\n        //start\r\n        if(refType === _refTypes.guid){\r\n            getPointersGUIDs(core,node,function(err,gHash){\r\n                if(err){\r\n                    callback(err,null);\r\n                } else {\r\n                    GUIDHash = gHash;\r\n                    initialized();\r\n                }\r\n            });\r\n        } else {\r\n            initialized();\r\n        }\r\n    };\r\n    var getOwnPartOfNode = function(core,node){\r\n        var own = {attributes:[],registry:[],pointers:[]};\r\n        own.attributes = core.getOwnAttributeNames(node);\r\n        own.registry = core.getOwnRegistryNames(node);\r\n        own.pointers = core.getOwnPointerNames(node);\r\n        return own;\r\n    } ;\r\n    var getJsonNode = function(core,node,urlPrefix,refType,callback){\r\n        var nodes = {},\r\n            tArray,\r\n            i,\r\n            jNode;\r\n\r\n        if(refType === _refTypes.guid && typeof core.getGuid !== 'function'){\r\n            callback(new Error('cannot provide GUIDs'),null);\r\n        }\r\n\r\n        nodes[core.getPath(node)] = node;\r\n        META.initialize(core,nodes,function(){});\r\n        jNode = {'meta':{},'registry':{},'children':[],'attributes':{},'pointers':{}, 'registry':{}};\r\n\r\n\r\n        //basic parts of the node\r\n        //GUID\r\n        if(typeof core.getGuid === 'function'){\r\n            jNode.GUID = core.getGuid(node);\r\n        }\r\n        //RELID\r\n        jNode.RELID = core.getRelid(node);\r\n        //registry entries\r\n        tArray = core.getRegistryNames(node);\r\n        for(i=0;i<tArray.length;i++){\r\n            jNode['registry'][tArray[i]] = core.getRegistry(node,tArray[i]);\r\n        }\r\n        //attribute entries\r\n        tArray = core.getAttributeNames(node);\r\n        for(i=0;i<tArray.length;i++){\r\n            jNode['attributes'][tArray[i]] = core.getAttribute(node,tArray[i]);\r\n        }\r\n\r\n        //own part of the node\r\n        jNode.OWN = getOwnPartOfNode(core,node);\r\n\r\n        //reference to parent\r\n        jNode.parent = getParentRefObject(refType,urlPrefix,core,node);\r\n\r\n\r\n        //now calling the relational parts\r\n        var needed = 4,\r\n            error = null;\r\n        getChildrenOfNode(core,node,urlPrefix,refType,function(err,children){\r\n            error = error || err;\r\n            jNode.children = children;\r\n            if(--needed === 0){\r\n                callback(error,jNode);\r\n            }\r\n        });\r\n        getMetaOfNode(core,node,urlPrefix,refType,function(err,meta){\r\n            error = error || err;\r\n            jNode.meta = meta;\r\n            if(--needed === 0){\r\n                callback(error,jNode);\r\n            }\r\n        });\r\n        getPointersOfNode(core,node,urlPrefix,refType,function(err,pointers){\r\n            error = error || err;\r\n            for(var i in pointers){\r\n                jNode.pointers[i] = pointers[i];\r\n            }\r\n            if(--needed === 0){\r\n                callback(error,jNode);\r\n            }\r\n        });\r\n        getSetsOfNode(core,node,urlPrefix,refType,function(err,sets){\r\n            error = error || err;\r\n            for(var i in sets){\r\n                jNode.pointers[i] = sets[i];\r\n            }\r\n            if(--needed === 0){\r\n                callback(error,jNode);\r\n            }\r\n        });\r\n    };\r\n    return getJsonNode;\r\n});\r\n\n",
    "define('coreclient/dump',[\r\n    'coreclient/meta',\r\n    'coreclient/tojson',\r\n    'util/url'\r\n],function(\r\n    BaseMeta,\r\n    ToJson,\r\n    URL\r\n    ){\r\n    var _refTypes = {\r\n        'url':'url',\r\n        'path':'path',\r\n        'guid':'guid'\r\n        },\r\n        _cache = {},\r\n        _rootPath = \"\",\r\n        _refType = 'url',\r\n        _core = null,\r\n        META = new BaseMeta();\r\n\r\n    var isRefObject = function(obj){\r\n        if(obj && typeof obj['$ref'] === 'string'){\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    var getRefObjectPath = function(obj){\r\n        if(isRefObject(obj) === true){\r\n            var refValue = obj['$ref'];\r\n            switch(_refType){\r\n                case _refTypes.url:\r\n                    if(refValue === null){\r\n                        return null;\r\n                    }\r\n                    refValue = refValue.split('/');\r\n                    return URL.removeSpecialChars(refValue[refValue.length-1]);\r\n                    break;\r\n                case _refTypes.path:\r\n                case _refTypes.guid:\r\n                    return refValue;\r\n                    break;\r\n                default:\r\n                    return null;\r\n            }\r\n\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    var pathToRelRefObject = function(path){\r\n        if(_cache[path]){\r\n            return {'$ref': _cache[path]};\r\n        }\r\n        return {'$ref': null};\r\n    };\r\n\r\n    var refToRelRefObj = function(path,refObj){\r\n        if(_cache[path]){\r\n            refObj['$ref'] = _cache[path];\r\n        } else {\r\n            refObj = {'$ref': null};\r\n        }\r\n    };\r\n\r\n    var isSubordinate = function(path){\r\n        if(path.indexOf(_rootPath) === 0){\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    var dumpChildren = function(node,dumpObject,urlPrefix,relPath,callback){\r\n        var needed = dumpObject.children.length;\r\n        if(needed > 0){\r\n            _core.loadChildren(node,function(err,children){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    if(children === null || children === undefined || ! children.length > 0){\r\n                        callback(new Error('invalid children info found'));\r\n                    } else {\r\n                        var setChildJson = function(child,cb){\r\n                            ToJson(_core,child,urlPrefix,_refType,function(err,jChild){\r\n                                if(err){\r\n                                    cb(err);\r\n                                } else {\r\n                                    if(jChild){\r\n                                        var childRelPath,\r\n                                            childPath = _core.getPath(child);\r\n                                        for(var j=0;j<dumpObject.children.length;j++){\r\n                                            if(childPath === getRefObjectPath(dumpObject.children[j])){\r\n                                                childRelPath = relPath+'/children['+j+']';\r\n                                                _cache[childPath] = childRelPath;\r\n                                                dumpObject.children[j] = jChild;\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        dumpChildren(child,dumpObject.children[j],urlPrefix,childRelPath,cb);\r\n                                    }\r\n                                }\r\n                            })\r\n                        };\r\n                        var error = null;\r\n\r\n                        for(var i=0;i<children.length;i++){\r\n                            setChildJson(children[i],function(err){\r\n                                error = error || err;\r\n                                if(--needed === 0){\r\n                                    callback(error);\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            callback(null);\r\n        }\r\n    };\r\n    var checkForInternalReferences = function(dumpObject){\r\n        if(typeof dumpObject === 'object'){\r\n            for(var i in dumpObject){\r\n                if(typeof dumpObject[i] === 'object'){\r\n                    if(isRefObject(dumpObject[i])){\r\n                        var path = getRefObjectPath(dumpObject[i]);\r\n                        if(isSubordinate(path)){\r\n                            refToRelRefObj(path,dumpObject[i]);\r\n                        }\r\n                    } else {\r\n                        checkForInternalReferences(dumpObject[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var dumpJsonNode = function(core,node,urlPrefix,refType,callback){\r\n        _cache = {};\r\n        _core = core;\r\n        _rootPath = core.getPath(node);\r\n        _refType = refType;\r\n\r\n        //TODO this needs to be done in another way\r\n        ToJson(core,node,urlPrefix,_refType,function(err,jDump){\r\n            if(err){\r\n                callback(err,null);\r\n            } else {\r\n                if(jDump){\r\n                    _cache[_rootPath] = \"#\";\r\n                }\r\n                dumpChildren(node,jDump,urlPrefix,_cache[_rootPath],function(err){\r\n                    if(err){\r\n                        callback(err);\r\n                    } else {\r\n                        checkForInternalReferences(jDump);\r\n                        callback(null,jDump);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    return dumpJsonNode;\r\n});\r\n\r\n\n",
    "define('coreclient/dumpmore',[\r\n    'coreclient/meta',\r\n    'coreclient/tojson',\r\n    'util/url'\r\n],function(\r\n    BaseMeta,\r\n    ToJson,\r\n    URL\r\n    ){\r\n    var _refTypes = {\r\n            'url':'url',\r\n            'path':'path',\r\n            'guid':'guid'\r\n        },\r\n        _cache = {},\r\n        _rootPath = \"\",\r\n        _refType = 'url',\r\n        _core = null,\r\n        _urlPrefix = \"\",\r\n        META = new BaseMeta();\r\n\r\n    var isRefObject = function(obj){\r\n        if(obj && obj['$ref']){\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    var getRefObjectPath = function(obj){\r\n        if(isRefObject(obj) === true){\r\n            var refValue = obj['$ref'];\r\n            switch(_refType){\r\n                case _refTypes.url:\r\n                    if(refValue === null){\r\n                        return null;\r\n                    }\r\n                    refValue = refValue.split('/');\r\n                    return URL.removeSpecialChars(refValue[refValue.length-1]);\r\n                    break;\r\n                case _refTypes.path:\r\n                case _refTypes.guid:\r\n                    return refValue;\r\n                    break;\r\n                default:\r\n                    return null;\r\n            }\r\n\r\n        } else {\r\n            return null;\r\n        }\r\n    };\r\n\r\n    var pathToRelRefObject = function(path){\r\n        if(_cache[path]){\r\n            return {'$ref': _cache[path]};\r\n        }\r\n        return {'$ref': null};\r\n    };\r\n\r\n    var refToRelRefObj = function(path,refObj){\r\n        if(_cache[path]){\r\n            refObj['$ref'] = _cache[path];\r\n        }\r\n    };\r\n\r\n    var isSubordinate = function(path){\r\n        if(path.indexOf(_rootPath) === 0){\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    var dumpChildren = function(node,dumpObject,urlPrefix,relPath,callback){\r\n        var needed = dumpObject.children.length;\r\n        if(needed > 0){\r\n            _core.loadChildren(node,function(err,children){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    if(children === null || children === undefined || ! children.length > 0){\r\n                        callback(new Error('invalid children info found'));\r\n                    } else {\r\n                        var setChildJson = function(child,cb){\r\n                            ToJson(_core,child,urlPrefix,_refType,function(err,jChild){\r\n                                if(err){\r\n                                    cb(err);\r\n                                } else {\r\n                                    if(jChild){\r\n                                        var childRelPath,\r\n                                            childPath = _core.getPath(child);\r\n                                        for(var j=0;j<dumpObject.children.length;j++){\r\n                                            if(childPath === getRefObjectPath(dumpObject.children[j])){\r\n                                                childRelPath = relPath+'/children['+j+']';\r\n                                                _cache[childPath] = childRelPath;\r\n                                                dumpObject.children[j] = jChild;\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        dumpChildren(child,dumpObject.children[j],urlPrefix,childRelPath,cb);\r\n                                    }\r\n                                }\r\n                            })\r\n                        };\r\n                        var error = null;\r\n\r\n                        for(var i=0;i<children.length;i++){\r\n                            setChildJson(children[i],function(err){\r\n                                error = error || err;\r\n                                if(--needed === 0){\r\n                                    callback(error);\r\n                                }\r\n                            })\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            callback(null);\r\n        }\r\n    };\r\n    var checkForInternalReferences = function(dumpObject){\r\n        if(typeof dumpObject === 'object'){\r\n            for(var i in dumpObject){\r\n                if(typeof dumpObject[i] === 'object'){\r\n                    if(isRefObject(dumpObject[i])){\r\n                        var path = getRefObjectPath(dumpObject[i]);\r\n                        refToRelRefObj(path,dumpObject[i]);\r\n                    } else {\r\n                        checkForInternalReferences(dumpObject[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var dumpJsonNode = function(core,node,urlPrefix,refType,callback){\r\n        _cache = {};\r\n        _core = core;\r\n        _rootPath = core.getPath(node);\r\n        _refType = refType;\r\n\r\n        //TODO this needs to be done in another way\r\n        ToJson(core,node,urlPrefix,_refType,function(err,jDump){\r\n            if(err){\r\n                callback(err,null);\r\n            } else {\r\n                if(jDump){\r\n                    _cache[_rootPath] = \"#\";\r\n                }\r\n                dumpChildren(node,jDump,urlPrefix,_cache[_rootPath],function(err){\r\n                    if(err){\r\n                        callback(err);\r\n                    } else {\r\n                        checkForInternalReferences(jDump);\r\n                        callback(null,jDump);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    var dumpNode = function(node,relPath,containerDump,index,callback){\r\n        //first we should check if the node is already dumped or not\r\n        var path = _core.getPath(node);\r\n        if(_cache[path]){\r\n            containerDump[index] = {\r\n                'GUID':_core.getGuid(node),\r\n                '$ref':relPath\r\n            };\r\n            callback(null);\r\n        } else {\r\n            //we try to dump this path for the first time\r\n            ToJson(_core,node,_urlPrefix,_refType,function(err,jNode){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    containerDump[index] = jNode;\r\n                    _cache[path] = relPath;\r\n\r\n                    //now we should recursively call ourselves if the node has children\r\n                    if(containerDump[index].children.length > 0){\r\n                        var needed = containerDump[index].children.length,\r\n                            error = null;\r\n                        _core.loadChildren(node,function(err,children){\r\n                            if(err){\r\n                                callback(err);\r\n                            } else {\r\n                                for(var i=0;i<children.length;i++){\r\n                                    dumpNode(children[i],relPath+'/children['+i+']',containerDump[index].children,i,function(err){\r\n                                        error = error || err;\r\n                                        if(--needed === 0){\r\n                                            callback(error);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        callback(null);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    var dumpMoreNodes = function(core,nodes,urlPrefix,refType,callback){\r\n        _cache = {};\r\n        _core = core;\r\n        _refType = refType;\r\n        _urlPrefix = urlPrefix;\r\n\r\n        var dumpNodes = [],\r\n            needed = nodes.length,\r\n            error = null,\r\n            postProcessing = function(err){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    checkForInternalReferences(dumpNodes);\r\n                    callback(null,dumpNodes);\r\n                }\r\n            };\r\n        if(needed > 0){\r\n            for(var i=0;i<nodes.length;i++){\r\n                dumpNodes.push({});\r\n                dumpNode(nodes[i],'#['+i+']',dumpNodes,i,function(err){\r\n                    error = error || err;\r\n                    if(--needed === 0){\r\n                        postProcessing(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            callback('no node to dump!!!',null);\r\n        }\r\n    };\r\n\r\n    return dumpMoreNodes;\r\n});\r\n\r\n\r\n\n",
    "/*\r\nthis type of import is for merge purposes\r\nit tries to import not only the outgoing relations but the incoming ones as well\r\nit also tries to keep both the GUID and the relid's\r\nif it finds the same guid in the same place then it overwrites the node with the imported one!!!\r\nit not searches for GUID!!! so be careful when to use this method\r\n*/\r\n\r\ndefine('coreclient/import',[\r\n    'coreclient/meta'\r\n],function(\r\n    BaseMeta\r\n    ){\r\n    var _core = null,\r\n        _root = null,\r\n        _rootPath = \"\",\r\n        _cache = {},\r\n        _underImport = {},\r\n        _internalRefHash = {},\r\n        META = new BaseMeta();\r\n\r\n    function internalRefCreated(intPath,node){\r\n        _cache[_core.getPath(node)] = node;\r\n        _internalRefHash[intPath] = _core.getPath(node);\r\n        var callbacks = _underImport[intPath] || [];\r\n        delete _underImport[intPath];\r\n        for(var i=0;i<callbacks.length;i++){\r\n            callbacks[i](null,node);\r\n        }\r\n    }\r\n    function objectLoaded(error,node){\r\n        if(error === null){\r\n            _cache[_core.getPath(node)] = node;\r\n        }\r\n\r\n        var callbacks = _underImport[_core.getPath(node)] || [];\r\n        delete _underImport[_core.getPath(node)];\r\n        for(var i=0;i<callbacks.length;i++){\r\n            callbacks[i](error,node);\r\n        }\r\n    }\r\n    function isInternalReference(refObj){\r\n        if(refObj && typeof refObj['$ref'] === 'string'){\r\n            if(refObj['$ref'].indexOf('#') === 0){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function getReferenceNode(refObj,callback){\r\n        //we allow the internal references and the\r\n        if(refObj && typeof refObj['$ref'] === 'string'){\r\n            if(refObj['$ref'].indexOf('#') === 0){\r\n                //we assume that it is an internal reference\r\n                if(_internalRefHash[refObj['$ref']] !== undefined){\r\n                    callback(null,_cache[_internalRefHash[refObj['$ref']]]);\r\n                } else if(_underImport[refObj['$ref']] !== undefined){\r\n                    _underImport[refObj['$ref']].push(callback);\r\n                } else {\r\n                    _underImport[refObj['$ref']] = [callback]; //TODO we should check if the loading order is really finite this way\r\n                }\r\n            } else if(refObj['$ref'] === null){\r\n                callback(null,null);\r\n            } else {\r\n                if(_cache[refObj['$ref']]){\r\n                    callback(null,_cache[refObj['$ref']]);\r\n                } else if(_underImport[refObj['$ref']]){\r\n                    _underImport[refObj['$ref']].push(callback);\r\n                } else {\r\n                    _underImport[refObj['$ref']] = [callback];\r\n                    _core.loadByPath(_root,refObj['$ref'],function(err,node){\r\n                        if(err){\r\n                            objectLoaded(err, null);\r\n                        } else {\r\n                            if(refObj['GUID']){\r\n                                if(refObj['GUID'] === _core.getGuid(node)){\r\n                                    objectLoaded(err,node);\r\n                                } else {\r\n                                    objectLoaded('GUID mismatch',node);\r\n                                }\r\n                            } else {\r\n                                objectLoaded(err,node);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            callback(null,null);\r\n        }\r\n    }\r\n    function importChildren(node,jNode,pIntPath,callback){\r\n        if(jNode && jNode.children && jNode.children.length){\r\n            var needed = jNode.children.length;\r\n\r\n            if(needed > 0){\r\n                var error = null;\r\n                for(var i=0;i<jNode.children.length;i++){\r\n                    importNode(jNode.children[i],node,pIntPath+'/children['+i+']',true,function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n\r\n        } else {\r\n            callback(null); //TODO maybe we should be more strict\r\n        }\r\n    }\r\n    function importAttributes(node,jNode){\r\n        if(typeof jNode.attributes === 'object'){\r\n            var names = Object.keys(jNode.attributes);\r\n            if(jNode.OWN){\r\n                names = jNode.OWN.attributes;\r\n            }\r\n\r\n            for(var i=0;i<names.length;i++){\r\n                var value = jNode.attributes[names[i]];\r\n                if(value !== undefined){\r\n                    _core.setAttribute(node,names[i],value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function importRegistry(node,jNode){\r\n        if(typeof jNode.registry === 'object'){\r\n            var names = Object.keys(jNode.registry);\r\n            if(jNode.OWN){\r\n                names = jNode.OWN.registry;\r\n            }\r\n\r\n            for(var i=0;i<names.length;i++){\r\n                var value = jNode.registry[names[i]];\r\n                if(value !== undefined){\r\n                    _core.setRegistry(node,names[i],value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function importPointer(node,jNode,pName,callback){\r\n        if(jNode.pointers[pName].to && jNode.pointers[pName].from){\r\n            var needed = jNode.pointers[pName].to.length + jNode.pointers[pName].from.length,\r\n                i,\r\n                error = null;\r\n            var ownPointer = true;\r\n            if(jNode.OWN){\r\n                if(jNode.OWN.pointers.indexOf(pName) === -1){\r\n                    ownPointer = false;\r\n                    needed -= jNode.pointers[pName].to.length;\r\n                }\r\n            }\r\n            if(needed === 0){\r\n                callback(null);\r\n            } else {\r\n                if(ownPointer){\r\n                    for(i=0;i<jNode.pointers[pName].to.length;i++){\r\n                        getReferenceNode(jNode.pointers[pName].to[i],function(err,target){\r\n                            error = error || err;\r\n                            _core.setPointer(node,pName,target);\r\n\r\n                            if(--needed === 0){\r\n                                callback(error);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                for(i=0;i<jNode.pointers[pName].from.length;i++){\r\n                    if(!isInternalReference(jNode.pointers[pName].from[i])){\r\n                        getReferenceNode(jNode.pointers[pName].from[i],function(err,source){\r\n                            error = error || err;\r\n                            if(source){\r\n                                _core.setPointer(source,pName,node);\r\n                            }\r\n\r\n                            if(--needed === 0){\r\n                                callback(error);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            callback(null);\r\n        }\r\n    }\r\n    function importSet(node,jNode,sName, callback){\r\n        if(jNode.pointers[sName].to && jNode.pointers[sName].from){\r\n            var needed = 0,\r\n                importSetRegAndAtr = function(sOwner,sMember,atrAndReg){\r\n                    _core.addMember(sOwner,sName,sMember);\r\n                    var mPath = _core.getPath(sMember);\r\n                    atrAndReg.attributes = atrAndReg.attributes || {};\r\n                    for(var i in atrAndReg.attributes){\r\n                        _core.setMemberAttribute(sOwner,sName,mPath,i,atrAndReg.attributes[i]);\r\n                    }\r\n                    atrAndReg.registry = atrAndReg.registry || {};\r\n                    for(var i in atrAndReg.registry){\r\n                        _core.setMemberRegistry(sOwner,sName,mPath,i,atrAndReg.registry[i]);\r\n                    }\r\n                },\r\n                importSetReference = function(isTo,index,cb){\r\n                    var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\r\n                    getReferenceNode(jObj,function(err,sNode){\r\n                        if(err){\r\n                            cb(err);\r\n                        } else {\r\n                            if(sNode){\r\n                                var sOwner = isTo === true ? node : sNode,\r\n                                    sMember = isTo === true ? sNode : node;\r\n                                importSetRegAndAtr(sOwner,sMember,jObj);\r\n                            }\r\n                            cb(null);\r\n                        }\r\n                    });\r\n                },\r\n                error = null;\r\n\r\n            if(jNode.pointers[sName].to.length > 0){\r\n                needed += jNode.pointers[sName].to.length;\r\n                _core.createSet(node,sName);\r\n            }\r\n            if(jNode.pointers[sName].from.length > 0){\r\n                needed += jNode.pointers[sName].from.length;\r\n            }\r\n\r\n            if(needed > 0){\r\n                for(var i=0;i<jNode.pointers[sName].to.length;i++){\r\n                    importSetReference(true,i,function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n                for(var i=0;i<jNode.pointers[sName].from.length;i++){\r\n                    importSetReference(false,i,function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        } else {\r\n            callback(null); //TODO now we just simply try to ignore faulty data import\r\n        }\r\n    }\r\n    function importRelations(node,jNode,callback){\r\n        //TODO now se use the pointer's 'set' attribute to decide if it is a set or a pointer really\r\n        var pointers = [],\r\n            sets = [],\r\n            needed = 0,\r\n            error = null,\r\n            i;\r\n        if(! typeof jNode.pointers === 'object'){\r\n            callback(null); //TODO should we drop an error???\r\n        } else {\r\n            for(i in jNode.pointers){\r\n                if(jNode.pointers[i].set === true){\r\n                    sets.push(i);\r\n                } else {\r\n                    pointers.push(i);\r\n                }\r\n            }\r\n\r\n            needed = sets.length + pointers.length;\r\n\r\n            if(needed > 0){\r\n                for(i=0;i<pointers.length;i++){\r\n                    importPointer(node,jNode,pointers[i],function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n                for(i=0;i<sets.length;i++){\r\n                    importSet(node,jNode,sets[i],function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        }\r\n    }\r\n    function importMeta(node,jNode,callback){\r\n        //TODO now this function searches the whole meta data for reference objects and load them, then call setMeta\r\n        var loadReference = function(refObj,cb){\r\n                getReferenceNode(refObj,function(err,rNode){\r\n                    if(err){\r\n                        cb(err);\r\n                    } else {\r\n                        if(rNode){\r\n                            refObj['$ref'] = _core.getPath(rNode);\r\n                        }\r\n                        cb(null);\r\n                    }\r\n                });\r\n            },\r\n            loadMetaReferences = function(jObject,cb){\r\n                var needed = 0,\r\n                    error = null;\r\n                for(var i in jObject){\r\n                    if(jObject[i] !== null && typeof jObject[i] === 'object'){\r\n                        needed++;\r\n                    }\r\n                }\r\n\r\n                if(needed>0){\r\n                    for(var i in jObject){\r\n                        if(jObject[i] !== null && typeof jObject[i] === 'object'){\r\n                            if(jObject[i]['$ref']){\r\n                                loadReference(jObject[i],function(err){\r\n                                    error = error || err;\r\n                                    if(--needed === 0){\r\n                                        cb(error);\r\n                                    }\r\n                                });\r\n                            } else {\r\n                                loadMetaReferences(jObject[i],function(err){\r\n                                    error = error || err;\r\n                                    if(--needed === 0){\r\n                                        cb(error);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    cb(error);\r\n                }\r\n            };\r\n\r\n        loadMetaReferences(jNode.meta || {}, function(err){\r\n            if(err){\r\n                callback(err);\r\n            } else {\r\n                META.setMeta(_core.getPath(node),jNode.meta || {});\r\n                callback(null);\r\n            }\r\n        });\r\n    };\r\n    function importRoot(jNode,callback){\r\n        //first we create the root node itself, then the other parts of the function is pretty much like the importNode\r\n        _root = _core.createNode({guid:jNode.GUID});\r\n        internalRefCreated('#',_root);\r\n        importAttributes(_root,jNode);\r\n        importRegistry(_root,jNode);\r\n        importChildren(_root,jNode,'#',function(err){\r\n            if(err){\r\n                callback(err);\r\n            } else {\r\n                importRelations(_root,jNode,function(err){\r\n                    if(err){\r\n                        callback(err);\r\n                    } else {\r\n                        importMeta(_root,jNode,function(err){\r\n                            callback(err,_root);\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    function clearOldNode(relid,guid,parentNode,callback){\r\n        var relids = _core.getChildrenRelids(parentNode);\r\n        if(relids.indexOf(relid) !== -1){\r\n            _core.loadChild(parentNode,relid,function(err,oldChild){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    if(_core.getGuid(oldChild) === guid){\r\n                        var root = _core.getRoot(oldChild);\r\n                        _core.deleteNode(oldChild);\r\n                        _core.persist(root,function(){\r\n                            callback(null)\r\n                        });\r\n                    } else {\r\n                        callback(null);\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            callback(null);\r\n        }\r\n    }\r\n    function getEmptyNode(jNode,parentNode,baseNode,noClear,callback){\r\n        var relids = _core.getChildrenRelids(parentNode),\r\n            returnNewNode = function(){\r\n                var node = _core.createNode({base:baseNode,parent:parentNode,relid:jNode.RELID,guid:jNode.GUID});\r\n                callback(null,node);\r\n            };\r\n        if(relids.indexOf(jNode.RELID) != -1){\r\n            _core.loadChild(parentNode,jNode.RELID,function(err,oldChild){\r\n                if(err){\r\n                    callback(err,null);\r\n                } else {\r\n                    if(_core.getGuid(oldChild) === jNode.GUID){\r\n                        if(noClear === true){\r\n                            callback(null,oldChild);\r\n                        } else {\r\n                            var root = _core.getRoot(oldChild);\r\n                            _core.deleteNode(oldChild);\r\n                            _core.persist(root,function(){\r\n                                returnNewNode();\r\n                            });\r\n                        }\r\n                    } else {\r\n                        returnNewNode();\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            returnNewNode();\r\n        }\r\n    }\r\n    function importNode(jNode,parentNode,intPath,noClear,callback){\r\n        //first we have to get the base of the node\r\n        if(jNode.pointers && jNode.pointers.base && jNode.pointers.base.to){\r\n            getReferenceNode(jNode.pointers.base.to[0],function(err,base){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                   getEmptyNode(jNode,parentNode,base,noClear,function(err,node){\r\n                        if(err){\r\n                            callback(err);\r\n                        } else {\r\n                            internalRefCreated(intPath,node);\r\n                            importAttributes(node,jNode);\r\n                            importRegistry(node,jNode);\r\n                            importChildren(node,jNode,intPath,function(err){\r\n                                if(err){\r\n                                    callback(err);\r\n                                } else {\r\n                                    importRelations(node,jNode,function(err){\r\n                                        if(err){\r\n                                            callback(err);\r\n                                        } else {\r\n                                            importMeta(node,jNode,function(err){\r\n                                                callback(err);\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            callback('wrong import format: base info is wrong');\r\n        }\r\n    }\r\n\r\n    function importing(core,parent,jNode,callback){\r\n        _core = core;\r\n        _cache = {};\r\n        _underImport = {};\r\n        _internalRefHash = {};\r\n        META.initialize(_core,_cache,function(){});\r\n\r\n        if(jNode.length){\r\n            //multiple objects\r\n            if(parent){\r\n                var needed = jNode.length,\r\n                    error = null;\r\n                _cache[core.getPath(parent)] = parent;\r\n                _root = core.getRoot(parent);\r\n                for(var i=0;i<jNode.length;i++){\r\n                    importNode(jNode[i],parent,'#['+i+']',false,function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback('no parent given!!!');\r\n            }\r\n        } else {\r\n            //single object\r\n            if(parent){\r\n                _cache[core.getPath(parent)] = parent;\r\n                _root = core.getRoot(parent);\r\n                importNode(jNode,parent,'#',false,callback);\r\n            } else {\r\n                importRoot(jNode,callback);\r\n            }\r\n        }\r\n    }\r\n\r\n    return importing;\r\n});\r\n\r\n\n",
    "// This import will only enter the outgoing relations and the internal ones.\r\n// This import will try to import an array of objects as well as a single object.\r\n// Although this import also asume that there is no loop in the references so it can simply wait for\r\n\r\ndefine('coreclient/copyimport',[\r\n    'coreclient/meta'\r\n],function(\r\n    BaseMeta\r\n    ){\r\n    var _core = null,\r\n        _root = null,\r\n        _cache = {},\r\n        _underImport = {},\r\n        _internalRefHash = {},\r\n        META = new BaseMeta();\r\n\r\n    function internalRefCreated(intPath,node){\r\n        _cache[_core.getPath(node)] = node;\r\n        _internalRefHash[intPath] = _core.getPath(node);\r\n        var callbacks = _underImport[intPath] || [];\r\n        delete _underImport[intPath];\r\n        for(var i=0;i<callbacks.length;i++){\r\n            callbacks[i](null,node);\r\n        }\r\n    }\r\n    function objectLoaded(error,node){\r\n        if(error === null){\r\n            _cache[_core.getPath(node)] = node;\r\n        }\r\n\r\n        var callbacks = _underImport[_core.getPath(node)] || [];\r\n        delete _underImport[_core.getPath(node)];\r\n        for(var i=0;i<callbacks.length;i++){\r\n            callbacks[i](error,node);\r\n        }\r\n    }\r\n    function isInternalReference(refObj){\r\n        if(refObj && typeof refObj['$ref'] === 'string'){\r\n            if(refObj['$ref'].indexOf('#') === 0){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function getReferenceNode(refObj,callback){\r\n        //we allow the internal references and the\r\n        if(refObj && typeof refObj['$ref'] === 'string'){\r\n            if(refObj['$ref'].indexOf('#') === 0){\r\n                //we assume that it is an internal reference\r\n                if(_internalRefHash[refObj['$ref']] !== undefined){\r\n                    callback(null,_cache[_internalRefHash[refObj['$ref']]]);\r\n                } else if(_underImport[refObj['$ref']] !== undefined){\r\n                    _underImport[refObj['$ref']].push(callback);\r\n                } else {\r\n                    _underImport[refObj['$ref']] = [callback]; //TODO we should check if the loading order is really finite this way\r\n                }\r\n            } else if(refObj['$ref'] === null){\r\n                callback(null,null);\r\n            } else {\r\n                if(_cache[refObj['$ref']]){\r\n                    callback(null,_cache[refObj['$ref']]);\r\n                } else if(_underImport[refObj['$ref']]){\r\n                    _underImport[refObj['$ref']].push(callback);\r\n                } else {\r\n                    _underImport[refObj['$ref']] = [callback];\r\n                    _core.loadByPath(_root,refObj['$ref'],function(err,node){\r\n                        if(err){\r\n                            objectLoaded(err, null);\r\n                        } else {\r\n                            if(refObj['GUID']){\r\n                                if(refObj['GUID'] === _core.getGuid(node)){\r\n                                    objectLoaded(err,node);\r\n                                } else {\r\n                                    objectLoaded('GUID mismatch',node);\r\n                                }\r\n                            } else {\r\n                                objectLoaded(err,node);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            callback(null,null);\r\n        }\r\n    }\r\n    function importChildren(node,jNode,pIntPath,callback){\r\n        if(jNode && jNode.children && jNode.children.length){\r\n            var needed = jNode.children.length;\r\n\r\n            if(needed > 0){\r\n                var error = null;\r\n                for(var i=0;i<jNode.children.length;i++){\r\n                    importNode(jNode.children[i],node,pIntPath+'/children['+i+']',function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n\r\n        } else {\r\n            callback(null); //TODO maybe we should be more strict\r\n        }\r\n    }\r\n    function importAttributes(node,jNode){\r\n        if(typeof jNode.attributes === 'object'){\r\n            for(var i in jNode.attributes){\r\n                _core.setAttribute(node,i,jNode.attributes[i]);\r\n            }\r\n        }\r\n    }\r\n    function importRegistry(node,jNode){\r\n        if(typeof jNode.registry === 'object'){\r\n            for(var i in jNode.registry){\r\n                _core.setRegistry(node,i,jNode.registry[i]);\r\n            }\r\n        }\r\n    }\r\n    function importPointer(node,jNode,pName,callback){\r\n        if(jNode.pointers[pName].to && jNode.pointers[pName].to.length > 0){\r\n            var needed = jNode.pointers[pName].to.length,\r\n                i,\r\n                error = null;\r\n\r\n            for(i=0;i<jNode.pointers[pName].to.length;i++){\r\n                getReferenceNode(jNode.pointers[pName].to[i],function(err,target){\r\n                    error = error || err;\r\n                    if(target !== undefined){\r\n                        _core.setPointer(node,pName,target);\r\n                    }\r\n\r\n                    if(--needed === 0){\r\n                        callback(error);\r\n                    }\r\n                });\r\n            }\r\n\r\n        } else {\r\n            callback(null);\r\n        }\r\n    }\r\n    function importSet(node,jNode,sName, callback){\r\n        if(jNode.pointers[sName].to && jNode.pointers[sName].to.length > 0){\r\n            var needed = 0,\r\n                importSetRegAndAtr = function(sOwner,sMember,atrAndReg){\r\n                    _core.addMember(sOwner,sName,sMember);\r\n                    var mPath = _core.getPath(sMember);\r\n                    atrAndReg.attributes = atrAndReg.attributes || {};\r\n                    for(var i in atrAndReg.attributes){\r\n                        _core.setMemberAttribute(sOwner,sName,mPath,i,atrAndReg.attributes[i]);\r\n                    }\r\n                    atrAndReg.registry = atrAndReg.registry || {};\r\n                    for(var i in atrAndReg.registry){\r\n                        _core.setMemberRegistry(sOwner,sName,mPath,i,atrAndReg.registry[i]);\r\n                    }\r\n                },\r\n                importSetReference = function(isTo,index,cb){\r\n                    var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\r\n                    getReferenceNode(jObj,function(err,sNode){\r\n                        if(err){\r\n                            cb(err);\r\n                        } else {\r\n                            if(sNode){\r\n                                var sOwner = isTo === true ? node : sNode,\r\n                                    sMember = isTo === true ? sNode : node;\r\n                                importSetRegAndAtr(sOwner,sMember,jObj);\r\n                            }\r\n                            cb(null);\r\n                        }\r\n                    });\r\n                },\r\n                error = null;\r\n\r\n            _core.createSet(node,sName);\r\n            needed = jNode.pointers[sName].to.length;\r\n            for(var i=0;i<jNode.pointers[sName].to.length;i++){\r\n                importSetReference(true,i,function(err){\r\n                    error = error || err;\r\n                    if(--needed === 0){\r\n                        callback(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            callback(null); //TODO now we just simply try to ignore faulty data import\r\n        }\r\n    }\r\n    function _importSet(node,jNode,sName, callback){\r\n        if(jNode.pointers[sName].to){\r\n            var needed = 0,\r\n                importSetRegAndAtr = function(sOwner,sMember,atrAndReg){\r\n                    _core.addMember(sOwner,sName,sMember);\r\n                    var mPath = _core.getPath(sMember);\r\n                    atrAndReg.attributes = atrAndReg.attributes || {};\r\n                    for(var i in atrAndReg.attributes){\r\n                        _core.setMemberAttribute(sOwner,sName,mPath,i,atrAndReg.attributes[i]);\r\n                    }\r\n                    atrAndReg.registry = atrAndReg.registry || {};\r\n                    for(var i in atrAndReg.registry){\r\n                        _core.setMemberRegistry(sOwner,sName,mPath,i,atrAndReg.registry[i]);\r\n                    }\r\n                },\r\n                importSetReference = function(isTo,index,cb){\r\n                    var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\r\n                    getReferenceNode(jObj,function(err,sNode){\r\n                        if(err){\r\n                            cb(err);\r\n                        } else {\r\n                            if(sNode){\r\n                                var sOwner = isTo === true ? node : sNode,\r\n                                    sMember = isTo === true ? sNode : node;\r\n                                importSetRegAndAtr(sOwner,sMember,jObj);\r\n                            }\r\n                            cb(null);\r\n                        }\r\n                    });\r\n                },\r\n                error = null;\r\n\r\n            if(jNode.pointers[sName].to.length > 0){\r\n                needed += jNode.pointers[sName].to.length;\r\n                _core.createSet(node,sName);\r\n            }\r\n\r\n            if(needed > 0){\r\n                for(var i=0;i<jNode.pointers[sName].to.length;i++){\r\n                    importSetReference(true,i,function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        } else {\r\n            callback(null); //TODO now we just simply try to ignore faulty data import\r\n        }\r\n    }\r\n    function importRelations(node,jNode,callback){\r\n        //TODO now se use the pointer's 'set' attribute to decide if it is a set or a pointer really\r\n        var pointers = [],\r\n            sets = [],\r\n            needed = 0,\r\n            error = null,\r\n            i;\r\n        if(! typeof jNode.pointers === 'object'){\r\n            callback(null); //TODO should we drop an error???\r\n        } else {\r\n            for(i in jNode.pointers){\r\n                if(jNode.pointers[i].set === true){\r\n                    sets.push(i);\r\n                } else {\r\n                    pointers.push(i);\r\n                }\r\n            }\r\n\r\n            needed = sets.length + pointers.length;\r\n\r\n            if(needed > 0){\r\n                for(i=0;i<pointers.length;i++){\r\n                    importPointer(node,jNode,pointers[i],function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n                for(i=0;i<sets.length;i++){\r\n                    importSet(node,jNode,sets[i],function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback(null);\r\n            }\r\n        }\r\n    }\r\n    function importMeta(node,jNode,callback){\r\n\r\n        //TODO now this function searches the whole meta data for reference objects and load them, then call setMeta\r\n        var loadReference = function(refObj,cb){\r\n                getReferenceNode(refObj,function(err,rNode){\r\n                    if(err){\r\n                        cb(err);\r\n                    } else {\r\n                        if(rNode){\r\n                            refObj['$ref'] = _core.getPath(rNode);\r\n                        }\r\n                        cb(null);\r\n                    }\r\n                });\r\n            },\r\n            loadMetaReferences = function(jObject,cb){\r\n                var needed = 0,\r\n                    error = null;\r\n                for(var i in jObject){\r\n                    if(jObject[i] !== null && typeof jObject[i] === 'object'){\r\n                        needed++;\r\n                    }\r\n                }\r\n\r\n                if(needed>0){\r\n                    for(var i in jObject){\r\n                        if(jObject[i] !== null && typeof jObject[i] === 'object'){\r\n                            if(jObject[i]['$ref']){\r\n                                loadReference(jObject[i],function(err){\r\n                                    error = error || err;\r\n                                    if(--needed === 0){\r\n                                        cb(error);\r\n                                    }\r\n                                });\r\n                            } else {\r\n                                loadMetaReferences(jObject[i],function(err){\r\n                                    error = error || err;\r\n                                    if(--needed === 0){\r\n                                        cb(error);\r\n                                    }\r\n                                })\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    cb(error);\r\n                }\r\n            };\r\n\r\n        loadMetaReferences(jNode.meta || {}, function(err){\r\n            if(err){\r\n                callback(err);\r\n            } else {\r\n                META.setMeta(_core.getPath(node),jNode.meta || {});\r\n                callback(null);\r\n            }\r\n        });\r\n    };\r\n    function importRoot(jNode,callback){\r\n        //first we create the root node itself, then the other parts of the function is pretty much like the importNode\r\n\r\n        _root = _core.createNode();\r\n        internalRefCreated('#',_root);\r\n        importAttributes(_root,jNode);\r\n        importRegistry(_root,jNode);\r\n        importChildren(_root,jNode,'#',function(err){\r\n            if(err){\r\n                callback(err);\r\n            } else {\r\n                importRelations(_root,jNode,function(err){\r\n                    if(err){\r\n                        callback(err);\r\n                    } else {\r\n                        importMeta(_root,jNode,function(err){\r\n                            callback(err,_root);\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n    function importNode(jNode,parentNode,intPath,callback){\r\n        //return callback('not implemented');\r\n        //first we have to get the base of the node\r\n        if(jNode.pointers && jNode.pointers.base && jNode.pointers.base.to){\r\n            getReferenceNode(jNode.pointers.base.to[0],function(err,base){\r\n                if(err){\r\n                    callback(err);\r\n                } else {\r\n                    //now we are ready to create the node itself\r\n                    var node = _core.createNode({base:base,parent:parentNode});\r\n                    internalRefCreated(intPath,node);\r\n                    importAttributes(node,jNode);\r\n                    importRegistry(node,jNode);\r\n                    importChildren(node,jNode,intPath,function(err){\r\n                        if(err){\r\n                            callback(err);\r\n                        } else {\r\n                            importRelations(node,jNode,function(err){\r\n                                if(err){\r\n                                    callback(err);\r\n                                } else {\r\n                                    importMeta(node,jNode,callback);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        } else {\r\n            callback('wrong import format: base info is wrong');\r\n        }\r\n    }\r\n    function importing(core,parent,jNode,callback){\r\n        _core = core;\r\n        _cache = {};\r\n        _underImport = {};\r\n        _internalRefHash = {};\r\n        META.initialize(_core,_cache,function(){});\r\n\r\n        if(jNode.length){\r\n            //multiple objects\r\n            if(parent){\r\n                var needed = jNode.length,\r\n                    error = null;\r\n                _cache[core.getPath(parent)] = parent;\r\n                _root = core.getRoot(parent);\r\n                for(var i=0;i<jNode.length;i++){\r\n                    importNode(jNode[i],parent,'#['+i+']',function(err){\r\n                        error = error || err;\r\n                        if(--needed === 0){\r\n                            callback(error);\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                callback('no parent given!!!');\r\n            }\r\n        } else {\r\n            //single object\r\n            if(parent){\r\n                _cache[core.getPath(parent)] = parent;\r\n                _root = core.getRoot(parent);\r\n                importNode(jNode,parent,'#',callback);\r\n            } else {\r\n                importRoot(jNode,callback);\r\n            }\r\n        }\r\n    }\r\n    return importing;\r\n});\n",
    "define('coreclient/serialization',['util/assert'],function(ASSERT){\r\n\r\n    \"use strict\";\r\n    var _nodes = {},\r\n        _core = null,\r\n        _pathToGuidMap = {},\r\n        _guidKeys = [], //ordered list of GUIDs\r\n        _extraBasePaths = {},\r\n        _export = {},\r\n        _import = {},\r\n        _newNodeGuids = [],\r\n        _removedNodeGuids = [],\r\n        _updatedNodeGuids = [],\r\n        _log = \"\";\r\n\r\n    function log(txt){\r\n        if(_log){\r\n            _log+=\"\\n\"+txt;\r\n        } else {\r\n            _log = \"\"+txt;\r\n        }\r\n    }\r\n    function exportLibrary(core,libraryRoot,callback){\r\n        //initialization\r\n        _core = core;\r\n        _nodes = {};\r\n        _pathToGuidMap = {};\r\n        _guidKeys = [];\r\n        _extraBasePaths = {};\r\n        _export = {};\r\n\r\n        //loading all library element\r\n        gatherNodesSlowly(libraryRoot,function(err){\r\n            if(err){\r\n                return callback(err);\r\n            }\r\n\r\n            _guidKeys = _guidKeys.sort();\r\n            gatherAncestors(); //collecting the 'external' base classes - probably we should avoid these\r\n\r\n            var keys = Object.keys(_extraBasePaths),\r\n                i;\r\n            _export.bases = {};\r\n            for(i=0;i<keys.length;i++){\r\n                _export.bases[_extraBasePaths[keys[i]]] = keys[i];\r\n            }\r\n            //_export.bases = _extraBasePaths; //we save this info alongside with the library export, to be on the safe side\r\n\r\n            _export.root = getLibraryRootInfo(libraryRoot);\r\n            _export.relids = getRelIdInfo();\r\n            _export.containment = {}; fillContainmentTree(libraryRoot,_export.containment);\r\n            _export.nodes = getNodesData();\r\n            _export.metaSheets = core.getParent(libraryRoot) ? getMetaSheetInfo(_core.getRoot(libraryRoot)) : {}; //we export MetaSheet info only if not the whole project is exported!!!\r\n\r\n            callback(null,_export);\r\n\r\n        });\r\n    }\r\n    function getMetaSheetInfo(root){\r\n        var getMemberRegistry = function(setname,memberpath){\r\n                var names = _core.getMemberRegistryNames(root,setname,memberpath),\r\n                    i,\r\n                    registry = {};\r\n                for(i=0;i<names.length;i++){\r\n                    registry[names[i]] = _core.getMemberRegistry(root,setname,memberpath,names[i]);\r\n                }\r\n                return registry;\r\n            },\r\n            getMemberAttributes = function(setname,memberpath){\r\n                var names = _core.getMemberAttributeNames(root,setname,memberpath),\r\n                    i,\r\n                    attributes = {};\r\n                for(i=0;i<names.length;i++){\r\n                    attributes[names[i]] = _core.getMemberAttribute(root,setname,memberpath,names[i]);\r\n                }\r\n                return attributes;\r\n            },\r\n            getRegistryEntry = function(setname){\r\n                var index = registry.length;\r\n\r\n                while(--index >= 0){\r\n                    if(registry[index].SetID === setname){\r\n                        return registry[index];\r\n                    }\r\n                }\r\n                return {};\r\n            },\r\n            sheets = {},\r\n            registry = _core.getRegistry(root,\"MetaSheets\"),\r\n            keys = _core.getSetNames(root),\r\n            elements,guid,\r\n            i,j;\r\n        for(i=0;i<keys.length;i++){\r\n            if(keys[i].indexOf(\"MetaAspectSet\") === 0){\r\n                elements = _core.getMemberPaths(root,keys[i]);\r\n                for(j=0;j<elements.length;j++){\r\n                    guid = _pathToGuidMap[elements[j]] || _extraBasePaths[elements[j]];\r\n                    if(guid){\r\n                        sheets[keys[i]] = sheets[keys[i]] || {};\r\n                        sheets[keys[i]][guid] = {registry:getMemberRegistry(keys[i],elements[j]),attributes:getMemberAttributes(keys[i],elements[j])};\r\n                    }\r\n                }\r\n\r\n                if(sheets[keys[i]] && keys[i] !== \"MetaAspectSet\"){\r\n                    //we add the global registry values as well\r\n                    sheets[keys[i]].global = getRegistryEntry(keys[i]);\r\n                }\r\n            }\r\n        }\r\n        console.log('sheets',sheets);\r\n        return sheets;\r\n    }\r\n    function importMetaSheetInfo(root){\r\n        var setMemberAttributesAndRegistry = function(setname,memberguid){\r\n                var attributes = oldSheets[setname][memberguid].attributes || {},\r\n                    registry = oldSheets[setname][memberguid].registry || {},\r\n                    keys,i;\r\n                keys = Object.keys(attributes);\r\n                for(i=0;i<keys.length;i++) {\r\n                    _core.setMemberAttribute(root,setname,_core.getPath(_nodes[memberguid]),keys[i],attributes[keys[i]]);\r\n                }\r\n                keys = Object.keys(registry);\r\n                for(i=0;i<keys.length;i++) {\r\n                    _core.setMemberRegistry(root,setname,_core.getPath(_nodes[memberguid]),keys[i],registry[keys[i]]);\r\n                }\r\n            },\r\n            updateSheet = function(name){\r\n                //the removed object should be already removed...\r\n                //if some element is extra in the place of import, then it stays untouched\r\n                var oldMemberGuids = Object.keys(oldSheets[name]),\r\n                    i;\r\n                oldMemberGuids.splice(oldMemberGuids.indexOf(\"global\"),1);\r\n                for(i=0;i<oldMemberGuids.length;i++) {\r\n                    _core.addMember(root,name,_nodes[oldMemberGuids[i]]);\r\n                    setMemberAttributesAndRegistry(name,oldMemberGuids[i]);\r\n                }\r\n            },\r\n            addSheet = function(name) {\r\n                var registry = JSON.parse(JSON.stringify(_core.getRegistry(root,\"MetaSheets\")) || {}),\r\n                    i,\r\n                    memberpath,\r\n                    memberguids = Object.keys(oldSheets[name]);\r\n\r\n                memberguids.splice(memberguids.indexOf('global'),1);\r\n\r\n                if(name !== 'MetaAspectSet'){\r\n                  registry.push(oldSheets[name].global);\r\n                  _core.setRegistry(root,\"MetaSheets\",registry);\r\n                }\r\n\r\n                _core.createSet(root,name);\r\n                for(i=0;i<memberguids.length;i++) {\r\n                    memberpath = _core.getPath(_nodes[memberguids[i]]);\r\n                    _core.addMember(root,name,_nodes[memberguids[i]]);\r\n                    setMemberAttributesAndRegistry(name,memberguids[i]);\r\n                }\r\n            },\r\n            oldSheets = _import.metaSheets || {},\r\n            newSheets = _export.metaSheets || {},\r\n            oldSheetNames = Object.keys(oldSheets),\r\n            newSheetNames = Object.keys(newSheets),\r\n            i;\r\n\r\n        for(i=0;i<oldSheetNames.length;i++) {\r\n            if(newSheetNames.indexOf(oldSheetNames[i]) !== -1){\r\n                updateSheet(oldSheetNames[i]);\r\n            } else {\r\n                addSheet(oldSheetNames[i]);\r\n            }\r\n        }\r\n    }\r\n    function getLibraryRootInfo(node){\r\n        return {\r\n            path: _core.getPath(node),\r\n            guid: _core.getGuid(node)\r\n        };\r\n    }\r\n    function gatherNodesSlowly(node,callback){\r\n        _core.loadSubTree(node,function(err,nodes){\r\n            var guid,i;\r\n            if(!err && nodes){\r\n                for(i=0;i<nodes.length;i++){\r\n                    guid = _core.getGuid(nodes[i]);\r\n                    _nodes[guid] = nodes[i];\r\n                    _guidKeys.push(guid);\r\n                    _pathToGuidMap[_core.getPath(nodes[i])] = guid;\r\n                }\r\n                callback(null);\r\n            } else {\r\n                callback(err);\r\n            }\r\n        });\r\n    }\r\n    function gatherAncestors(){\r\n        //this function inserts the needed base classes which were not included in the library\r\n        var i,base,guid;\r\n        for(i=0;i<_guidKeys.length;i++){\r\n            base = _nodes[_guidKeys[i]];\r\n            while(base!== null){\r\n                guid = _core.getGuid(base);\r\n                if(!_nodes[guid]) {\r\n                    _nodes[guid] = base;\r\n                    _extraBasePaths[_core.getPath(base)] = guid;\r\n                } else if(_guidKeys.indexOf(guid) === -1){\r\n                    _extraBasePaths[_core.getPath(base)] = guid;\r\n                }\r\n                base = _core.getBase(base);\r\n            }\r\n        }\r\n    }\r\n    function pathsToSortedGuidList(pathsList){ //it will also filter out not wanted elements\r\n        var i,guids = [];\r\n        for(i=0;i<pathsList.length;i++){\r\n            if(_pathToGuidMap[pathsList[i]]){\r\n                guids.push(_pathToGuidMap[pathsList[i]]);\r\n            }\r\n        }\r\n        return guids.sort();\r\n    }\r\n    function fillContainmentTree(node,myTreeObject){\r\n        var childrenGuids = pathsToSortedGuidList(_core.getChildrenPaths(node)),\r\n            i;\r\n        for(i=0;i<childrenGuids.length;i++){\r\n            myTreeObject[childrenGuids[i]] = {};\r\n            fillContainmentTree(_nodes[childrenGuids[i]],myTreeObject[childrenGuids[i]]);\r\n        }\r\n    }\r\n    function fillInheritanceTree(node,myTreeObject){\r\n        var i,\r\n            descendantGuids = pathsToSortedGuidList(_core.getCollectionPaths(node,'base'));\r\n        for(i=0;i<descendantGuids.length;i++){\r\n            myTreeObject[descendantGuids[i]] = {};\r\n            fillInheritanceTree(_nodes[descendantGuids[i]],myTreeObject[descendantGuids[i]]);\r\n        }\r\n    }\r\n    function getRelIdInfo(){\r\n        var i,\r\n            relIdInfo={};\r\n        for(i=0;i<_guidKeys.length;i++){\r\n            relIdInfo[_guidKeys[i]] = _core.getRelid(_nodes[_guidKeys[i]]);\r\n        }\r\n        return relIdInfo;\r\n    }\r\n    function getNodesData(){\r\n        var data = {},\r\n            i;\r\n        for(i=0;i<_guidKeys.length;i++){\r\n            data[_guidKeys[i]] = getNodeData(_nodes[_guidKeys[i]]);\r\n        }\r\n        return data;\r\n    }\r\n    function getNodeData(node){\r\n        /*{\r\n            //only the ones defined on this level\r\n            attributes:{name:value},\r\n            base:GUID,\r\n            registry:{name:value},\r\n            parent:GUID,\r\n            pointers:{name:targetGuid},\r\n            sets:{name:[{guid:GUID,attributes:{name:value},registy:{name:value}}]}\r\n            meta:{}\r\n        }*/\r\n        return {\r\n            attributes:getAttributesOfNode(node),\r\n            base: _core.getBase(node) ? _core.getGuid(_core.getBase(node)) : null,\r\n            meta:pathsToGuids(JSON.parse(JSON.stringify(_core.getOwnJsonMeta(node)) || {})),\r\n            parent:_core.getParent(node) ? _core.getGuid(_core.getParent(node)) : null,\r\n            pointers:getPointersOfNode(node),\r\n            registry:getRegistryOfNode(node),\r\n            sets:getSetsOfNode(node)\r\n        };\r\n    }\r\n    function baseGuid(path){\r\n       /*var keys = Object.keys(_extraBasePaths),\r\n            i;\r\n        for(i=0;i<keys.length;i++){\r\n            if(_extraBasePaths[keys[i]] === path){\r\n                return keys[i];\r\n            }\r\n        }\r\n        return null;*/\r\n        return _extraBasePaths[path];\r\n    }\r\n\r\n    var sortMultipleArrays = function () {\r\n        var index = getSortedIndex(arguments[0]);\r\n        for (var j = 0; j < arguments.length; j++) {\r\n            var _arr = arguments[j].slice();\r\n            for(var i = 0; i < _arr.length; i++) {\r\n                arguments[j][i] = _arr[index[i]];\r\n            }\r\n        }\r\n    };\r\n\r\n    var getSortedIndex = function (arr) {\r\n        var index = [];\r\n        for (var i = 0; i < arr.length; i++) {\r\n            index.push(i);\r\n        }\r\n        index = index.sort((function(arr){\r\n            return function (a, b) {return ((arr[a] > arr[b]) ? 1 : ((arr[a] < arr[b]) ? -1 : 0));\r\n            };\r\n        })(arr));\r\n        return index;\r\n    };\r\n\r\n    function pathsToGuids(jsonObject){\r\n        if(jsonObject && typeof jsonObject === 'object'){\r\n            var keys = Object.keys(jsonObject),\r\n                i, j, k,toDelete,tArray;\r\n\r\n            for(i=0;i<keys.length;i++){\r\n                if(keys[i] === 'items') {\r\n                    //here comes the transformation itself\r\n                    toDelete = [];\r\n                    for (j = 0; j < jsonObject.items.length; j++) {\r\n                        if (_pathToGuidMap[jsonObject.items[j]]) {\r\n                            jsonObject.items[j] = _pathToGuidMap[jsonObject.items[j]];\r\n                        } else if (baseGuid(jsonObject.items[j])) {\r\n                            jsonObject.items[j] = baseGuid(jsonObject.items[j]);\r\n                        } else {\r\n                            toDelete.push(j);\r\n                        }\r\n                    }\r\n\r\n                    if (toDelete.length > 0) {\r\n                        toDelete = toDelete.sort();\r\n                        toDelete = toDelete.reverse();\r\n                        for (j = 0; j < toDelete.length; j++) {\r\n                            jsonObject.items.splice(toDelete[j], 1);\r\n                            jsonObject.minItems.splice(toDelete[j], 1);\r\n                            jsonObject.maxItems.splice(toDelete[j], 1);\r\n                        }\r\n                    }\r\n                    sortMultipleArrays(jsonObject.items, jsonObject.minItems, jsonObject.maxItems);\r\n                } else if(keys[i] === 'aspects'){\r\n                    //aspects are a bunch of named path list, so we have to handle them separately\r\n                    tArray = Object.keys(jsonObject[keys[i]]);\r\n                    for(j=0;j<tArray.length;j++){\r\n                        //here comes the transformation itself\r\n                        toDelete = [];\r\n                        for(k=0;k<jsonObject.aspects[tArray[j]].length;k++) {\r\n                            if (_pathToGuidMap[jsonObject.aspects[tArray[j]][k]]) {\r\n                                jsonObject.aspects[tArray[j]][k] = _pathToGuidMap[jsonObject.aspects[tArray[j]][k]];\r\n                            } else if (baseGuid(jsonObject.aspects[tArray[j]][k])) {\r\n                                jsonObject.aspects[tArray[j]][k] = baseGuid(jsonObject.aspects[tArray[j]][k]);\r\n                            } else {\r\n                                toDelete.push(k);\r\n                            }\r\n                        }\r\n\r\n                        if (toDelete.length > 0) {\r\n                            toDelete = toDelete.sort();\r\n                            toDelete = toDelete.reverse();\r\n                            for (k = 0; k < toDelete.length; k++) {\r\n                                jsonObject.aspects[tArray[j]].splice(toDelete[k], 1);\r\n                            }\r\n                        }\r\n\r\n                        jsonObject.aspects[tArray[j]] = jsonObject.aspects[tArray[j]].sort();\r\n\r\n                    }\r\n                } else {\r\n                    if(typeof jsonObject[keys[i]] === 'object'){\r\n                        jsonObject[keys[i]] = pathsToGuids(jsonObject[keys[i]]);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n        return jsonObject;\r\n    }\r\n    function getAttributesOfNode(node){\r\n        var names = _core.getOwnAttributeNames(node).sort(),\r\n            i,\r\n            result = {};\r\n        for(i=0;i<names.length;i++){\r\n            result[names[i]] = _core.getAttribute(node,names[i]);\r\n        }\r\n        return result;\r\n    }\r\n    function getRegistryOfNode(node){\r\n        var names = _core.getOwnRegistryNames(node).sort(),\r\n            i,\r\n            result = {};\r\n        for(i=0;i<names.length;i++){\r\n            result[names[i]] = _core.getRegistry(node,names[i]);\r\n        }\r\n        return result;\r\n    }\r\n    function getPointersOfNode(node){\r\n        var names = _core.getOwnPointerNames(node).sort(),\r\n            i,\r\n            result = {},\r\n            target;\r\n        for(i=0;i<names.length;i++){\r\n            target = _core.getPointerPath(node,names[i]);\r\n            if(_pathToGuidMap[target] || baseGuid(target) || target === null){\r\n                result[names[i]] = _pathToGuidMap[target] || baseGuid(target) || null;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    function getOwnMemberPaths(node,setName){\r\n        var base = _core.getBase(node),\r\n            baseMembers = base === null ? [] : _core.getMemberPaths(base,setName),\r\n            members = _core.getMemberPaths(node,setName),\r\n            ownMembers=[],\r\n            i;\r\n        for(i=0;i<members.length;i++){\r\n            if(baseMembers.indexOf(members[i]) === -1){\r\n                ownMembers.push(members[i]);\r\n            }\r\n        }\r\n        return ownMembers;\r\n    }\r\n    function getSetsOfNode(node){\r\n        var names = _core.getSetNames(node).sort(),\r\n            i, j, k,\r\n            result = {},\r\n            targetGuids,\r\n            attributeNames,\r\n            registryNames,\r\n            memberInfo,\r\n            path;\r\n        for(i=0;i<names.length;i++){\r\n            targetGuids = pathsToSortedGuidList(getOwnMemberPaths(node,names[i]));\r\n            result[names[i]] = [];\r\n            for(j=0;j<targetGuids.length;j++){\r\n                path = _core.getPath(_nodes[targetGuids[j]]);\r\n                memberInfo = {\r\n                    attributes:{},\r\n                    guid:targetGuids[j],\r\n                    registry:{}\r\n                };\r\n\r\n                //attributes\r\n                attributeNames = _core.getMemberAttributeNames(node,names[i],path).sort();\r\n                for(k=0;k<attributeNames.length;k++){\r\n                    memberInfo.attributes[attributeNames[k]] = _core.getMemberAttribute(node,names[i],path,attributeNames[k]);\r\n                }\r\n\r\n                //registry\r\n                registryNames = _core.getMemberRegistryNames(node,names[i],path).sort();\r\n                for(k=0;k<registryNames.length;k++){\r\n                    memberInfo.registry[registryNames[k]] = _core.getMemberRegistry(node,names[i],path,registryNames[k]);\r\n                }\r\n\r\n                result[names[i]].push(memberInfo);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function logId(nodes,id){\r\n        var txtId = id+\"\";\r\n        if(nodes[id] && nodes[id].attributes && nodes[id].attributes.name){\r\n            txtId = nodes[id].attributes.name+\"(\"+id+\")\";\r\n        }\r\n\r\n        return txtId;\r\n    }\r\n    function loadImportBases(guids,root,callback){\r\n        var needed = [],\r\n            error = null,\r\n            stillToGo = 0,\r\n            i,\r\n            guidList = Object.keys(guids),\r\n            loadBase = function(guid,path,cb){\r\n                _core.loadByPath(root,path,function(err,node){\r\n                    if(err){\r\n                        return cb(err);\r\n                    }\r\n                    if(_core.getGuid(node) !== guid){\r\n                        return cb(\"GUID mismatch\");\r\n                    }\r\n\r\n                    _nodes[guid] = node;\r\n                    cb(null);\r\n                });\r\n            };\r\n\r\n        for(i=0;i<guidList.length;i++){\r\n            if(_nodes[guidList[i]] === undefined){\r\n                needed.push(guidList[i]);\r\n            }\r\n        }\r\n\r\n        if(needed.length > 0){\r\n            stillToGo = needed.length;\r\n            for(i=0;i<needed.length;i++){\r\n                loadBase(needed[i],guids[needed[i]],function(err){\r\n                    error = error || err;\r\n                    if(--stillToGo === 0){\r\n                        callback(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            return callback(null);\r\n        }\r\n\r\n\r\n    }\r\n    function importLibrary(core,originLibraryRoot,updatedLibraryJson,callback){\r\n        _core = core;\r\n        _import = updatedLibraryJson;\r\n        _newNodeGuids = [];\r\n        _updatedNodeGuids = [];\r\n        _removedNodeGuids = [];\r\n        _log = \"\";\r\n\r\n        synchronizeRoots(originLibraryRoot,_import.root.guid);\r\n        exportLibrary(core,originLibraryRoot,function(err){\r\n            //we do not need the returned json object as that is stored in our global _export variable\r\n            if(err){\r\n                return callback(err);\r\n            }\r\n\r\n            //now we will search for the bases of the import and load them\r\n            loadImportBases(_import.bases,_core.getRoot(originLibraryRoot),function(err){\r\n                if(err){\r\n                    return callback(err);\r\n                }\r\n\r\n                //now we fill the insert/update/remove lists of GUIDs\r\n                var oldkeys = Object.keys(_export.nodes),\r\n                    newkeys = Object.keys(_import.nodes),\r\n                    i;\r\n\r\n                //TODO now we make three rounds although one would be sufficient on ordered lists\r\n                for(i=0;i<oldkeys.length;i++){\r\n                    if(newkeys.indexOf(oldkeys[i]) === -1){\r\n                        log(\"node \"+logId(_export.nodes,oldkeys[i])+\", all of its sub-types and its children will be removed\");\r\n                        _removedNodeGuids.push(oldkeys[i]);\r\n                    }\r\n                }\r\n\r\n                for(i=0;i<oldkeys.length;i++){\r\n                    if(newkeys.indexOf(oldkeys[i]) !== -1){\r\n                        log(\"node \"+logId(_export.nodes,oldkeys[i])+\" will be updated\")\r\n                        _updatedNodeGuids.push(oldkeys[i]);\r\n                    }\r\n                }\r\n\r\n                for(i=0;i<newkeys.length;i++){\r\n                    if(oldkeys.indexOf(newkeys[i]) === -1){\r\n                        log(\"node \"+logId(_import.nodes,newkeys[i])+\" will be added\")\r\n                        _newNodeGuids.push(newkeys[i]);\r\n                    }\r\n                }\r\n\r\n                //Now we normalize the removedGUIDs by containment and remove them\r\n                var toDelete = [],\r\n                    parent;\r\n                for(i=0;i<_removedNodeGuids.length;i++){\r\n                    parent = _core.getParent(_nodes[_removedNodeGuids[i]]);\r\n                    if(parent && _removedNodeGuids.indexOf(_core.getGuid(parent)) === -1){\r\n                        toDelete.push(_removedNodeGuids[i]);\r\n                    }\r\n                }\r\n                //and as a final step we remove all that is needed\r\n                for(i=0;i<toDelete.length;i++){\r\n                    _core.deleteNode(_nodes[toDelete[i]]);\r\n                }\r\n\r\n                //as a second step we should deal with the updated nodes\r\n                //we should go among containment hierarchy\r\n                updateNodes(_import.root.guid,null,_import.containment);\r\n\r\n                //now update inheritance chain\r\n                //we assume that our inheritance chain comes from the FCO and that it is identical everywhere\r\n                updateInheritance();\r\n\r\n                //now we can add or modify the relations of the nodes - we go along the hierarchy chain\r\n                updateRelations();\r\n\r\n                //finally we need to update the meta rules of each node - again along the containment hierarchy\r\n                updateMetaRules(_import.root.guid,_import.containment);\r\n\r\n                //after everything is done we try to synchronize the metaSheet info\r\n                importMetaSheetInfo(_core.getRoot(originLibraryRoot));\r\n\r\n                callback(null,_log);\r\n            });\r\n        });\r\n    }\r\n\r\n    function synchronizeRoots(oldRoot,newGuid){\r\n        _core.setGuid(oldRoot,newGuid);\r\n    }\r\n    //it will update the modified nodes and create the new ones regarding their place in the hierarchy chain\r\n    function updateNodes(guid,parent,containmentTreeObject){\r\n        if(_updatedNodeGuids.indexOf(guid) !== -1){\r\n            updateNode(guid,parent);\r\n        }\r\n\r\n        var keys = Object.keys(containmentTreeObject),\r\n            i,\r\n            node = _nodes[guid],\r\n            relid;\r\n\r\n        for(i=0;i<keys.length;i++){\r\n            if(_updatedNodeGuids.indexOf(keys[i]) === -1){\r\n                relid = _import.relids[keys[i]];\r\n                if(_core.getChildrenRelids(node).indexOf(relid) !== -1){\r\n                    relid = undefined;\r\n                }\r\n                //this child is a new one so we should create\r\n                _nodes[keys[i]] = _core.createNode({parent:node,guid:keys[i],relid:relid});\r\n                addNode(keys[i]);\r\n            }\r\n            updateNodes(keys[i],node,containmentTreeObject[keys[i]]);\r\n        }\r\n    }\r\n\r\n    function updateRegistry(guid){\r\n        var keys, i,\r\n            node = _nodes[guid],\r\n            jsonNode = _import.nodes[guid];\r\n\r\n        keys = _core.getOwnRegistryNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.delRegistry(node,keys[i]);\r\n        }\r\n        keys = Object.keys(jsonNode.registry);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.setRegistry(node,keys[i],jsonNode.registry[keys[i]]);\r\n        }\r\n    }\r\n    function updateAttributes(guid){\r\n        var keys, i,\r\n            node = _nodes[guid],\r\n            jsonNode = _import.nodes[guid];\r\n\r\n        keys = _core.getOwnAttributeNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.delAttribute(node,keys[i]);\r\n        }\r\n        keys = Object.keys(jsonNode.attributes);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.setAttribute(node,keys[i],jsonNode.attributes[keys[i]]);\r\n        }\r\n    }\r\n    //this function does not cover relations - it means only attributes and registry have been updated here\r\n    function updateNode(guid,parent){\r\n        //first we check if the node have to be moved\r\n        var node = _nodes[guid];\r\n\r\n        if(parent && _core.getParent(node) && _core.getGuid(parent) !== _core.getGuid(_core.getParent(node))){\r\n            //parent changed so it has to be moved...\r\n            _nodes[guid] = _core.moveNode(node,parent);\r\n        }\r\n\r\n        updateAttributes(guid);\r\n        updateRegistry(guid);\r\n    }\r\n\r\n    //this function doesn't not cover relations - so only attributes and registry have been taken care of here\r\n    function addNode(guid){\r\n        //at this point we assume that an empty vessel has been already created and part of the _nodes\r\n        updateAttributes(guid);\r\n        updateRegistry(guid);\r\n    }\r\n\r\n    function getInheritanceBasedGuidOrder(){\r\n        var inheritanceOrdered = Object.keys(_import.nodes).sort(),i= 0,baseGuid,baseIndex;\r\n        while(i<inheritanceOrdered.length){\r\n            baseGuid = _import.nodes[inheritanceOrdered[i]].base;\r\n            if(baseGuid){\r\n                baseIndex = inheritanceOrdered.indexOf(baseGuid);\r\n                if(baseIndex > i){\r\n                    inheritanceOrdered.splice(baseIndex,1);\r\n                    inheritanceOrdered.splice(i,0,baseGuid);\r\n                } else {\r\n                    ++i;\r\n                }\r\n            } else {\r\n                ++i;\r\n            }\r\n        }\r\n        return inheritanceOrdered;\r\n    }\r\n    function updateRelations(){\r\n        var guids = getInheritanceBasedGuidOrder(),i;\r\n        for(i=0;i<guids.length;i++){\r\n            updateNodeRelations(guids[i]);\r\n        }\r\n    }\r\n\r\n    function updateNodeRelations(guid){\r\n        //although it is possible that we set the base pointer at this point we should go through inheritance just to be sure\r\n        var node = _nodes[guid],\r\n            jsonNode = _import.nodes[guid],\r\n            keys, i, j, k,target,memberGuid;\r\n\r\n        //pointers\r\n        keys = _core.getOwnPointerNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.deletePointer(node,keys[i]);\r\n        }\r\n        keys = Object.keys(jsonNode.pointers);\r\n        for(i=0;i<keys.length;i++){\r\n            target = jsonNode.pointers[keys[i]];\r\n            if(target === null){\r\n                _core.setPointer(node,keys[i],null);\r\n            } else if(_nodes[target] && _removedNodeGuids.indexOf(target) === -1){\r\n                _core.setPointer(node,keys[i],_nodes[target]);\r\n            } else {\r\n                console.log(\"error handling needed???!!!???\");\r\n            }\r\n        }\r\n\r\n        //sets\r\n        keys = _core.getSetNames(node);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.deleteSet(node,keys[i]);\r\n        }\r\n        keys = Object.keys(jsonNode.sets);\r\n        for(i=0;i<keys.length;i++){\r\n            //for every set we create it, go through its members...\r\n            _core.createSet(node,keys[i]);\r\n            for(j=0;j<jsonNode.sets[keys[i]].length;j++){\r\n                memberGuid = jsonNode.sets[keys[i]][j].guid;\r\n                if(_nodes[memberGuid]){\r\n                    _core.addMember(node,keys[i],_nodes[memberGuid]);\r\n                    for(k in jsonNode.sets[keys[i]][j].attributes){\r\n                        _core.setMemberAttribute(node,keys[i],_core.getPath(_nodes[memberGuid]),k,jsonNode.sets[keys[i]][j].attributes[k]);\r\n                    }\r\n                    for(k in jsonNode.sets[keys[i]][j].registry){\r\n                        _core.setMemberRegistry(node,keys[i],_core.getPath(_nodes[memberGuid]),k,jsonNode.sets[keys[i]][j].registry[k]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateInheritance(){\r\n        var i,guidList = Object.keys(_import.nodes),base;\r\n        for(i=0;i<guidList.length;i++){\r\n            base = _core.getBase(_nodes[guidList[i]]);\r\n            if((base && _core.getGuid(base) !== _import.nodes[guidList[i]].base) || (base === null && _import.nodes[guidList[i]].base !== null)){\r\n                updateNodeInheritance(guidList[i]);\r\n            }\r\n        }\r\n    }\r\n    function updateNodeInheritance(guid){\r\n        _core.setBase(_nodes[guid],_nodes[_import.nodes[guid].base]);\r\n    }\r\n\r\n    function updateMetaRules(guid,containmentTreeObject){\r\n\r\n        var keys,i;\r\n\r\n        updateMeta(guid);\r\n\r\n        keys = Object.keys(containmentTreeObject);\r\n        for(i=0;i<keys.length;i++){\r\n            updateMetaRules(keys[i],containmentTreeObject[keys[i]]);\r\n        }\r\n    }\r\n\r\n    function updateMeta(guid) {\r\n        _core.clearMetaRules(_nodes[guid]);\r\n\r\n        updateAttributeMeta(guid);\r\n        updateChildrenMeta(guid);\r\n        updatePointerMeta(guid);\r\n        updateAspectMeta(guid);\r\n        updateConstraintMeta(guid);\r\n    }\r\n\r\n    function updateAttributeMeta(guid){\r\n        var jsonMeta = _import.nodes[guid].meta.attributes || {},\r\n            node = _nodes[guid],\r\n            keys,i;\r\n\r\n        keys = Object.keys(jsonMeta);\r\n        for(i=0;i<keys.length;i++){\r\n            _core.setAttributeMeta(node,keys[i],jsonMeta[keys[i]]);\r\n        }\r\n    }\r\n    function updateChildrenMeta(guid){\r\n        var jsonMeta = _import.nodes[guid].meta.children || {items:[],minItems:[],maxItems:[]},\r\n            i;\r\n        ASSERT(jsonMeta.items.length === jsonMeta.minItems.length && jsonMeta.minItems.length === jsonMeta.maxItems.length);\r\n\r\n        _core.setChildrenMetaLimits(_nodes[guid],jsonMeta.min,jsonMeta.max);\r\n        for(i=0;i<jsonMeta.items.length;i++){\r\n            _core.setChildMeta(_nodes[guid],_nodes[jsonMeta.items[i]],jsonMeta.minItems[i],jsonMeta.maxItems[i]);\r\n        }\r\n    }\r\n    function updatePointerMeta(guid){\r\n        var jsonMeta = _import.nodes[guid].meta.pointers || {},\r\n            keys = Object.keys(jsonMeta),\r\n            i, j;\r\n\r\n        for(i=0;i<keys.length;i++){\r\n            ASSERT(jsonMeta[keys[i]].items.length === jsonMeta[keys[i]].minItems.length && jsonMeta[keys[i]].maxItems.length === jsonMeta[keys[i]].minItems.length);\r\n            for(j=0;j<jsonMeta[keys[i]].items.length;j++){\r\n                _core.setPointerMetaTarget(_nodes[guid],keys[i],_nodes[jsonMeta[keys[i]].items[j]],jsonMeta[keys[i]].minItems[j],jsonMeta[keys[i]].maxItems[j]);\r\n            }\r\n            _core.setPointerMetaLimits(_nodes[guid],keys[i],jsonMeta[keys[i]].min,jsonMeta[keys[i]].max);\r\n        }\r\n    }\r\n    function updateAspectMeta(guid){\r\n        var jsonMeta = _import.nodes[guid].meta.aspects || {},\r\n            keys = Object.keys(jsonMeta),\r\n            i,j;\r\n\r\n        for(i=0;i<keys.length;i++){\r\n            for(j=0;j<jsonMeta[keys[i]].length;j++){\r\n                _core.setAspectMetaTarget(_nodes[guid],keys[i],_nodes[jsonMeta[keys[i]][j]]);\r\n            }\r\n        }\r\n    }\r\n    function updateConstraintMeta(guid){\r\n        var jsonMeta = _import.nodes[guid].meta.constraints || {},\r\n            keys = Object.keys(jsonMeta),\r\n            i;\r\n\r\n        for(i=0;i<keys.length;i++){\r\n            _core.setConstraint(_nodes[guid],keys[i],jsonMeta[keys[i]]);\r\n        }\r\n    }\r\n\r\n    return {\r\n        export : exportLibrary,\r\n        import : importLibrary\r\n    };\r\n});\r\n\n",
    "/*globals define, _, requirejs, WebGMEGlobal*/\r\n\r\ndefine('client',[\r\n    'util/assert',\r\n    'eventDispatcher',\r\n    'util/guid',\r\n    'core/core',\r\n    'storage/clientstorage',\r\n    'logManager',\r\n    'util/url',\r\n    'coreclient/meta',\r\n    'coreclient/tojson',\r\n    'coreclient/dump',\r\n    'coreclient/dumpmore',\r\n    'coreclient/import',\r\n    'coreclient/copyimport',\r\n    'coreclient/serialization'\r\n  ],\r\n  function (\r\n    ASSERT,\r\n    EventDispatcher,\r\n    GUID,\r\n    Core,\r\n    Storage,\r\n    LogManager,\r\n    URL,\r\n    BaseMeta,\r\n    ToJson,\r\n    Dump,\r\n    DumpMore,\r\n    MergeImport,\r\n    Import,\r\n    Serialization) {\r\n\r\n    \"use strict\";\r\n\r\n    var ROOT_PATH = '';\r\n\r\n    function COPY(object) {\r\n      if (object) {\r\n        return JSON.parse(JSON.stringify(object));\r\n      }\r\n      return null;\r\n    }\r\n\r\n\r\n    function getNewCore(project) {\r\n      //return new NullPointerCore(new DescriptorCore(new SetCore(new GuidCore(new Core(project)))));\r\n      return Core(project, {autopersist: true, usertype: 'nodejs'});\r\n    }\r\n\r\n    function UndoRedo(_client) {\r\n      var\r\n        currentModification = null,\r\n        canDoUndo = false,\r\n        canDoRedo = false,\r\n        currentTarget = null,\r\n        addModification = function (commitHash, info) {\r\n          var newElement = {\r\n            previous: currentModification,\r\n            commit: commitHash,\r\n            info: info,\r\n            next: null\r\n          };\r\n          if(currentModification){\r\n            currentModification.next = newElement;\r\n          }\r\n          currentModification = newElement;\r\n        },\r\n        undo = function (branch, callback) {\r\n          var from, to, project;\r\n          if (canDoUndo && currentModification && currentModification.previous) {\r\n            project = _client.getProjectObject();\r\n            from = currentModification.commit;\r\n            to = currentModification.previous.commit;\r\n            currentModification = currentModification.previous;\r\n            currentTarget = to;\r\n            project.setBranchHash(branch, from, to, callback);\r\n          } else {\r\n            callback(new Error('unable to execute undo'));\r\n          }\r\n        },\r\n        redo = function (branch, callback) {\r\n          var from, to, project;\r\n          if (canDoRedo && currentModification && currentModification.next) {\r\n            project = _client.getProjectObject();\r\n            from = currentModification.commit;\r\n            to = currentModification.next.commit;\r\n            currentModification = currentModification.next;\r\n            currentTarget = to;\r\n            project.setBranchHash(branch, from, to, callback);\r\n          } else {\r\n            callback(new Error('unable to execute redo'));\r\n          }\r\n        },\r\n        clean = function() {\r\n          currentModification = null;\r\n          canDoUndo = false;\r\n          canDoRedo = false;\r\n        },\r\n        checkStatus = function(){\r\n          return {\r\n            undo: currentModification ? currentModification.previous !== null && currentModification.previous !== undefined : false,\r\n            redo: currentModification ? currentModification.next !== null && currentModification.next !== undefined : false\r\n          };\r\n        },\r\n        isCurrentTarget = function(commitHash){\r\n          if(currentTarget === commitHash){\r\n            currentTarget = null;\r\n            return true;\r\n          }\r\n          return false;\r\n        };\r\n\r\n      _client.addEventListener(_client.events.UNDO_AVAILABLE,function(client,parameters){\r\n        canDoUndo = parameters === true;\r\n      });\r\n      _client.addEventListener(_client.events.REDO_AVAILABLE,function(client,parameters){\r\n        canDoRedo = parameters === true;\r\n      });\r\n      return {\r\n        undo: undo,\r\n        redo: redo,\r\n        addModification: addModification,\r\n        clean: clean,\r\n        checkStatus: checkStatus,\r\n        isCurrentTarget: isCurrentTarget\r\n      };\r\n\r\n    }\r\n\r\n    function Client(_configuration) {\r\n      var _self = this,\r\n        logger = LogManager.create(\"client\"),\r\n        _database = null,\r\n        _projectName = null,\r\n        _project = null,\r\n        _core = null,\r\n        _branch = null,\r\n        _branchState = null,\r\n        _nodes = {},\r\n        _metaNodes = {},\r\n        _inTransaction = false,\r\n        _users = {},\r\n        _patterns = {},\r\n        _networkStatus = '',\r\n        _msg = \"\",\r\n        _recentCommits = [],\r\n        _viewer = false,\r\n        _readOnlyProject = false,\r\n        _loadNodes = {},\r\n        _loadError = 0,\r\n        _commitCache = null,\r\n        _offline = false,\r\n        _networkWatcher = null,\r\n        _TOKEN = null,\r\n        META = new BaseMeta(),\r\n        _rootHash = null,\r\n        _root = null,\r\n        _previousRootHash = null,\r\n        _changeTree = null,\r\n        _inheritanceHash = {},\r\n        _gHash = 0,\r\n        _addOns = {},\r\n        _constraintCallback = null,\r\n        _redoer = null,\r\n        _selfCommits = {},\r\n        AllPlugins, AllDecorators;\r\n\r\n\r\n      if (!_configuration.host) {\r\n        if (window) {\r\n          _configuration.host = window.location.protocol + \"//\" + window.location.host;\r\n        } else {\r\n          _configuration.host = \"\";\r\n        }\r\n      }\r\n      if(typeof WebGMEGlobal !== 'undefined') {\r\n        require([_configuration.host + '/listAllDecorators', _configuration.host + '/listAllPlugins'], function (d, p) {\r\n          AllDecorators = WebGMEGlobal.allDecorators;\r\n          AllPlugins = WebGMEGlobal.allPlugins;\r\n        });\r\n      } else {\r\n        console.warn('WebGMEGlobal not defined - cannot get plugins.');\r\n      }\r\n\r\n      function print_nodes(pretext) {\r\n        if (pretext) {\r\n          console.log(pretext);\r\n        }\r\n        var nodes = \"loaded: \";\r\n        for (var k in _loadNodes) {\r\n          nodes += \"(\" + k + \",\" + _loadNodes[k].hash + \")\";\r\n        }\r\n        console.log(nodes);\r\n        nodes = \"stored: \";\r\n        for (var k in _nodes) {\r\n          nodes += \"(\" + k + \",\" + _nodes[k].hash + \")\";\r\n        }\r\n        console.log(nodes);\r\n        return;\r\n      }\r\n\r\n      //default configuration\r\n      _configuration = _configuration || {};\r\n      _configuration.autoreconnect = _configuration.autoreconnect === null || _configuration.autoreconnect === undefined ? true : _configuration.autoreconnect;\r\n      _configuration.reconndelay = _configuration.reconndelay || 1000;\r\n      _configuration.reconnamount = _configuration.reconnamount || 1000;\r\n      _configuration.autostart = _configuration.autostart === null || _configuration.autostart === undefined ? false : _configuration.autostart;\r\n\r\n\r\n      //TODO remove the usage of jquery\r\n      //$.extend(_self, new EventDispatcher());\r\n      var eDisp = new EventDispatcher();\r\n      for (var i in eDisp) {\r\n        _self[i] = eDisp[i];\r\n      }\r\n      _self.events = {\r\n        \"NETWORKSTATUS_CHANGED\": \"NETWORKSTATUS_CHANGED\",\r\n        \"BRANCHSTATUS_CHANGED\": \"BRANCHSTATUS_CHANGED\",\r\n        \"BRANCH_CHANGED\": \"BRANCH_CHANGED\",\r\n        \"PROJECT_CLOSED\": \"PROJECT_CLOSED\",\r\n        \"PROJECT_OPENED\": \"PROJECT_OPENED\",\r\n\r\n        \"SERVER_PROJECT_CREATED\": \"SERVER_PROJECT_CREATED\",\r\n        \"SERVER_PROJECT_DELETED\": \"SERVER_PROJECT_DELETED\",\r\n        \"SERVER_BRANCH_CREATED\": \"SERVER_BRANCH_CREATED\",\r\n        \"SERVER_BRANCH_UPDATED\": \"SERVER_BRANCH_UPDATED\",\r\n        \"SERVER_BRANCH_DELETED\": \"SERVER_BRANCH_DELETED\",\r\n\r\n        \"UNDO_AVAILABLE\": \"UNDO_AVAILABLE\",\r\n        \"REDO_AVAILABLE\": \"REDO_AVAILABLE\"\r\n      };\r\n      _self.networkStates = {\r\n        'CONNECTED': \"connected\",\r\n        'DISCONNECTED': \"socket.io is disconnected\"\r\n      };\r\n      _self.branchStates = {\r\n        'SYNC': 'inSync',\r\n        'FORKED': 'forked',\r\n        'OFFLINE': 'offline'\r\n      };\r\n\r\n      function getUserId() {\r\n        var cookies = URL.parseCookie(document.cookie);\r\n        if (cookies.webgme) {\r\n          return cookies.webgme;\r\n        } else {\r\n          return 'n/a';\r\n        }\r\n      }\r\n\r\n      function newDatabase() {\r\n        var storageOptions ={log: LogManager.create('client-storage'), host: _configuration.host};\r\n        if(typeof WebGMEGlobal !== 'undefined' && WebGMEGlobal.TESTING === true){\r\n          storageOptions.type = 'node';\r\n          storageOptions.host = 'http://localhost';\r\n          storageOptions.port = _configuration.port;\r\n          storageOptions.user = \"TEST\";\r\n        } else {\r\n          storageOptions.user = getUserId();\r\n        }\r\n        return Storage(storageOptions);\r\n      }\r\n\r\n      function changeBranchState(newstate) {\r\n        if (_branchState !== newstate) {\r\n          _branchState = newstate;\r\n          _self.dispatchEvent(_self.events.BRANCHSTATUS_CHANGED, _branchState);\r\n        }\r\n      }\r\n\r\n      function connect() {\r\n        //this is when the user force to go online on network level\r\n        //TODO implement :) - but how, there is no such function on the storage's API\r\n        if (_database) {\r\n          _database.openDatabase(function (err) {\r\n          });\r\n        }\r\n      }\r\n\r\n      //branch handling functions\r\n      function goOffline() {\r\n        //TODO stop watching the branch changes\r\n        _offline = true;\r\n        changeBranchState(_self.branchStates.OFFLINE);\r\n      }\r\n\r\n      function goOnline() {\r\n        //TODO we should try to update the branch with our latest commit\r\n        //and 'restart' listening to branch changes\r\n        if (_offline) {\r\n          stopRunningAddOns();\r\n          branchWatcher(_branch);\r\n        }\r\n      }\r\n\r\n      function addCommit(commitHash) {\r\n        _commitCache.newCommit(commitHash);\r\n        _recentCommits.unshift(commitHash);\r\n        if (_recentCommits.length > 100) {\r\n          _recentCommits.pop();\r\n        }\r\n      }\r\n\r\n      function serverEventer() {\r\n        var lastGuid = '',\r\n          nextServerEvent = function (err, guid, parameters) {\r\n            lastGuid = guid || lastGuid;\r\n            if (!err && parameters) {\r\n              switch (parameters.type) {\r\n                case \"PROJECT_CREATED\":\r\n                  _self.dispatchEvent(_self.events.SERVER_PROJECT_CREATED, parameters.project);\r\n                  break;\r\n                case \"PROJECT_DELETED\":\r\n                  _self.dispatchEvent(_self.events.SERVER_PROJECT_DELETED, parameters.project);\r\n                  break;\r\n                case \"BRANCH_CREATED\":\r\n                  _self.dispatchEvent(_self.events.SERVER_BRANCH_CREATED, {project: parameters.project, branch: parameters.branch, commit: parameters.commit});\r\n                  break;\r\n                case \"BRANCH_DELETED\":\r\n                  _self.dispatchEvent(_self.events.SERVER_BRANCH_DELETED, {project: parameters.project, branch: parameters.branch});\r\n                  break;\r\n                case \"BRANCH_UPDATED\":\r\n                  _self.dispatchEvent(_self.events.SERVER_BRANCH_UPDATED, {project: parameters.project, branch: parameters.branch, commit: parameters.commit});\r\n                  break;\r\n              }\r\n              return _database.getNextServerEvent(lastGuid, nextServerEvent);\r\n            } else {\r\n              setTimeout(function () {\r\n                return _database.getNextServerEvent(lastGuid, nextServerEvent);\r\n              }, 1000);\r\n            }\r\n          };\r\n        _database.getNextServerEvent(lastGuid, nextServerEvent);\r\n      }\r\n\r\n      //addOn functions\r\n      function startAddOnAsync(name, projectName, branchName, callback) {\r\n        if (_addOns[name] === undefined) {\r\n          _addOns[name] = \"loading\";\r\n          _database.simpleRequest({command: 'connectedWorkerStart', workerName: name, project: projectName, branch: branchName}, function (err, id) {\r\n            if (err) {\r\n              delete _addOns[name];\r\n              return callback(err);\r\n            }\r\n\r\n            _addOns[name] = id;\r\n            callback(null);\r\n          });\r\n        }\r\n      }\r\n\r\n      function startAddOn(name) {\r\n        if (_addOns[name] === undefined) {\r\n          _addOns[name] = \"loading\";\r\n          _database.simpleRequest({command: 'connectedWorkerStart', workerName: name, project: _projectName, branch: _branch}, function (err, id) {\r\n            console.log('started addon', err);\r\n            if (err) {\r\n              delete _addOns[name];\r\n              return logger.error(err);\r\n            }\r\n\r\n            _addOns[name] = id;\r\n          });\r\n        }\r\n\r\n      }\r\n\r\n      function queryAddOn(name, query, callback) {\r\n        if (!_addOns[name] || _addOns[name] === \"loading\") {\r\n          return callback(new Error('no such addOn is ready for queries'));\r\n        }\r\n        _database.simpleQuery(_addOns[name], query, callback);\r\n      }\r\n\r\n      function stopAddOn(name, callback) {\r\n        if (_addOns[name] && _addOns[name] !== \"loading\") {\r\n          _database.simpleResult(_addOns[name], callback);\r\n          delete _addOns[name];\r\n        } else {\r\n          callback(_addOns[name] ? new Error(\"addon loading\") : null);\r\n        }\r\n      }\r\n\r\n      //generic project related addOn handling\r\n      function updateRunningAddOns(root) {\r\n        var neededAddOns = _core.getRegistry(root, \"usedAddOns\"),\r\n          i,\r\n          runningAddOns = getRunningAddOnNames();\r\n        neededAddOns = neededAddOns ? neededAddOns.split(\" \") : [];\r\n        for (i = 0; i < neededAddOns.length; i++) {\r\n          if (!_addOns[neededAddOns[i]]) {\r\n            startAddOn(neededAddOns[i]);\r\n          }\r\n        }\r\n        for (i = 0; i < runningAddOns.length; i++) {\r\n          if (neededAddOns.indexOf(runningAddOns[i]) === -1) {\r\n            stopAddOn(runningAddOns[i], function (err) {\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      function stopRunningAddOns() {\r\n        var i,\r\n          keys = Object.keys(_addOns),\r\n          callback = function (err) {\r\n            if (err) {\r\n              console.log(\"stopAddOn\", err);\r\n            }\r\n          };\r\n        for (i = 0; i < keys.length; i++) {\r\n          stopAddOn(keys[i], callback);\r\n        }\r\n      }\r\n\r\n      function getRunningAddOnNames() {\r\n        var i,\r\n          names = [],\r\n          keys = Object.keys(_addOns);\r\n        for (i = 0; i < keys.length; i++) {\r\n          if (_addOns[keys[i]] !== 'loading') {\r\n            names.push(keys[i]);\r\n          }\r\n        }\r\n        return names;\r\n      }\r\n\r\n      //core addOns\r\n      function startCoreAddOnsAsync(project, branch, callback) {\r\n        var needed = 2,\r\n          error = null,\r\n          icb = function (err) {\r\n            error = error || err;\r\n            if (--needed === 0) {\r\n              callback(error);\r\n            }\r\n          };\r\n\r\n        startHistoryAsync(project, branch, icb);\r\n        startConstraintAsync(project, branch, icb);\r\n      }\r\n\r\n      //history\r\n      function startHistoryAsync(project, branch, callback) {\r\n        if (_addOns['HistoryAddOn'] && _addOns['HistoryAddOn'] !== 'loading') {\r\n          stopAddOn('HistoryAddOn', function (err) {\r\n            if (err) {\r\n              callback(err);\r\n            } else {\r\n              startAddOnAsync('HistoryAddOn', project, branch, callback);\r\n            }\r\n          });\r\n        } else {\r\n          startAddOnAsync('HistoryAddOn', project, branch, callback);\r\n        }\r\n      }\r\n\r\n      function getDetailedHistoryAsync(callback) {\r\n        if (_addOns['HistoryAddOn'] && _addOns['HistoryAddOn'] !== 'loading') {\r\n          queryAddOn('HistoryAddOn', {}, callback);\r\n        } else {\r\n          callback(new Error('history information is not available'));\r\n        }\r\n      }\r\n\r\n      //constraint\r\n      function startConstraintAsync(project, branch, callback) {\r\n        if (_addOns['ConstraintAddOn'] && _addOns['ConstraintAddOn'] !== 'loading') {\r\n          stopAddOn('ConstraintAddOn', function (err) {\r\n            if (err) {\r\n              callback(err);\r\n            } else {\r\n              startAddOnAsync('ConstraintAddOn', project, branch, callback);\r\n            }\r\n          });\r\n        } else {\r\n          startAddOnAsync('ConstraintAddOn', project, branch, callback);\r\n        }\r\n      }\r\n\r\n      function validateProjectAsync(callback) {\r\n        callback = callback || _constraintCallback || function (err, result) {\r\n        };\r\n        if (_addOns['ConstraintAddOn'] && _addOns['ConstraintAddOn'] !== 'loading') {\r\n          queryAddOn(\"ConstraintAddOn\", {querytype: 'checkProject'}, callback);\r\n        } else {\r\n          callback(new Error('constraint checking is not available'));\r\n        }\r\n      }\r\n\r\n      function validateModelAsync(path, callback) {\r\n        callback = callback || _constraintCallback || function (err, result) {\r\n        };\r\n        if (_addOns['ConstraintAddOn'] && _addOns['ConstraintAddOn'] !== 'loading') {\r\n          queryAddOn(\"ConstraintAddOn\", {querytype: 'checkModel', path: path}, callback);\r\n        } else {\r\n          callback(new Error('constraint checking is not available'));\r\n        }\r\n      }\r\n\r\n      function validateNodeAsync(path, callback) {\r\n        callback = callback || _constraintCallback || function (err, result) {\r\n        };\r\n        if (_addOns['ConstraintAddOn'] && _addOns['ConstraintAddOn'] !== 'loading') {\r\n          queryAddOn(\"ConstraintAddOn\", {querytype: 'checkNode', path: path}, callback);\r\n        } else {\r\n          callback(new Error('constraint checking is not available'));\r\n        }\r\n      }\r\n\r\n      function setValidationCallback(cFunction) {\r\n        if (typeof cFunction === 'function' || cFunction === null) {\r\n          _constraintCallback = cFunction;\r\n        }\r\n      }\r\n\r\n      //core addOns end\r\n\r\n      function tokenWatcher() {\r\n        var token = null,\r\n          refreshToken = function () {\r\n            _database.getToken(function (err, t) {\r\n              if (!err) {\r\n                token = t || \"_\";\r\n              }\r\n            });\r\n          },\r\n          getToken = function () {\r\n            return token;\r\n          };\r\n\r\n        setInterval(refreshToken, 10000); //maybe it could be configurable\r\n        refreshToken();\r\n\r\n        //TODO check if this is okay to set it here\r\n        if(typeof WebGMEGlobal !== 'undefined') {\r\n           WebGMEGlobal.getToken = getToken;\r\n        }\r\n        return {\r\n          getToken: getToken\r\n        };\r\n      }\r\n\r\n      function branchWatcher(branch, callback) {\r\n        ASSERT(_project);\r\n        callback = callback || function () {\r\n        };\r\n        var myCallback = function(err){\r\n          myCallback = function(){};\r\n          callback(err);\r\n        };\r\n        var redoerNeedsClean = true;\r\n        var branchHashUpdated = function (err, newhash, forked) {\r\n          var doUpdate = false;\r\n          if (branch === _branch && !_offline) {\r\n            if (!err && typeof newhash === 'string') {\r\n              if (newhash === '') {\r\n                logger.warning('The current branch ' + branch + ' have been deleted!');\r\n                //we should open a viewer with our current commit...\r\n                var latestCommit = _recentCommits[0];\r\n                viewerCommit(latestCommit, function (err) {\r\n                  if (err) {\r\n                    logger.error('Current branch ' + branch + ' have been deleted, and unable to open the latest commit ' + latestCommit + '! [' + JSON.stringify(err) + ']');\r\n                  }\r\n                });\r\n              } else {\r\n                if(_redoer.isCurrentTarget(newhash)){\r\n                  addCommit(newhash);\r\n                  doUpdate = true;\r\n                } else if(!_selfCommits[newhash] || redoerNeedsClean){\r\n                  redoerNeedsClean = false;\r\n                  _redoer.clean();\r\n                  _redoer.addModification(newhash,\"branch initial\");\r\n                  _selfCommits={};\r\n                  _selfCommits[newhash] = true;\r\n                  doUpdate = true;\r\n                  addCommit(newhash);\r\n                }\r\n                var redoInfo = _redoer.checkStatus(),\r\n                  canUndo = false,\r\n                  canRedo = false;\r\n\r\n                if(_selfCommits[newhash]){\r\n                  if(redoInfo.undo) {\r\n                    canUndo = true;\r\n                  }\r\n                  if(redoInfo.redo) {\r\n                    canRedo = true;\r\n                  }\r\n                }\r\n                _self.dispatchEvent(_self.events.UNDO_AVAILABLE, canUndo);\r\n                _self.dispatchEvent(_self.events.REDO_AVAILABLE, canRedo);\r\n\r\n                if(doUpdate){\r\n                  _project.loadObject(newhash, function (err, commitObj) {\r\n                    if (!err && commitObj) {\r\n                      loading(commitObj.root,myCallback);\r\n                    } else {\r\n                      setTimeout(function () {\r\n                        _project.loadObject(newhash, function (err, commitObj) {\r\n                          if (!err && commitObj) {\r\n                            loading(commitObj.root,myCallback);\r\n                          } else {\r\n                            console.log(\"second load try failed on commit!!!\", err);\r\n                          }\r\n                        });\r\n                      }, 1000);\r\n                    }\r\n                  });\r\n                }\r\n\r\n                //branch status update\r\n                if (_offline) {\r\n                  changeBranchState(_self.branchStates.OFFLINE);\r\n                } else {\r\n                  if (forked) {\r\n                    changeBranchState(_self.branchStates.FORKED);\r\n                  }\r\n                }\r\n\r\n                return _project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\r\n\r\n                /*if(redoerNeedsClean || !_selfCommits[newhash]){\r\n                  redoerNeedsClean = false;\r\n                  _redoer.clean();\r\n                  _redoer.addModification(newhash,\"branch initial\");\r\n                  _selfCommits={};_selfCommits[newhash] = true;\r\n                }\r\n                var redoInfo = _redoer.checkStatus(),\r\n                  canUndo = false,\r\n                  canRedo = false;\r\n\r\n                if(_selfCommits[newhash]){\r\n                  if(redoInfo.undo) {\r\n                    canUndo = true;\r\n                  }\r\n                  if(redoInfo.redo) {\r\n                    canRedo = true;\r\n                  }\r\n                }\r\n                _self.dispatchEvent(_self.events.UNDO_AVAILABLE, canUndo);\r\n                _self.dispatchEvent(_self.events.REDO_AVAILABLE, canRedo);\r\n\r\n\r\n                if (/*_recentCommits.indexOf(newhash) === -1/_recentCommits.indexOf(newhash) !== 0) {\r\n\r\n                  addCommit(newhash);\r\n\r\n                  //TODO here we have to start with a syncronous root object load...\r\n                  _project.loadObject(newhash, function (err, commitObj) {\r\n                    if (!err && commitObj) {\r\n                      loading(commitObj.root);\r\n                    } else {\r\n                      setTimeout(function () {\r\n                        _project.loadObject(newhash, function (err, commitObj) {\r\n                          if (!err && commitObj) {\r\n                            loading(commitObj.root);\r\n                          } else {\r\n                            console.log(\"second load try failed on commit!!!\", err);\r\n                          }\r\n                        });\r\n                      }, 1000);\r\n                    }\r\n                  });\r\n                }\r\n\r\n                if (callback) {\r\n                  myCallback = callback;\r\n                  callback = null;\r\n                  myCallback();\r\n                }\r\n\r\n                //branch status update\r\n                if (_offline) {\r\n                  changeBranchState(_self.branchStates.OFFLINE);\r\n                } else {\r\n                  if (forked) {\r\n                    changeBranchState(_self.branchStates.FORKED);\r\n                  }\r\n                  /* else {\r\n                   changeBranchState(_self.branchStates.SYNC);\r\n                   }/\r\n                }\r\n\r\n                return _project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);*/\r\n              }\r\n            } else {\r\n              myCallback(null);\r\n              return _project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\r\n            }\r\n          } else {\r\n            myCallback(null);\r\n          }\r\n        };\r\n\r\n        if (_branch !== branch) {\r\n          _branch = branch;\r\n          _viewer = false;\r\n          _offline = false;\r\n          _recentCommits = [\"\"];\r\n          _self.dispatchEvent(_self.events.BRANCH_CHANGED, _branch);\r\n          changeBranchState(_self.branchStates.SYNC);\r\n          _project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\r\n        } else {\r\n          if (_offline) {\r\n            _viewer = false;\r\n            _offline = false;\r\n            changeBranchState(_self.branchStates.SYNC);\r\n            _project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\r\n          } else {\r\n            callback(null);\r\n          }\r\n        }\r\n      }\r\n\r\n      function networkWatcher() {\r\n        _networkStatus = \"\";\r\n        var running = true;\r\n        var autoReconnect = _configuration.autoreconnect ? true : false;\r\n        var reConnDelay = _configuration.reconndelay || 1000;\r\n        var reConnAmount = _configuration.reconnamount || 1000;\r\n        var reconnecting = function () {\r\n          var counter = 0;\r\n          var timerId = setInterval(function () {\r\n            if (counter < reConnAmount && _networkStatus === _self.networkStates.DISCONNECTED && running) {\r\n              _database.openDatabase(function (err) {\r\n              });\r\n              counter++;\r\n            } else {\r\n              clearInterval(timerId);\r\n            }\r\n          }, reConnDelay);\r\n        };\r\n        var dbStatusUpdated = function (err, newstatus) {\r\n          if (running) {\r\n            if (!err && newstatus && _networkStatus !== newstatus) {\r\n              _networkStatus = newstatus;\r\n              if (_networkStatus === _self.networkStates.DISCONNECTED && autoReconnect) {\r\n                reconnecting();\r\n              }\r\n              _self.dispatchEvent(_self.events.NETWORKSTATUS_CHANGED, _networkStatus);\r\n            }\r\n            return _database.getDatabaseStatus(_networkStatus, dbStatusUpdated);\r\n          }\r\n          return;\r\n        };\r\n        var stop = function () {\r\n          running = false;\r\n        };\r\n        _database.getDatabaseStatus('', dbStatusUpdated);\r\n\r\n        return {\r\n          stop: stop\r\n        };\r\n      }\r\n\r\n      function commitCache() {\r\n        var _cache = {},\r\n          _timeOrder = [];\r\n\r\n        function clearCache() {\r\n          _cache = {};\r\n          _timeOrder = [];\r\n        }\r\n\r\n        function addCommit(commitObject) {\r\n          if (_cache[commitObject._id]) {\r\n            //already in the cache we do not have to do anything\r\n            return;\r\n          } else {\r\n            _cache[commitObject._id] = commitObject;\r\n            var index = 0;\r\n            while (index < _timeOrder.length && _cache[_timeOrder[index]].time > commitObject.time) {\r\n              index++;\r\n            }\r\n            _timeOrder.splice(index, 0, commitObject._id);\r\n          }\r\n          return;\r\n        }\r\n\r\n        function getNCommitsFrom(commitHash, number, callback) {\r\n          var fillCache = function (time, number, cb) {\r\n            _project.getCommits(time, number, function (err, commits) {\r\n              if (!err && commits) {\r\n                for (var i = 0; i < commits.length; i++) {\r\n                  addCommit(commits[i]);\r\n                }\r\n                cb(null);\r\n              } else {\r\n                //we cannot get new commits from the server\r\n                //we should use our very own ones\r\n                cb(null);\r\n              }\r\n            });\r\n          };\r\n          var returnNCommitsFromHash = function (hash, num, cb) {\r\n            //now we should have all the commits in place\r\n            var index = _timeOrder.indexOf(hash),\r\n              commits = [];\r\n            if (index > -1 || hash === null) {\r\n              if (hash === null) {\r\n                index = 0;\r\n              } else {\r\n                index++;\r\n\r\n              }\r\n              while (commits.length < num && index < _timeOrder.length) {\r\n                commits.push(_cache[_timeOrder[index]]);\r\n                index++;\r\n              }\r\n              cb(null, commits);\r\n            } else {\r\n              cb('cannot found starting commit');\r\n            }\r\n          };\r\n          var cacheFilled = function (err) {\r\n            if (err) {\r\n              callback(err);\r\n            } else {\r\n              returnNCommitsFromHash(commitHash, number, callback);\r\n            }\r\n          };\r\n\r\n\r\n          if (commitHash) {\r\n            if (_cache[commitHash]) {\r\n              //we can be lucky :)\r\n              var index = _timeOrder.indexOf(commitHash);\r\n              if (_timeOrder.length > index + number) {\r\n                //we are lucky\r\n                cacheFilled(null);\r\n              } else {\r\n                //not that lucky\r\n                fillCache(_cache[_timeOrder[_timeOrder.length - 1]].time, number - (_timeOrder.length - (index + 1)), cacheFilled);\r\n              }\r\n            } else {\r\n              //we are not lucky enough so we have to download the commit\r\n              _project.loadObject(commitHash, function (err, commitObject) {\r\n                if (!err && commitObject) {\r\n                  addCommit(commitObject);\r\n                  fillCache(commitObject.time, number, cacheFilled);\r\n                } else {\r\n                  callback(err);\r\n                }\r\n              });\r\n            }\r\n          } else {\r\n            //initial call\r\n            fillCache((new Date()).getTime(), number, cacheFilled);\r\n          }\r\n        }\r\n\r\n        function newCommit(commitHash) {\r\n          if (_cache[commitHash]) {\r\n            return;\r\n          } else {\r\n            _project.loadObject(commitHash, function (err, commitObj) {\r\n              if (!err && commitObj) {\r\n                addCommit(commitObj);\r\n              }\r\n              return;\r\n            });\r\n          }\r\n        }\r\n\r\n        return {\r\n          getNCommitsFrom: getNCommitsFrom,\r\n          clearCache: clearCache,\r\n          newCommit: newCommit\r\n        };\r\n      }\r\n\r\n      function viewLatestCommit(callback) {\r\n        _commitCache.getNCommitsFrom(null, 1, function (err, commits) {\r\n          if (!err && commits && commits.length > 0) {\r\n            viewerCommit(commits[0][_project.ID_NAME], callback)\r\n          } else {\r\n            logger.error('Cannot get latest commit! [' + JSON.stringify(err) + ']');\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      function openProject(name, callback) {\r\n        //this function cannot create new project\r\n        ASSERT(_database);\r\n        var waiting = 1,\r\n          innerCallback = function (err) {\r\n            error = error || err;\r\n            if (--waiting === 0) {\r\n              if (error) {\r\n                logger.error('The branch ' + firstName + ' of project ' + name + ' cannot be selected! [' + JSON.stringify(error) + ']');\r\n              }\r\n              callback(error);\r\n            }\r\n          },\r\n          firstName = null,\r\n          error = null;\r\n        _database.getProjectNames(function (err, names) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n          if (names.indexOf(name) !== -1) {\r\n            _database.openProject(name, function (err, p) {\r\n              if (!err && p) {\r\n                _database.getAuthorizationInfo(name, function (err, authInfo) {\r\n                  _readOnlyProject = authInfo ? (authInfo.write === true ? false : true) : true;\r\n                  _project = p;\r\n                  _projectName = name;\r\n                  _inTransaction = false;\r\n                  _nodes = {};\r\n                  _metaNodes = {};\r\n                  _core = getNewCore(_project);\r\n                  META.initialize(_core, _metaNodes, saveRoot);\r\n                  if (_commitCache) {\r\n                    _commitCache.clearCache();\r\n                  } else {\r\n                    _commitCache = commitCache();\r\n                  }\r\n                  _self.dispatchEvent(_self.events.PROJECT_OPENED, _projectName);\r\n\r\n                  //check for master or any other branch\r\n                  _project.getBranchNames(function (err, names) {\r\n                    if (!err && names) {\r\n\r\n                      if (names['master']) {\r\n                        firstName = 'master';\r\n                      } else {\r\n                        firstName = Object.keys(names)[0] || null;\r\n                      }\r\n\r\n                      if (firstName) {\r\n                        stopRunningAddOns();\r\n                        branchWatcher(firstName, innerCallback);\r\n                        //startCoreAddOnsAsync(_projectName,firstName,innerCallback);\r\n                      } else {\r\n                        //we should try the latest commit\r\n                        viewLatestCommit(callback);\r\n                      }\r\n                    } else {\r\n                      //we should try the latest commit\r\n                      viewLatestCommit(callback);\r\n                    }\r\n                  });\r\n                });\r\n              } else {\r\n                logger.error('The project ' + name + ' cannot be opened! [' + JSON.stringify(err) + ']');\r\n                callback(err);\r\n              }\r\n            });\r\n          } else {\r\n            callback(new Error('there is no such project'));\r\n          }\r\n\r\n        });\r\n      }\r\n\r\n      //internal functions\r\n      function cleanUsersTerritories() {\r\n        for (var i in _users) {\r\n          var events = [];\r\n          for (var j in _users[i].PATHS) {\r\n            events.push({etype: 'unload', eid: j});\r\n          }\r\n          // TODO events.push({etype:'complete',eid:null});\r\n\r\n\r\n          _users[i].FN(events);\r\n          _users[i].PATTERNS = {};\r\n          _users[i].PATHS = {};\r\n          _users[i].SENDEVENTS = true;\r\n        }\r\n      }\r\n\r\n      function reLaunchUsers() {\r\n        for (var i in _users) {\r\n          if (_users[i].UI.reLaunch) {\r\n            _users[i].UI.reLaunch();\r\n          }\r\n        }\r\n      }\r\n\r\n      function closeOpenedProject(callback) {\r\n        callback = callback || function () {\r\n        };\r\n        var returning = function (e) {\r\n          var oldProjName = _projectName;\r\n          _projectName = null;\r\n          _inTransaction = false;\r\n          _core = null;\r\n          _nodes = {};\r\n          _metaNodes = {};\r\n          //_commitObject = null;\r\n          _patterns = {};\r\n          _msg = \"\";\r\n          _recentCommits = [];\r\n          _previousRootHash = null;\r\n          _rootHash = null;\r\n          _viewer = false;\r\n          _readOnlyProject = false;\r\n          _loadNodes = {};\r\n          _loadError = 0;\r\n          _offline = false;\r\n          cleanUsersTerritories();\r\n          if (oldProjName) {\r\n            //otherwise there were no open project at all\r\n            _self.dispatchEvent(_self.events.PROJECT_CLOSED, oldProjName);\r\n          }\r\n\r\n          callback(e);\r\n        };\r\n        if (_branch) {\r\n          //otherwise the branch will not 'change'\r\n          _self.dispatchEvent(_self.events.BRANCH_CHANGED, null);\r\n        }\r\n        _branch = null;\r\n        if (_project) {\r\n          var project = _project;\r\n          _project = null;\r\n          project.closeProject(function (err) {\r\n            //TODO what if for some reason we are in transaction???\r\n            returning(err);\r\n          });\r\n        } else {\r\n          returning(null);\r\n        }\r\n      }\r\n\r\n      function createEmptyProject(project, callback) {\r\n        var core = getNewCore(project),\r\n          root = core.createNode(),\r\n          rootHash = '',\r\n          commitHash = '';\r\n        core.persist(root,function(err){\r\n          rootHash = core.getHash(root);\r\n          commitHash = project.makeCommit([],rootHash,'project creation commit',function(err){\r\n            project.setBranchHash('master',\"\",commitHash, function (err) {\r\n                    callback(err, commitHash);\r\n                });\r\n          });\r\n        });\r\n\r\n      }\r\n\r\n      //loading functions\r\n      function getStringHash(node) {\r\n        //TODO there is a memory issue with the huge strings so we have to replace it with something\r\n        return _gHash++;\r\n        /*\r\n         var datas = _core.getDataForSingleHash(node),\r\n         i,hash=\"\";\r\n         for(i=0;i<datas.length;i++){\r\n         hash+=datas[i];\r\n         }\r\n         return hash;\r\n         */\r\n\r\n      }\r\n\r\n      function _getModifiedNodes(newerNodes){\r\n        var modifiedNodes = [];\r\n        for(var i in _nodes){\r\n          if(newerNodes[i]){\r\n            if(newerNodes[i].hash !== _nodes[i].hash && _nodes[i].hash !== \"\"){\r\n              modifiedNodes.push(i);\r\n            }\r\n          }\r\n        }\r\n        return modifiedNodes;\r\n      }\r\n      function isInChangeTree(path){\r\n        var pathArray = path.split(\"/\"),\r\n          diffObj = _changeTree,\r\n          index = 0,\r\n          found = false;\r\n\r\n        pathArray.shift();\r\n        if(pathArray.length === 0){\r\n          found = true;\r\n        }\r\n\r\n        if(!diffObj){\r\n          return false;\r\n        }\r\n\r\n        while(index<pathArray.length && !found){\r\n          if(diffObj[pathArray[index]]){\r\n            diffObj = diffObj[pathArray[index]];\r\n            if(++index === pathArray.length){\r\n              found = true;\r\n            }\r\n          } else {\r\n            index = pathArray.length;\r\n          }\r\n        }\r\n\r\n        if(found && diffObj){\r\n          if(diffObj.removed !== undefined){\r\n            return false;\r\n          }\r\n          if(diffObj.reg || diffObj.attr || diffObj.pointer || diffObj.set || diffObj.meta || diffObj.childrenListChanged){\r\n            return true;\r\n          }\r\n        }\r\n\r\n        return false;\r\n      }\r\n      function getModifiedNodes(newerNodes){\r\n        var modifiedNodes = [],\r\n          keys = Object.keys(newerNodes),\r\n          i,found,\r\n          inheritanceArray;\r\n        for(i=0;i<keys.length;i++){\r\n          found = false;\r\n          inheritanceArray = getInheritanceChain(newerNodes[keys[i]].node);\r\n          inheritanceArray.unshift(keys[i]);\r\n          while(inheritanceArray.length > 0 && !found){\r\n            if(isInChangeTree(inheritanceArray.shift())){\r\n              found = true;\r\n              modifiedNodes.push(keys[i]);\r\n            }\r\n          }\r\n        }\r\n\r\n        return modifiedNodes;\r\n      }\r\n\r\n\r\n      //this is just a first brute implementation it needs serious optimization!!!\r\n      function fitsInPatternTypes(path, pattern) {\r\n        if (pattern.items && pattern.items.length > 0) {\r\n          for (var i = 0; i < pattern.items.length; i++) {\r\n            if (META.isTypeOf(path, pattern.items[i])) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        } else {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      function patternToPaths(patternId, pattern, pathsSoFar) {\r\n        if (_nodes[patternId]) {\r\n          pathsSoFar[patternId] = true;\r\n          if (pattern.children && pattern.children > 0) {\r\n            var children = _core.getChildrenPaths(_nodes[patternId].node);\r\n            var subPattern = COPY(pattern);\r\n            subPattern.children--;\r\n            for (var i = 0; i < children.length; i++) {\r\n              if (fitsInPatternTypes(children[i], pattern)) {\r\n                patternToPaths(children[i], subPattern, pathsSoFar);\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          _loadError++;\r\n        }\r\n\r\n      }\r\n\r\n      function userEvents(userId, modifiedNodes) {\r\n        var newPaths = {};\r\n        var startErrorLevel = _loadError;\r\n        for (var i in _users[userId].PATTERNS) {\r\n          if (_nodes[i]) { //TODO we only check pattern if its root is there...\r\n            patternToPaths(i, _users[userId].PATTERNS[i], newPaths);\r\n          }\r\n        }\r\n\r\n        if (startErrorLevel !== _loadError) {\r\n          return; //we send events only when everything is there correctly\r\n        }\r\n        var events = [];\r\n\r\n        //deleted items\r\n        for (i in _users[userId].PATHS) {\r\n          if (!newPaths[i]) {\r\n            events.push({etype: 'unload', eid: i});\r\n          }\r\n        }\r\n\r\n        //added items\r\n        for (i in newPaths) {\r\n          if (!_users[userId].PATHS[i]) {\r\n            events.push({etype: 'load', eid: i});\r\n          }\r\n        }\r\n\r\n        //updated items\r\n        for (i = 0; i < modifiedNodes.length; i++) {\r\n          if (newPaths[modifiedNodes[i]]) {\r\n            events.push({etype: 'update', eid: modifiedNodes[i]});\r\n          }\r\n        }\r\n\r\n        _users[userId].PATHS = newPaths;\r\n\r\n\r\n        //this is how the events should go\r\n        if(events.length>0){\r\n          if(_loadError > startErrorLevel){\r\n            events.unshift({etype:'incomplete',eid:null});\r\n          } else {\r\n            events.unshift({etype:'complete',eid:null});\r\n          }\r\n        } else {\r\n          events.unshift({etype:'complete',eid:null});\r\n        }\r\n        _users[userId].FN(events);\r\n\r\n      }\r\n\r\n      function getInheritanceChain(node){\r\n        var ancestors = [];\r\n        node = _core.getBase(node);\r\n        while(node){\r\n          ancestors.push(_core.getPath(node));\r\n          node = _core.getBase(node);\r\n        }\r\n        return ancestors;\r\n      }\r\n\r\n      function storeNode(node, basic) {\r\n        //basic = basic || true;\r\n        if (node) {\r\n          var path = _core.getPath(node);\r\n          _metaNodes[path] = node;\r\n          if (_nodes[path]) {\r\n            //TODO we try to avoid this\r\n          } else {\r\n            _nodes[path] = {node: node, hash: \"\"/*,incomplete:true,basic:basic*/};\r\n            _inheritanceHash[path] = getInheritanceChain(node);\r\n\r\n          }\r\n          return path;\r\n        }\r\n        return null;\r\n      }\r\n\r\n      function _loadChildrenPattern(core, nodesSoFar, node, level, callback) {\r\n        var path = core.getPath(node);\r\n        _metaNodes[path] = node;\r\n        if (!nodesSoFar[path]) {\r\n          nodesSoFar[path] = {node: node, incomplete: true, basic: true, hash: getStringHash(node)};\r\n        }\r\n        if (level > 0) {\r\n          if (core.getChildrenRelids(nodesSoFar[path].node).length > 0) {\r\n            core.loadChildren(nodesSoFar[path].node, function (err, children) {\r\n              if (!err && children) {\r\n                var missing = children.length;\r\n                var error = null;\r\n                for (var i = 0; i < children.length; i++) {\r\n                  loadChildrenPattern(core, nodesSoFar, children[i], level - 1, function (err) {\r\n                    error = error || err;\r\n                    if (--missing === 0) {\r\n                      callback(error);\r\n                    }\r\n                  });\r\n                }\r\n              } else {\r\n                callback(err);\r\n              }\r\n            });\r\n          } else {\r\n            callback(null);\r\n          }\r\n        } else {\r\n          callback(null);\r\n        }\r\n      }\r\n\r\n      //partially optimized\r\n      function loadChildrenPattern(core, nodesSoFar, node, level, callback) {\r\n        var path = core.getPath(node),\r\n          childrenPaths = core.getChildrenPaths(node),\r\n          childrenRelids = core.getChildrenRelids(node),\r\n          missing = childrenPaths.length,\r\n          error = null,\r\n          i;\r\n        _metaNodes[path] = node;\r\n        if (!nodesSoFar[path]) {\r\n          nodesSoFar[path] = {node: node, incomplete: true, basic: true, hash: getStringHash(node)};\r\n        }\r\n        if (level > 0) {\r\n          if (missing > 0) {\r\n            for (i = 0; i < childrenPaths.length; i++) {\r\n              if (nodesSoFar[childrenPaths[i]]) {\r\n                loadChildrenPattern(core, nodesSoFar, nodesSoFar[childrenPaths[i]].node, level - 1, function (err) {\r\n                  error = error || err;\r\n                  if (--missing === 0) {\r\n                    callback(error);\r\n                  }\r\n                });\r\n              } else {\r\n                core.loadChild(node, childrenRelids[i], function (err, child) {\r\n                  if (err || child === null) {\r\n                    error = error || err;\r\n                    if (--missing === 0) {\r\n                      callback(error);\r\n                    }\r\n                  } else {\r\n                    loadChildrenPattern(core, nodesSoFar, child, level - 1, function (err) {\r\n                      error = error || err;\r\n                      if (--missing === 0) {\r\n                        callback(error);\r\n                      }\r\n                    });\r\n                  }\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            callback(error);\r\n          }\r\n        } else {\r\n          callback(error);\r\n        }\r\n      }\r\n\r\n      function loadPattern(core, id, pattern, nodesSoFar, callback) {\r\n        var base = null;\r\n        var baseLoaded = function () {\r\n          if (pattern.children && pattern.children > 0) {\r\n            var level = pattern.children;\r\n            loadChildrenPattern(core, nodesSoFar, base, level, callback);\r\n          } else {\r\n            callback(null);\r\n          }\r\n        };\r\n\r\n        if (nodesSoFar[id]) {\r\n          base = nodesSoFar[id].node;\r\n          baseLoaded();\r\n        } else {\r\n          base = null;\r\n          if (_loadNodes[ROOT_PATH]) {\r\n            base = _loadNodes[ROOT_PATH].node;\r\n          } else if (_nodes[ROOT_PATH]) {\r\n            base = _nodes[ROOT_PATH].node;\r\n          }\r\n          core.loadByPath(base, id, function (err, node) {\r\n            if (!err && node && !core.isEmpty(node)) {\r\n              var path = core.getPath(node);\r\n              _metaNodes[path] = node;\r\n              if (!nodesSoFar[path]) {\r\n                nodesSoFar[path] = {node: node, incomplete: false, basic: true, hash: getStringHash(node)};\r\n              }\r\n              base = node;\r\n              baseLoaded();\r\n            } else {\r\n              callback(err);\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      function orderStringArrayByElementLength(strArray) {\r\n        var ordered = [],\r\n          i, j, index;\r\n\r\n        for (i = 0; i < strArray.length; i++) {\r\n          index = -1;\r\n          j = 0;\r\n          while (index === -1 && j < ordered.length) {\r\n            if (ordered[j].length > strArray[i].length) {\r\n              index = j;\r\n            }\r\n            j++;\r\n          }\r\n\r\n          if (index === -1) {\r\n            ordered.push(strArray[i]);\r\n          } else {\r\n            ordered.splice(index, 0, strArray[i]);\r\n          }\r\n        }\r\n        return ordered;\r\n      }\r\n\r\n      function getEventTree(oldRootHash,newRootHash,callback){\r\n        var error = null,\r\n          sRoot = null,\r\n          tRoot = null,\r\n          start = new Date().getTime(),\r\n          loadRoot = function(hash,root){\r\n            _core.loadRoot(hash,function(err,r){\r\n              error = error || err;\r\n              if(sRoot === null && hash === oldRootHash){\r\n                sRoot = r;\r\n              } else {\r\n                tRoot = r;\r\n              }\r\n              if(--needed === 0){\r\n                rootsLoaded();\r\n              }\r\n            });\r\n          },\r\n          rootsLoaded = function(){\r\n            if(error){\r\n              return callback(error);\r\n            }\r\n            _core./*generateLightTreeDiff*/generateTreeDiff(sRoot,tRoot,function(err,diff){\r\n              console.log('genDiffTree',new Date().getTime()-start);\r\n              console.log('diffTree',JSON.stringify(diff,null,2));\r\n              callback(err,diff);\r\n            });\r\n          },\r\n          needed = 2;\r\n        loadRoot(oldRootHash,sRoot);\r\n        loadRoot(newRootHash,tRoot);\r\n      }\r\n\r\n      function loadRoot(newRootHash, callback) {\r\n        //with the newer approach we try to optimize a bit the mechanizm of the loading and try to get rid of the paralellism behind it\r\n        var patterns = {},\r\n          orderedPatternIds = [],\r\n          error = null,\r\n          i, j, keysi, keysj,\r\n          loadNextPattern = function (index) {\r\n            if (index < orderedPatternIds.length) {\r\n              loadPattern(_core, orderedPatternIds[index], patterns[orderedPatternIds[index]], _loadNodes, function (err) {\r\n                error = error || err;\r\n                loadNextPattern(index + 1);\r\n              });\r\n            } else {\r\n              callback(error);\r\n            }\r\n          };\r\n        _loadNodes = {};\r\n        _loadError = 0;\r\n\r\n        //gathering the patterns\r\n        keysi = Object.keys(_users);\r\n        for (i = 0; i < keysi.length; i++) {\r\n          keysj = Object.keys(_users[keysi[i]].PATTERNS);\r\n          for (j = 0; j < keysj.length; j++) {\r\n            if (patterns[keysj[j]]) {\r\n              //we check if the range is bigger for the new definition\r\n              if (patterns[keysj[j]].children < _users[keysi[i]].PATTERNS[keysj[j]].children) {\r\n                patterns[keysj[j]].children = _users[keysi[i]].PATTERNS[keysj[j]].children;\r\n              }\r\n            } else {\r\n              patterns[keysj[j]] = _users[keysi[i]].PATTERNS[keysj[j]];\r\n            }\r\n          }\r\n        }\r\n        //getting an orderd keylist\r\n        orderedPatternIds = Object.keys(patterns);\r\n        orderedPatternIds = orderStringArrayByElementLength(orderedPatternIds);\r\n\r\n\r\n        //and now the one-by-one loading\r\n        _core.loadRoot(newRootHash, function (err, root) {\r\n          ASSERT(err || root);\r\n          _root = root;\r\n          error = error || err;\r\n          if (!err) {\r\n            //TODO here is the point where we can start / stop our addOns - but we will not wait for them to start\r\n            updateRunningAddOns(root);\r\n            _loadNodes[_core.getPath(root)] = {node: root, incomplete: true, basic: true, hash: getStringHash(root)};\r\n            _metaNodes[_core.getPath(root)] = root;\r\n            if (orderedPatternIds.length === 0 && Object.keys(_users) > 0) {\r\n              //we have user, but they do not interested in any object -> let's relaunch them :D\r\n              callback(null);\r\n              reLaunchUsers();\r\n            } else {\r\n              loadNextPattern(0);\r\n            }\r\n          } else {\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      //this is just a first brute implementation it needs serious optimization!!!\r\n      function loading(newRootHash,callback){\r\n        var finalEvents = function () {\r\n          var modifiedPaths;\r\n          modifiedPaths = getModifiedNodes(_loadNodes);\r\n          _nodes = _loadNodes;\r\n          _loadNodes = {};\r\n          for (var i in _users) {\r\n            userEvents(i, modifiedPaths);\r\n          }\r\n          callback(null);\r\n        };\r\n        callback = callback || function(err){};\r\n        _previousRootHash = _rootHash;\r\n        _rootHash = newRootHash;\r\n        if(_previousRootHash){\r\n          getEventTree(_previousRootHash,_rootHash,function(err,diffTree){\r\n            if(err){\r\n              _rootHash = null;\r\n              callback(err);\r\n            } else {\r\n              _changeTree = diffTree;\r\n              loadRoot(newRootHash,function(err){\r\n                if(err){\r\n                  _rootHash = null;\r\n                  callback(err);\r\n                } else {\r\n                  finalEvents();\r\n                }\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          loadRoot(newRootHash,function(err){\r\n            if(err){\r\n              _rootHash = null;\r\n              callback(err);\r\n            } else {\r\n              finalEvents();\r\n            }\r\n          });\r\n        }\r\n      }\r\n      function _loading(newRootHash, callback) {\r\n        callback = callback || function () {\r\n        };\r\n        var incomplete = false;\r\n        var modifiedPaths = {};\r\n        var missing = 2;\r\n        var finalEvents = function () {\r\n          if (_loadError > 0) {\r\n            //we assume that our immediate load was only partial\r\n            modifiedPaths = getModifiedNodes(_loadNodes);\r\n            _nodes = _loadNodes;\r\n            _loadNodes = {};\r\n            for (var i in _users) {\r\n              userEvents(i, modifiedPaths);\r\n            }\r\n            _loadError = 0;\r\n          } else if (_loadNodes[ROOT_PATH]) {\r\n            //we left the stuff in the loading rack, probably because there were no _nodes beforehand\r\n            _nodes = _loadNodes;\r\n            _loadNodes = {};\r\n          }\r\n          callback(null);\r\n        };\r\n\r\n        _previousRootHash = _rootHash;\r\n        _rootHash = newRootHash;\r\n        if(_previousRootHash){\r\n          getEventTree(_previousRootHash,_rootHash,function(err,diffTree){\r\n            if(err){\r\n              _rootHash = null;\r\n              callback(err);\r\n            } else {\r\n              _changeTree = diffTree;\r\n              loadRoot(newRootHash,function(err){\r\n                if(err){\r\n                  _rootHash = null;\r\n                  callback(err);\r\n                } else {\r\n                  if(--missing === 0){\r\n                    finalEvents();\r\n                  }\r\n                }\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          loadRoot(newRootHash,function(err){\r\n            if(err){\r\n              _rootHash = null;\r\n              callback(err);\r\n            } else {\r\n              if(--missing === 0){\r\n                finalEvents();\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        //here we try to make an immediate event building\r\n        //TODO we should deal with the full unloading!!!\r\n        //TODO we should check not to hide any issue related to immediate loading!!!\r\n        var hasEnoughNodes = false;\r\n        var counter = 0;\r\n        var limit = 0;\r\n        for (var i in _nodes) {\r\n          counter++;\r\n        }\r\n        limit = counter / 2;\r\n        counter = 0;\r\n        for (i in _loadNodes) {\r\n          counter++;\r\n        }\r\n        hasEnoughNodes = limit <= counter;\r\n        if (/*hasEnoughNodes*/false) {\r\n          modifiedPaths = getModifiedNodes(_loadNodes);\r\n          _nodes = {};\r\n          for (i in _loadNodes) {\r\n            _nodes[i] = _loadNodes[i];\r\n          }\r\n\r\n          for (i in _users) {\r\n            userEvents(i, modifiedPaths);\r\n          }\r\n\r\n          if (--missing === 0) {\r\n            finalEvents();\r\n          }\r\n\r\n        } else {\r\n          _loadError++;\r\n          if (--missing === 0) {\r\n            finalEvents();\r\n          }\r\n        }\r\n      }\r\n\r\n      function saveRoot(msg, callback) {\r\n        callback = callback || function () {\r\n        };\r\n        if (!_viewer && !_readOnlyProject) {\r\n          if (_msg) {\r\n            _msg += \"\\n\" + msg;\r\n          } else {\r\n            _msg += msg;\r\n          }\r\n          if (!_inTransaction) {\r\n            ASSERT(_project && _core && _branch);\r\n            _core.persist(_nodes[ROOT_PATH].node, function (err) {\r\n            });\r\n            var newRootHash = _core.getHash(_nodes[ROOT_PATH].node);\r\n            var newCommitHash = _project.makeCommit([_recentCommits[0]], newRootHash, _msg, function (err) {\r\n              //TODO now what??? - could we end up here?\r\n            });\r\n            _msg = \"\";\r\n            addCommit(newCommitHash);\r\n            _selfCommits[newCommitHash] = true;\r\n            _redoer.addModification(newCommitHash,\"\");\r\n            _project.setBranchHash(_branch, _recentCommits[1], _recentCommits[0], function (err) {\r\n              //TODO now what??? - could we screw up?\r\n              loading(newRootHash);\r\n              callback(err);\r\n            });\r\n            //loading(newRootHash);\r\n          } else {\r\n            _core.persist(_nodes[ROOT_PATH].node, function (err) {\r\n            });\r\n          }\r\n        } else {\r\n          _msg = \"\";\r\n        }\r\n      }\r\n\r\n      function getActiveProject() {\r\n        return _projectName;\r\n      }\r\n\r\n      function getAvailableProjectsAsync(callback) {\r\n        if (_database) {\r\n          _database.getProjectNames(callback);\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function getViewableProjectsAsync(callback) {\r\n        if (_database) {\r\n          _database.getAllowedProjectNames(callback);\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function getProjectAuthInfoAsync(projectname, callback) {\r\n        if (_database) {\r\n          _database.getAuthorizationInfo(projectname, callback);\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function getFullProjectListAsync(callback) {\r\n        _database.getProjectNames(function (err, names) {\r\n          if (!err && names) {\r\n            var wait = names.length || 0;\r\n            var fullList = {};\r\n            if (wait > 0) {\r\n              var getProjectAuthInfo = function (name, cb) {\r\n                _database.getAuthorizationInfo(name, function (err, authObj) {\r\n                  if (!err && authObj) {\r\n                    fullList[name] = authObj;\r\n                  }\r\n                  cb(err);\r\n                });\r\n              };\r\n\r\n              for (var i = 0; i < names.length; i++) {\r\n                getProjectAuthInfo(names[i], function (err) {\r\n                  if (--wait === 0) {\r\n                    callback(null, fullList);\r\n                  }\r\n                });\r\n              }\r\n            } else {\r\n              callback(null, {});\r\n            }\r\n          } else {\r\n            callback(err, {});\r\n          }\r\n        });\r\n      }\r\n\r\n      function selectProjectAsync(projectname, callback) {\r\n        if (_database) {\r\n          if (projectname === _projectName) {\r\n            callback(null);\r\n          } else {\r\n            closeOpenedProject(function (err) {\r\n              //TODO what can we do with the error??\r\n              openProject(projectname, function (err) {\r\n                //TODO is there a meaningful error which we should propagate towards user???\r\n                if(!err){\r\n                  reLaunchUsers();\r\n                }\r\n                callback(err);\r\n              });\r\n            });\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!!!'));\r\n        }\r\n      }\r\n\r\n      function createProjectAsync(projectname, projectInfo, callback) {\r\n        if (_database) {\r\n          getAvailableProjectsAsync(function (err, names) {\r\n            if (!err && names) {\r\n              if (names.indexOf(projectname) === -1) {\r\n                _database.openProject(projectname, function (err, p) {\r\n                  if (!err && p) {\r\n                    createEmptyProject(p, function (err, commit) {\r\n                      if (!err && commit) {\r\n                        //TODO currently this is just a hack\r\n                        p.setInfo(projectInfo || {\r\n                          visibleName:projectname,\r\n                          description:\"project in webGME\",\r\n                          tags:{}\r\n                        },function(err){\r\n                          callback(err);\r\n                        });\r\n                      } else {\r\n                        callback(err);\r\n                      }\r\n                    });\r\n                  } else {\r\n                    callback(err);\r\n                  }\r\n                });\r\n              } else {\r\n                //TODO maybe the selectProjectAsync could be called :)\r\n                callback('the project already exists!');\r\n              }\r\n            } else {\r\n              callback(err);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n\r\n      }\r\n\r\n      function deleteProjectAsync(projectname, callback) {\r\n        if (_database) {\r\n          if (projectname === _projectName) {\r\n            closeOpenedProject();\r\n          }\r\n          _database.deleteProject(projectname, callback);\r\n\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      //branching functionality\r\n      function getBranchesAsync(callback) {\r\n        if (_database) {\r\n          if (_project) {\r\n            _project.getBranchNames(function (err, names) {\r\n              if (!err && names) {\r\n                var missing = 0;\r\n                var branchArray = [];\r\n                var error = null;\r\n                var getBranchValues = function (name) {\r\n                  _project.getBranchHash(name, '#hack', function (err, newhash, forked) {\r\n                    if (!err && newhash) {\r\n                      var element = {name: name, commitId: newhash};\r\n                      if (forked) {\r\n                        element.sync = false;\r\n                      } else {\r\n                        element.sync = true;\r\n                      }\r\n                      branchArray.push(element);\r\n                    } else {\r\n                      error = error || err;\r\n                    }\r\n\r\n                    if (--missing === 0) {\r\n                      callback(error, branchArray);\r\n                    }\r\n                  });\r\n                };\r\n\r\n                for (var i in names) {\r\n                  missing++;\r\n                }\r\n                if (missing > 0) {\r\n                  for (i in names) {\r\n                    getBranchValues(i);\r\n                  }\r\n                } else {\r\n                  callback(null, branchArray);\r\n                }\r\n              } else {\r\n                callback(err);\r\n              }\r\n            });\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no opened database connection!'));\r\n        }\r\n      }\r\n\r\n      function viewerCommit(hash, callback) {\r\n        //no project change\r\n        //we stop watching branch\r\n        //we create the core\r\n        //we use the existing territories\r\n        //we set viewer mode, so there will be no modification allowed to send to server...\r\n        _branch = null;\r\n        _viewer = true;\r\n        _recentCommits = [hash];\r\n        _self.dispatchEvent(_self.events.BRANCH_CHANGED, _branch);\r\n        _project.loadObject(hash, function (err, commitObj) {\r\n          if (!err && commitObj) {\r\n            loading(commitObj.root, callback);\r\n          } else {\r\n            logger.error('Cannot view given ' + hash + ' commit as it\\'s root cannot be loaded! [' + JSON.stringify(err) + ']');\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      function selectCommitAsync(hash, callback) {\r\n        //this should proxy to branch selection and viewer functions\r\n        if (_database) {\r\n          if (_project) {\r\n            viewerCommit(hash, callback);\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function selectBranchAsync(branch, callback) {\r\n        var waiting = 1,\r\n          error = null,\r\n          innerCallback = function (err) {\r\n            error = error || err;\r\n            if (--waiting === 0) {\r\n              callback(error);\r\n            }\r\n          }\r\n        if (_database) {\r\n          if (_project) {\r\n            _project.getBranchNames(function (err, names) {\r\n              if (err) {\r\n                return callback(err);\r\n              }\r\n\r\n              if (names[branch]) {\r\n                stopRunningAddOns();\r\n                branchWatcher(branch, innerCallback);\r\n                //startCoreAddOnsAsync(_projectName,branch,innerCallback);\r\n              } else {\r\n                callback(new Error('there is no such branch!'));\r\n              }\r\n\r\n            });\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function getCommitsAsync(commitHash, number, callback) {\r\n        if (_database) {\r\n          if (_project) {\r\n            ASSERT(_commitCache);\r\n            if (commitHash === undefined) {\r\n              commitHash = null;\r\n            }\r\n            _commitCache.getNCommitsFrom(commitHash, number, callback);\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function getActualCommit() {\r\n        return _recentCommits[0];\r\n      }\r\n\r\n      function getActualBranch() {\r\n        return _branch;\r\n      }\r\n\r\n      function getActualNetworkStatus() {\r\n        return _networkStatus;\r\n      }\r\n\r\n      function getActualBranchStatus() {\r\n        return _branchState;\r\n      }\r\n\r\n      function createBranchAsync(branchName, commitHash, callback) {\r\n        //it doesn't changes anything, just creates the new branch\r\n        if (_database) {\r\n          if (_project) {\r\n            _project.setBranchHash(branchName, '', commitHash, callback);\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function deleteBranchAsync(branchName, callback) {\r\n        if (_database) {\r\n          if (_project) {\r\n            _project.getBranchHash(branchName, '', function (err, newhash, forkedhash) {\r\n              if (!err && newhash) {\r\n                if (forkedhash) {\r\n                  _project.setBranchHash(branchName, newhash, forkedhash, function (err) {\r\n                    if (!err) {\r\n                      changeBranchState(_self.branchStates.SYNC);\r\n                    }\r\n                    callback(err);\r\n                  });\r\n                } else {\r\n                  _project.setBranchHash(branchName, newhash, '', callback);\r\n                }\r\n              } else {\r\n                callback(err);\r\n              }\r\n            });\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function commitAsync(params, callback) {\r\n        if (_database) {\r\n          if (_project) {\r\n            var msg = params.message || '';\r\n            saveRoot(msg, callback);\r\n          } else {\r\n            callback(new Error('there is no open project!'));\r\n          }\r\n        } else {\r\n          callback(new Error('there is no open database connection!'));\r\n        }\r\n      }\r\n\r\n      function connectToDatabaseAsync(options, callback) {\r\n        var oldcallback = callback;\r\n        callback = function (err) {\r\n          _TOKEN = tokenWatcher();\r\n          reLaunchUsers();\r\n          oldcallback(err);\r\n        }; //we add tokenWatcher start at this point\r\n        options = options || {};\r\n        callback = callback || function () {\r\n        };\r\n        options.open = (options.open !== undefined || options.open !== null) ? options.open : false;\r\n        options.project = options.project || null;\r\n        if (_database) {\r\n          //we have to close the current\r\n          closeOpenedProject(function () {\r\n          });\r\n          _database.closeDatabase(function () {\r\n          });\r\n          _networkStatus = \"\";\r\n          changeBranchState(null);\r\n        }\r\n        _database = newDatabase();\r\n\r\n        _database.openDatabase(function (err) {\r\n          if (!err) {\r\n            if (_networkWatcher) {\r\n              _networkWatcher.stop();\r\n            }\r\n            _networkWatcher = networkWatcher();\r\n            serverEventer();\r\n\r\n            if (options.open) {\r\n              if (options.project) {\r\n                openProject(options.project, callback);\r\n              } else {\r\n                //default opening routine\r\n                _database.getProjectNames(function (err, names) {\r\n                  if (!err && names && names.length > 0) {\r\n                    openProject(names[0], callback);\r\n                  } else {\r\n                    logger.error('Cannot get project names / There is no project on the server');\r\n                    callback(err);\r\n                  }\r\n                });\r\n              }\r\n            } else {\r\n              callback(null);\r\n            }\r\n          } else {\r\n            logger.error('Cannot open database');\r\n            callback(err);\r\n          }\r\n        });\r\n      }\r\n\r\n      //MGA\r\n      function copyMoreNodes(parameters, msg) {\r\n        var pathestocopy = [];\r\n        if (typeof parameters.parentId === 'string' && _nodes[parameters.parentId] && typeof _nodes[parameters.parentId].node === 'object') {\r\n          for (var i in parameters) {\r\n            if (i !== \"parentId\") {\r\n              pathestocopy.push(i);\r\n            }\r\n          }\r\n\r\n          msg = msg || 'copyMoreNodes(' + pathestocopy + ',' + parameters.parentId + ')';\r\n          if (pathestocopy.length < 1) {\r\n          } else if (pathestocopy.length === 1) {\r\n            var newNode = _core.copyNode(_nodes[pathestocopy[0]].node, _nodes[parameters.parentId].node);\r\n            storeNode(newNode);\r\n            if (parameters[pathestocopy[0]]) {\r\n              for (var j in parameters[pathestocopy[0]].attributes) {\r\n                _core.setAttribute(newNode, j, parameters[pathestocopy[0]].attributes[j]);\r\n              }\r\n              for (j in parameters[pathestocopy[0]].registry) {\r\n                _core.setRegistry(newNode, j, parameters[pathestocopy[0]].registry[j]);\r\n              }\r\n            }\r\n            saveRoot(msg);\r\n          } else {\r\n            copyMoreNodesAsync(pathestocopy, parameters.parentId, function (err, copyarr) {\r\n              if (err) {\r\n                //rollBackModification();\r\n              }\r\n              else {\r\n                for (var i in copyarr) {\r\n                  if (parameters[i]) {\r\n                    for (var j in parameters[i].attributes) {\r\n                      _core.setAttribute(copyarr[i], j, parameters[i].attributes[j]);\r\n                    }\r\n                    for (j in parameters[i].registry) {\r\n                      _core.setRegistry(copyarr[i], j, parameters[i].registry[j]);\r\n                    }\r\n                  }\r\n                }\r\n                saveRoot(msg);\r\n              }\r\n            });\r\n          }\r\n        } else {\r\n          console.log('wrong parameters for copy operation - denied -');\r\n        }\r\n      }\r\n\r\n\r\n      function copyMoreNodesAsync(nodePaths, parentPath, callback) {\r\n        var checkPaths = function () {\r\n          var result = true;\r\n          for (var i = 0; i < nodePaths.length; i++) {\r\n            result = result && (_nodes[nodePaths[i]] && typeof _nodes[nodePaths[i]].node === 'object');\r\n          }\r\n          return result;\r\n        };\r\n\r\n        if (_nodes[parentPath] && typeof _nodes[parentPath].node === 'object' && checkPaths()) {\r\n          var helpArray = {},\r\n            subPathArray = {},\r\n            parent = _nodes[parentPath].node,\r\n            returnArray = {};\r\n\r\n          //creating the 'from' object\r\n          var tempFrom = _core.createNode({parent: parent, base: _core.getTypeRoot(_nodes[nodePaths[0]].node)});\r\n          //and moving every node under it\r\n          for (var i = 0; i < nodePaths.length; i++) {\r\n            helpArray[nodePaths[i]] = {};\r\n            helpArray[nodePaths[i]].origparent = _core.getParent(_nodes[nodePaths[i]].node);\r\n            helpArray[nodePaths[i]].tempnode = _core.moveNode(_nodes[nodePaths[i]].node, tempFrom);\r\n            subPathArray[_core.getRelid(helpArray[nodePaths[i]].tempnode)] = nodePaths[i];\r\n            delete _nodes[nodePaths[i]];\r\n          }\r\n\r\n          //do the copy\r\n          var tempTo = _core.copyNode(tempFrom, parent);\r\n\r\n          //moving back the temporary source\r\n          for (var i = 0; i < nodePaths.length; i++) {\r\n            helpArray[nodePaths[i]].node = _core.moveNode(helpArray[nodePaths[i]].tempnode, helpArray[nodePaths[i]].origparent);\r\n            storeNode(helpArray[nodePaths[i]].node);\r\n          }\r\n\r\n          //gathering the destination nodes\r\n          _core.loadChildren(tempTo, function (err, children) {\r\n            if (!err && children && children.length > 0) {\r\n              for (i = 0; i < children.length; i++) {\r\n                if (subPathArray[_core.getRelid(children[i])]) {\r\n                  var newNode = _core.moveNode(children[i], parent);\r\n                  storeNode(newNode);\r\n                  returnArray[subPathArray[_core.getRelid(children[i])]] = newNode;\r\n                } else {\r\n                  console.log('635 - should never happen!!!');\r\n                }\r\n              }\r\n              _core.deleteNode(tempFrom);\r\n              _core.deleteNode(tempTo);\r\n              callback(null, returnArray);\r\n            } else {\r\n              //clean up the mess and return\r\n              _core.deleteNode(tempFrom);\r\n              _core.deleteNode(tempTo);\r\n              callback(err, {});\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      function _copyMoreNodes(parameters) {\r\n        //now we will use the multiple copy function of the core\r\n        var nodes = [],\r\n          copiedNodes,\r\n          i, j, paths, keys,\r\n          parent = _nodes[parameters.parentId].node,\r\n          resultMap = {};\r\n        keys = Object.keys(parameters);\r\n        keys.splice(keys.indexOf('parentId'), 1);\r\n        paths = keys;\r\n        for (i = 0; i < paths.length; i++) {\r\n          nodes.push(_nodes[paths[i]].node);\r\n        }\r\n\r\n        copiedNodes = _core.copyNodes(nodes, parent);\r\n\r\n        for (i = 0; i < paths.length; i++) {\r\n          keys = Object.keys(parameters[paths[i]].attributes || {});\r\n          for (j = 0; j < keys.length; j++) {\r\n            _core.setAttribute(copiedNodes[i], keys[j], parameters[paths[i]].attributes[keys[j]]);\r\n          }\r\n\r\n          keys = Object.keys(parameters[paths[i]].registry || {});\r\n          for (j = 0; j < keys.length; j++) {\r\n            _core.setRegistry(copiedNodes[i], keys[j], parameters[paths[i]].registry[keys[j]]);\r\n          }\r\n        }\r\n\r\n\r\n        //creating the result map and storing the nodes to our cache, so the user will know which path became which\r\n        for (i = 0; i < paths.length; i++) {\r\n          resultMap[paths[i]] = storeNode(copiedNodes[i]);\r\n        }\r\n\r\n        return resultMap;\r\n      }\r\n\r\n      function moveMoreNodes(parameters) {\r\n        var pathsToMove = [],\r\n          returnParams = {};\r\n        for (var i in parameters) {\r\n          if (i !== 'parentId') {\r\n            pathsToMove.push(i);\r\n          }\r\n        }\r\n\r\n        if (pathsToMove.length > 0 && typeof parameters.parentId === 'string' && _nodes[parameters.parentId] && typeof _nodes[parameters.parentId].node === 'object') {\r\n          for (var i = 0; i < pathsToMove.length; i++) {\r\n            if (_nodes[pathsToMove[i]] && typeof _nodes[pathsToMove[i]].node === 'object') {\r\n              var newNode = _core.moveNode(_nodes[pathsToMove[i]].node, _nodes[parameters.parentId].node);\r\n              returnParams[pathsToMove[i]] = _core.getPath(newNode);\r\n              if (parameters[pathsToMove[i]].attributes) {\r\n                for (var j in parameters[pathsToMove[i]].attributes) {\r\n                  _core.setAttribute(newNode, j, parameters[pathsToMove[i]].attributes[j]);\r\n                }\r\n              }\r\n              if (parameters[pathsToMove[i]].registry) {\r\n                for (var j in parameters[pathsToMove[i]].registry) {\r\n                  _core.setRegistry(newNode, j, parameters[pathsToMove[i]].registry[j]);\r\n                }\r\n              }\r\n\r\n              delete _nodes[pathsToMove[i]];\r\n              storeNode(newNode, true);\r\n            }\r\n          }\r\n        }\r\n\r\n        return returnParams;\r\n      }\r\n\r\n      function createChildren(parameters, msg) {\r\n        //TODO we also have to check out what is happening with the sets!!!\r\n        var result = {},\r\n          paths = [],\r\n          nodes = [], node,\r\n          parent = _nodes[parameters.parentId].node,\r\n          names, i, j, index, keys, pointer,\r\n          newChildren = [], relations = [];\r\n\r\n        //to allow 'meaningfull' instantiation of multiple objects we have to recreate the internal relations - except the base\r\n        paths = Object.keys(parameters);\r\n        paths.splice(paths.indexOf('parentId'), 1);\r\n        for (i = 0; i < paths.length; i++) {\r\n          node = _nodes[paths[i]].node;\r\n          nodes.push(node);\r\n          pointer = {};\r\n          names = _core.getPointerNames(node);\r\n          index = names.indexOf('base');\r\n          if (index !== -1) {\r\n            names.splice(index, 1);\r\n          }\r\n\r\n          for (j = 0; j < names.length; j++) {\r\n            index = paths.indexOf(_core.getPointerPath(node, names[j]));\r\n            if (index !== -1) {\r\n              pointer[names[j]] = index;\r\n            }\r\n          }\r\n          relations.push(pointer);\r\n        }\r\n\r\n        //now the instantiation\r\n        for (i = 0; i < nodes.length; i++) {\r\n          newChildren.push(_core.createNode({parent: parent, base: nodes[i]}));\r\n        }\r\n\r\n        //now for the storage and relation setting\r\n        for (i = 0; i < paths.length; i++) {\r\n          //attributes\r\n          names = Object.keys(parameters[paths[i]].attributes || {});\r\n          for (j = 0; j < names.length; j++) {\r\n            _core.setAttribute(newChildren[i], names[j], parameters[paths[i]].attributes[names[j]]);\r\n          }\r\n          //registry\r\n          names = Object.keys(parameters[paths[i]].registry || {});\r\n          for (j = 0; j < names.length; j++) {\r\n            _core.setRegistry(newChildren[i], names[j], parameters[paths[i]].registry[names[j]]);\r\n          }\r\n\r\n          //relations\r\n          names = Object.keys(relations[i]);\r\n          for (j = 0; j < names.length; j++) {\r\n            _core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);\r\n          }\r\n\r\n          //store\r\n          result[paths[i]] = storeNode(newChildren[i]);\r\n\r\n        }\r\n\r\n        msg = msg || 'createChildren(' + JSON.stringify(result) + ')';\r\n        saveRoot(msg);\r\n        return result;\r\n      }\r\n\r\n\r\n      function startTransaction(msg) {\r\n        if (_core) {\r\n          _inTransaction = true;\r\n          msg = msg || 'startTransaction()';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function completeTransaction(msg, callback) {\r\n        _inTransaction = false;\r\n        if (_core) {\r\n          msg = msg || 'completeTransaction()';\r\n          saveRoot(msg, callback);\r\n        }\r\n      }\r\n\r\n      function setAttributes(path, name, value, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setAttribute(_nodes[path].node, name, value);\r\n          msg = msg || 'setAttribute(' + path + ',' + name + ',' + value + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function delAttributes(path, name, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delAttribute(_nodes[path].node, name);\r\n          msg = msg || 'delAttribute(' + path + ',' + name + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function setRegistry(path, name, value, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setRegistry(_nodes[path].node, name, value);\r\n          msg = msg || 'setRegistry(' + path + ',' + ',' + name + ',' + value + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function delRegistry(path, name, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delRegistry(_nodes[path].node, name);\r\n          msg = msg || 'delRegistry(' + path + ',' + ',' + name + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function deleteNode(path, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.deleteNode(_nodes[path].node);\r\n          //delete _nodes[path];\r\n          msg = msg || 'deleteNode(' + path + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function delMoreNodes(paths, msg) {\r\n        if (_core) {\r\n          for (var i = 0; i < paths.length; i++) {\r\n            if (_nodes[paths[i]] && typeof _nodes[paths[i]].node === 'object') {\r\n              _core.deleteNode(_nodes[paths[i]].node);\r\n              //delete _nodes[paths[i]];\r\n            }\r\n          }\r\n          msg = msg || 'delMoreNodes(' + paths + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function createChild(parameters, msg) {\r\n        var newID;\r\n\r\n        if (_core) {\r\n          if (typeof parameters.parentId === 'string' && _nodes[parameters.parentId] && typeof _nodes[parameters.parentId].node === 'object') {\r\n            var baseNode = null;\r\n            if (_nodes[parameters.baseId]) {\r\n              baseNode = _nodes[parameters.baseId].node || baseNode;\r\n            }\r\n            var child = _core.createNode({parent: _nodes[parameters.parentId].node, base: baseNode, guid: parameters.guid, relid: parameters.relid});\r\n            if (parameters.position) {\r\n              _core.setRegistry(child, \"position\", { \"x\": parameters.position.x || 100, \"y\": parameters.position.y || 100});\r\n            } else {\r\n              _core.setRegistry(child, \"position\", { \"x\": 100, \"y\": 100});\r\n            }\r\n            storeNode(child);\r\n            newID = _core.getPath(child);\r\n            msg = msg || 'createChild(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')';\r\n            saveRoot(msg);\r\n          }\r\n        }\r\n\r\n        return newID;\r\n      }\r\n\r\n      function makePointer(id, name, to, msg) {\r\n        if (to === null) {\r\n          _core.setPointer(_nodes[id].node, name, to);\r\n        } else {\r\n\r\n\r\n          _core.setPointer(_nodes[id].node, name, _nodes[to].node);\r\n        }\r\n\r\n        msg = msg || 'makePointer(' + id + ',' + name + ',' + to + ')';\r\n        saveRoot(msg);\r\n      }\r\n\r\n      function delPointer(path, name, msg) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setPointer(_nodes[path].node, name, undefined);\r\n          msg = msg || 'delPointer(' + path + ',' + name + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n\r\n      //MGAlike - set functions\r\n      function addMember(path, memberpath, setid, msg) {\r\n        if (_nodes[path] &&\r\n          _nodes[memberpath] &&\r\n          typeof _nodes[path].node === 'object' &&\r\n          typeof _nodes[memberpath].node === 'object') {\r\n          _core.addMember(_nodes[path].node, setid, _nodes[memberpath].node);\r\n          msg = msg || 'addMember(' + path + ',' + memberpath + ',' + setid + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function removeMember(path, memberpath, setid, msg) {\r\n        if (_nodes[path] &&\r\n          typeof _nodes[path].node === 'object') {\r\n          _core.delMember(_nodes[path].node, setid, memberpath);\r\n          msg = msg || 'removeMember(' + path + ',' + memberpath + ',' + setid + ')';\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function setMemberAttribute(path, memberpath, setid, name, value, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setMemberAttribute(_nodes[path].node, setid, memberpath, name, value);\r\n          msg = msg || 'setMemberAttribute(' + path + \",\" + memberpath + \",\" + setid + \",\" + name + \",\" + value + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function delMemberAttribute(path, memberpath, setid, name, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delMemberAttribute(_nodes[path].node, setid, memberpath, name);\r\n          msg = msg || 'delMemberAttribute(' + path + \",\" + memberpath + \",\" + setid + \",\" + name + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function setMemberRegistry(path, memberpath, setid, name, value, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setMemberRegistry(_nodes[path].node, setid, memberpath, name, value);\r\n          msg = msg || 'setMemberRegistry(' + path + \",\" + memberpath + \",\" + setid + \",\" + name + \",\" + value + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function delMemberRegistry(path, memberpath, setid, name, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delMemberRegistry(_nodes[path].node, setid, memberpath, name);\r\n          msg = msg || 'delMemberRegistry(' + path + \",\" + memberpath + \",\" + setid + \",\" + name + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function createSet(path, setid, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.createSet(_nodes[path].node, setid);\r\n          msg = msg || 'createSet(' + path + \",\" + setid + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      function deleteSet(path, setid, msg) {\r\n        if (_nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.deleteSet(_nodes[path].node, setid);\r\n          msg = msg || 'deleteSet(' + path + \",\" + setid + \")\";\r\n          saveRoot(msg);\r\n        }\r\n      }\r\n\r\n      //Meta like descriptor functions\r\n      function setAttributeDescriptor(path, attributename, descriptor) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setAttributeDescriptor(_nodes[path].node, attributename, descriptor);\r\n          saveRoot('setAttributeDescriptor(' + path + ',' + ',' + attributename + ')');\r\n        }\r\n      }\r\n\r\n      function delAttributeDescriptor(path, attributename) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delAttributeDescriptor(_nodes[path].node, attributename);\r\n          saveRoot('delAttributeDescriptor(' + path + ',' + ',' + attributename + ')');\r\n        }\r\n      }\r\n\r\n      function setPointerDescriptor(path, pointername, descriptor) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setPointerDescriptor(_nodes[path].node, pointername, descriptor);\r\n          saveRoot('setPointerDescriptor(' + path + ',' + ',' + pointername + ')');\r\n        }\r\n      }\r\n\r\n      function delPointerDescriptor(path, pointername) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delPointerDescriptor(_nodes[path].node, pointername);\r\n          saveRoot('delPointerDescriptor(' + path + ',' + ',' + pointername + ')');\r\n        }\r\n      }\r\n\r\n      function setChildrenMetaDescriptor(path, descriptor) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setNodeDescriptor(_nodes[path].node, descriptor);\r\n          saveRoot('setNodeDescriptor(' + path + ')');\r\n        }\r\n      }\r\n\r\n      function delChildrenMetaDescriptor(path) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delNodeDescriptor(_nodes[path].node);\r\n          saveRoot('delNodeDescriptor(' + path + ')');\r\n        }\r\n      }\r\n\r\n      function setBase(path, basepath) {\r\n        /*if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n         _core.setRegistry(_nodes[path].node,'base',basepath);\r\n         saveRoot('setBase('+path+','+basepath+')');\r\n         }*/\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object' && _nodes[basepath] && typeof _nodes[basepath].node === 'object') {\r\n          _core.setBase(_nodes[path].node, _nodes[basepath].node);\r\n          saveRoot('setBase(' + path + ',' + basepath + ')');\r\n        }\r\n      }\r\n\r\n      function delBase(path) {\r\n        /*if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n         _core.delRegistry(_nodes[path].node,'base');\r\n         saveRoot('delBase('+path+')');\r\n         }*/\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setBase(_nodes[path].node, null);\r\n          saveRoot('delBase(' + path + ')');\r\n        }\r\n      }\r\n\r\n\r\n      //constraint functions\r\n      function setConstraint(path, name, constraintObj) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.setConstraint(_nodes[path].node, name, constraintObj);\r\n          saveRoot('setConstraint(' + path + ',' + name + ')');\r\n        }\r\n      }\r\n\r\n      function delConstraint(path, name) {\r\n        if (_core && _nodes[path] && typeof _nodes[path].node === 'object') {\r\n          _core.delConstraint(_nodes[path].node, name);\r\n          saveRoot('delConstraint(' + path + 'name' + ')');\r\n        }\r\n      }\r\n\r\n      //territory functions\r\n      function addUI(ui, fn, guid) {\r\n        ASSERT(fn);\r\n        ASSERT(typeof fn === 'function');\r\n        guid = guid || GUID();\r\n        _users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};\r\n        return guid;\r\n      }\r\n\r\n      function removeUI(guid) {\r\n        delete _users[guid];\r\n      }\r\n\r\n      function _updateTerritoryAllDone(guid, patterns, error) {\r\n        if (_users[guid]) {\r\n          _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n          if (!error) {\r\n            userEvents(guid, []);\r\n          }\r\n        }\r\n      }\r\n\r\n      function updateTerritory(guid, patterns) {\r\n        if (_users[guid]) {\r\n          if (_project) {\r\n            if (_nodes[ROOT_PATH]) {\r\n              //TODO: this has to be optimized\r\n              var missing = 0;\r\n              var error = null;\r\n\r\n              var patternLoaded = function (err) {\r\n                error = error || err;\r\n                if (--missing === 0) {\r\n                  //allDone();\r\n                  _updateTerritoryAllDone(guid, patterns, error);\r\n                }\r\n              };\r\n\r\n              //EXTRADTED OUT TO: _updateTerritoryAllDone\r\n              /*var allDone = function(){\r\n               if(_users[guid]){\r\n               _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n               if(!error){\r\n               userEvents(guid,[]);\r\n               }\r\n               }\r\n               };*/\r\n              for (var i in patterns) {\r\n                missing++;\r\n              }\r\n              if (missing > 0) {\r\n                for (i in patterns) {\r\n                  loadPattern(_core, i, patterns[i], _nodes, patternLoaded);\r\n                }\r\n              } else {\r\n                //allDone();\r\n                _updateTerritoryAllDone(guid, patterns, error);\r\n              }\r\n            } else {\r\n              //something funny is going on\r\n              if (_loadNodes[ROOT_PATH]) {\r\n                //probably we are in the loading process, so we should redo this update when the loading finishes\r\n                //setTimeout(updateTerritory,100,guid,patterns);\r\n              } else {\r\n                //root is not in nodes and has not even started to load it yet...\r\n                _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n              }\r\n            }\r\n          } else {\r\n            //we should update the patterns, but that is all\r\n            _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n          }\r\n        }\r\n      }\r\n\r\n      //getNode\r\n      function getNode(_id) {\r\n\r\n        var setNames = {\r\n          VALIDCHILDREN: 'ValidChildren',\r\n          VALIDSOURCE: 'ValidSource',\r\n          VALIDDESTINATION: 'ValidDestination',\r\n          VALIDINHERITOR: 'ValidInheritor',\r\n          GENERAL: 'General'\r\n        };\r\n\r\n        var getParentId = function () {\r\n          return storeNode(_core.getParent(_nodes[_id].node)); //just for sure, as it may missing from the cache\r\n        };\r\n\r\n        var getId = function () {\r\n          return _id;\r\n        };\r\n\r\n        var getGuid = function () {\r\n          return _core.getGuid(_nodes[_id].node);\r\n        };\r\n\r\n        var getChildrenIds = function () {\r\n          return _core.getChildrenPaths(_nodes[_id].node);\r\n        };\r\n\r\n        var getBaseId = function () {\r\n          return storeNode(_core.getBase(_nodes[_id].node)); //just for sure, maybe the base is missing from the cache\r\n        };\r\n\r\n        var getInheritorIds = function () {\r\n          return [];\r\n        };\r\n\r\n        var getAttribute = function (name) {\r\n          return _core.getAttribute(_nodes[_id].node, name);\r\n        };\r\n        var getOwnAttribute = function (name) {\r\n          return _core.getOwnAttribute(_nodes[_id].node, name);\r\n        };\r\n\r\n        var getEditableAttribute = function (name) {\r\n          var value = _core.getAttribute(_nodes[_id].node, name);\r\n          if (typeof value === 'object') {\r\n            return JSON.parse(JSON.stringify(value));\r\n          }\r\n          return value;\r\n        };\r\n        var getOwnEditableAttribute = function (name) {\r\n          var value = _core.getOwnAttribute(_nodes[_id].node, name);\r\n          if (typeof value === 'object') {\r\n            return JSON.parse(JSON.stringify(value));\r\n          }\r\n          return value;\r\n        };\r\n\r\n        var getRegistry = function (name) {\r\n          return _core.getRegistry(_nodes[_id].node, name);\r\n        };\r\n        var getOwnRegistry = function (name) {\r\n          return _core.getOwnRegistry(_nodes[_id].node, name);\r\n        };\r\n\r\n        var getEditableRegistry = function (name) {\r\n          var value = _core.getRegistry(_nodes[_id].node, name);\r\n          if (typeof value === 'object') {\r\n            return JSON.parse(JSON.stringify(value));\r\n          }\r\n          return value;\r\n        };\r\n        var getOwnEditableRegistry = function (name) {\r\n          var value = _core.getOwnRegistry(_nodes[_id].node, name);\r\n          if (typeof value === 'object') {\r\n            return JSON.parse(JSON.stringify(value));\r\n          }\r\n          return value;\r\n        };\r\n\r\n        var getPointer = function (name) {\r\n          //return _core.getPointerPath(_nodes[_id].node,name);\r\n          if (name === 'base') {\r\n            //base is a special case as it complicates with inherited children\r\n            return {to: _core.getPath(_core.getBase(_nodes[_id].node)), from: []};\r\n          }\r\n          return {to: _core.getPointerPath(_nodes[_id].node, name), from: []};\r\n        };\r\n        var getOwnPointer = function (name) {\r\n          return {to: _core.getOwnPointerPath(_nodes[_id].node, name), from: []};\r\n        };\r\n\r\n        var getPointerNames = function () {\r\n          return _core.getPointerNames(_nodes[_id].node);\r\n        };\r\n        var getOwnPointerNames = function () {\r\n          return _core.getOwnPointerNames(_nodes[_id].node);\r\n        };\r\n\r\n        var getAttributeNames = function () {\r\n          return _core.getAttributeNames(_nodes[_id].node);\r\n        };\r\n        var getOwnAttributeNames = function () {\r\n          return _core.getOwnAttributeNames(_nodes[_id].node);\r\n        };\r\n\r\n\r\n        var getRegistryNames = function () {\r\n          return _core.getRegistryNames(_nodes[_id].node);\r\n        };\r\n        var getOwnRegistryNames = function () {\r\n          return _core.getOwnRegistryNames(_nodes[_id].node);\r\n        };\r\n\r\n        //SET\r\n        var getMemberIds = function (setid) {\r\n          return _core.getMemberPaths(_nodes[_id].node, setid);\r\n        };\r\n        var getSetNames = function () {\r\n          return _core.getSetNames(_nodes[_id].node);\r\n        };\r\n        var getMemberAttributeNames = function (setid, memberid) {\r\n          return _core.getMemberAttributeNames(_nodes[_id].node, setid, memberid);\r\n        };\r\n        var getMemberAttribute = function (setid, memberid, name) {\r\n          return _core.getMemberAttribute(_nodes[_id].node, setid, memberid, name);\r\n        };\r\n        var getEditableMemberAttribute = function (setid, memberid, name) {\r\n          var attr = _core.getMemberAttribute(_nodes[_id].node, setid, memberid, name);\r\n          if (attr !== null && attr !== undefined) {\r\n            return JSON.parse(JSON.stringify(attr));\r\n          }\r\n          return null;\r\n        };\r\n\r\n        var getMemberRegistryNames = function (setid, memberid) {\r\n          return _core.getMemberRegistryNames(_nodes[_id].node, setid, memberid);\r\n        };\r\n        var getMemberRegistry = function (setid, memberid, name) {\r\n          return _core.getMemberRegistry(_nodes[_id].node, setid, memberid, name);\r\n        };\r\n        var getEditableMemberRegistry = function (setid, memberid, name) {\r\n          var attr = _core.getMemberRegistry(_nodes[_id].node, setid, memberid, name);\r\n          if (attr !== null && attr !== undefined) {\r\n            return JSON.parse(JSON.stringify(attr));\r\n          }\r\n          return null;\r\n        };\r\n\r\n        //META\r\n        var getValidChildrenTypes = function () {\r\n          //return getMemberIds('ValidChildren');\r\n          return META.getValidChildrenTypes(_id);\r\n        };\r\n        var getAttributeDescriptor = function (attributename) {\r\n          return _core.getAttributeDescriptor(_nodes[_id].node, attributename);\r\n        };\r\n        var getEditableAttributeDescriptor = function (attributename) {\r\n          var descriptor = _core.getAttributeDescriptor(_nodes[_id].node, attributename);\r\n          if (typeof descriptor === 'object') {\r\n            descriptor = JSON.parse(JSON.stringify(descriptor));\r\n          }\r\n          return descriptor;\r\n        };\r\n        var getPointerDescriptor = function (pointername) {\r\n          return _core.getPointerDescriptor(_nodes[_id].node, pointername);\r\n        };\r\n        var getEditablePointerDescriptor = function (pointername) {\r\n          var descriptor = _core.getPointerDescriptor(_nodes[_id].node, pointername);\r\n          if (typeof descriptor === 'object') {\r\n            descriptor = JSON.parse(JSON.stringify(descriptor));\r\n          }\r\n          return descriptor;\r\n        };\r\n        var getChildrenMetaDescriptor = function () {\r\n          return _core.getNodeDescriptor(_nodes[_id].node);\r\n        };\r\n        var getEditableChildrenMetaDescriptor = function () {\r\n          var descriptor = _core.getNodeDescriptor(_nodes[_id].node);\r\n          if (typeof descriptor === 'object') {\r\n            descriptor = JSON.parse(JSON.stringify(descriptor));\r\n          }\r\n          return descriptor;\r\n        };\r\n\r\n\r\n        //constraint functions\r\n        var getConstraintNames = function () {\r\n          return _core.getConstraintNames(_nodes[_id].node);\r\n        };\r\n        var getOwnConstraintNames = function () {\r\n          return _core.getOwnConstraintNames(_nodes[_id].node);\r\n        };\r\n        var getConstraint = function (name) {\r\n          return _core.getConstraint(_nodes[_id].node, name);\r\n        };\r\n        //ASSERT(_nodes[_id]);\r\n\r\n        var printData = function () {\r\n          //probably we will still use it for test purposes, but now it goes officially into printing the node's json representation\r\n          ToJson(_core, _nodes[_id].node, \"\", 'guid', function (err, jNode) {\r\n            console.log('node in JSON format[status = ', err, ']:', jNode);\r\n          });\r\n        };\r\n\r\n        var toString = function () {\r\n          return _core.getAttribute(_nodes[_id].node, 'name') + ' (' + _id + ')';\r\n        };\r\n\r\n        var getCollectionPaths = function (name) {\r\n          return _core.getCollectionPaths(_nodes[_id].node, name);\r\n        };\r\n\r\n        if (_nodes[_id]) {\r\n          return {\r\n            getParentId: getParentId,\r\n            getId: getId,\r\n            getGuid: getGuid,\r\n            getChildrenIds: getChildrenIds,\r\n            getBaseId: getBaseId,\r\n            getInheritorIds: getInheritorIds,\r\n            getAttribute: getAttribute,\r\n            getEditableAttribute: getEditableAttribute,\r\n            getRegistry: getRegistry,\r\n            getEditableRegistry: getEditableRegistry,\r\n            getOwnAttribute: getOwnAttribute,\r\n            getOwnEditableAttribute: getOwnEditableAttribute,\r\n            getOwnRegistry: getOwnRegistry,\r\n            getOwnEditableRegistry: getOwnEditableRegistry,\r\n            getPointer: getPointer,\r\n            getPointerNames: getPointerNames,\r\n            getAttributeNames: getAttributeNames,\r\n            getRegistryNames: getRegistryNames,\r\n            getOwnAttributeNames: getOwnAttributeNames,\r\n            getOwnRegistryNames: getOwnRegistryNames,\r\n            getOwnPointer: getOwnPointer,\r\n            getOwnPointerNames: getOwnPointerNames,\r\n\r\n            //SetFunctions\r\n            getMemberIds: getMemberIds,\r\n            getSetNames: getSetNames,\r\n            getMemberAttributeNames: getMemberAttributeNames,\r\n            getMemberAttribute: getMemberAttribute,\r\n            getEditableMemberAttribute: getEditableMemberAttribute,\r\n            getMemberRegistryNames: getMemberRegistryNames,\r\n            getMemberRegistry: getMemberRegistry,\r\n            getEditableMemberRegistry: getEditableMemberRegistry,\r\n\r\n            //META functions\r\n            getValidChildrenTypes: getValidChildrenTypes,\r\n            getAttributeDescriptor: getAttributeDescriptor,\r\n            getEditableAttributeDescriptor: getEditableAttributeDescriptor,\r\n            getPointerDescriptor: getPointerDescriptor,\r\n            getEditablePointerDescriptor: getEditablePointerDescriptor,\r\n            getChildrenMetaDescriptor: getChildrenMetaDescriptor,\r\n            getEditableChildrenMetaDescriptor: getEditableChildrenMetaDescriptor,\r\n\r\n            //constraint functions\r\n            getConstraintNames: getConstraintNames,\r\n            getOwnConstraintNames: getOwnConstraintNames,\r\n            getConstraint: getConstraint,\r\n\r\n            printData: printData,\r\n            toString: toString,\r\n\r\n            getCollectionPaths: getCollectionPaths\r\n\r\n          };\r\n        }\r\n\r\n        return null;\r\n\r\n      }\r\n\r\n      //testing\r\n      function testMethod(testnumber){\r\n        switch(testnumber){\r\n          case 1:\r\n            break;\r\n          case 2:\r\n            break;\r\n          case 3:\r\n            break;\r\n        }\r\n      }\r\n\r\n      //export and import functions\r\n      function exportItems(paths, callback) {\r\n        var nodes = [];\r\n        for (var i = 0; i < paths.length; i++) {\r\n          if (_nodes[paths[i]]) {\r\n            nodes.push(_nodes[paths[i]].node);\r\n          } else {\r\n            callback('invalid node');\r\n            return;\r\n          }\r\n        }\r\n\r\n        //DumpMore(_core,nodes,\"\",'guid',callback);\r\n        _database.simpleRequest({command: 'dumpMoreNodes', name: _projectName, hash: _rootHash || _core.getHash(_nodes[ROOT_PATH].node), nodes: paths}, function (err, resId) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            _database.simpleResult(resId, callback);\r\n          }\r\n        });\r\n      }\r\n\r\n      function getExportItemsUrlAsync(paths, filename, callback) {\r\n        _database.simpleRequest({command: 'dumpMoreNodes', name: _projectName, hash: _rootHash || _core.getHash(_nodes[ROOT_PATH].node), nodes: paths}, function (err, resId) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            callback(null, window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' + resId + '/' + filename);\r\n          }\r\n        });\r\n      }\r\n\r\n      function getExternalInterpreterConfigUrlAsync(selectedItemsPaths, filename, callback) {\r\n        var config = {};\r\n        config.host = window.location.protocol + \"//\" + window.location.host;\r\n        config.project = _projectName;\r\n        config.token = _TOKEN.getToken();\r\n        config.selected = plainUrl({command: 'node', path: selectedItemsPaths[0] || \"\"});\r\n        config.commit = URL.addSpecialChars(_recentCommits[0] || \"\");\r\n        config.root = plainUrl({command: 'node'});\r\n        config.branch = _branch\r\n        _database.simpleRequest({command: 'generateJsonURL', object: config}, function (err, resId) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            callback(null, window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' + resId + '/' + filename);\r\n          }\r\n        });\r\n      }\r\n\r\n      function getExportLibraryUrlAsync(libraryRootPath, filename, callback) {\r\n        var command = {};\r\n        command.command = 'exportLibrary';\r\n        command.name = _projectName;\r\n        command.hash = _rootHash || _core.getHash(_nodes[ROOT_PATH].node);\r\n        command.path = libraryRootPath;\r\n        if (command.name && command.hash) {\r\n          _database.simpleRequest(command, function (err, resId) {\r\n            if (err) {\r\n              callback(err);\r\n            } else {\r\n              callback(null, window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' + resId + '/' + filename);\r\n            }\r\n          });\r\n        } else {\r\n          callback(new Error('there is no open project!'));\r\n        }\r\n      }\r\n\r\n      function updateLibraryAsync(libraryRootPath, newLibrary, callback) {\r\n        Serialization.import(_core, _nodes[libraryRootPath].node, newLibrary, function (err, log) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n\r\n          saveRoot(\"library update done\\nlogs:\\n\" + log, callback);\r\n        });\r\n      }\r\n\r\n      function addLibraryAsync(libraryParentPath, newLibrary, callback) {\r\n        startTransaction(\"creating library as a child of \" + libraryParentPath);\r\n        var libraryRoot = createChild({parentId: libraryParentPath, baseId: null}, \"library placeholder\");\r\n        Serialization.import(_core, _nodes[libraryRoot].node, newLibrary, function (err, log) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n\r\n          completeTransaction(\"library update done\\nlogs:\\n\" + log, callback);\r\n        });\r\n      }\r\n\r\n      function dumpNodeAsync(path, callback) {\r\n        if (_nodes[path]) {\r\n          Dump(_core, _nodes[path].node, \"\", 'guid', callback);\r\n        } else {\r\n          callback('unknown object', null);\r\n        }\r\n      }\r\n\r\n      function importNodeAsync(parentPath, jNode, callback) {\r\n        var node = null;\r\n        if (_nodes[parentPath]) {\r\n          node = _nodes[parentPath].node;\r\n        }\r\n        Import(_core, _nodes[parentPath].node, jNode, function (err) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            saveRoot('importNode under ' + parentPath, callback);\r\n          }\r\n        });\r\n      }\r\n\r\n      function mergeNodeAsync(parentPath, jNode, callback) {\r\n        var node = null;\r\n        if (_nodes[parentPath]) {\r\n          node = _nodes[parentPath].node;\r\n        }\r\n        MergeImport(_core, _nodes[parentPath].node, jNode, function (err) {\r\n          if (err) {\r\n            callback(err);\r\n          } else {\r\n            saveRoot('importNode under ' + parentPath, callback);\r\n          }\r\n        });\r\n      }\r\n\r\n      function createProjectFromFileAsync(projectname, jProject, callback) {\r\n        //if called on an existing project, it will ruin it!!! - although the old commits will be untouched\r\n        //TODO somehow the export / import should contain the INFO field so the tags and description could come from it\r\n        createProjectAsync(projectname, {}, function (err) {\r\n          selectProjectAsync(projectname, function (err) {\r\n            Serialization.import(_core, _root, jProject, function (err) {\r\n              if (err) {\r\n                return callback(err);\r\n              }\r\n\r\n              saveRoot(\"library have been updated...\", callback);\r\n            });\r\n          });\r\n        });\r\n      }\r\n\r\n      function plainUrl(parameters) {\r\n        //setting the default values\r\n        parameters.command = parameters.command || 'etf';\r\n        parameters.path = parameters.path || \"\";\r\n        parameters.project = parameters.project || _projectName;\r\n\r\n        if (!parameters.root && !parameters.branch && !parameters.commit) {\r\n          if (_rootHash) {\r\n            parameters.root = _rootHash;\r\n          } else if (_nodes && _nodes[ROOT_PATH]) {\r\n            parameters.root = _core.getHash(_nodes[ROOT_PATH].node);\r\n          } else {\r\n            parameters.branch = _branch || 'master';\r\n          }\r\n        }\r\n\r\n        //now we compose the URL\r\n        if (window && window.location) {\r\n          var address = window.location.protocol + '//' + window.location.host + '/rest/' + parameters.command + '?';\r\n          address += \"&project=\" + URL.addSpecialChars(parameters.project);\r\n          if (parameters.root) {\r\n            address += \"&root=\" + URL.addSpecialChars(parameters.root);\r\n          } else {\r\n            if (parameters.commit) {\r\n              address += \"&commit=\" + URL.addSpecialChars(parameters.commit);\r\n            } else {\r\n              address += \"&branch=\" + URL.addSpecialChars(parameters.branch);\r\n            }\r\n          }\r\n\r\n          address += \"&path=\" + URL.addSpecialChars(parameters.path);\r\n\r\n          if (parameters.output) {\r\n            address += \"&output=\" + URL.addSpecialChars(parameters.output);\r\n          }\r\n\r\n          return address;\r\n        }\r\n\r\n        return null;\r\n\r\n      }\r\n\r\n      function getDumpURL(parameters) {\r\n        parameters.output = parameters.output || \"dump_url.out\";\r\n        return plainUrl(parameters);\r\n      }\r\n\r\n      function getProjectObject() {\r\n        return _project;\r\n      }\r\n\r\n      function getAvailableInterpreterNames() {\r\n        var names = [];\r\n        var valids = _nodes[ROOT_PATH] ? _core.getRegistry(_nodes[ROOT_PATH].node, 'validPlugins') || \"\" : \"\";\r\n        valids = valids.split(\" \");\r\n        for (var i = 0; i < valids.length; i++) {\r\n          if (AllPlugins.indexOf(valids[i]) !== -1) {\r\n            names.push(valids[i]);\r\n          }\r\n        }\r\n        return names;\r\n      }\r\n\r\n      function runServerPlugin(name, context, callback) {\r\n        _database.simpleRequest({command: 'executePlugin', name: name, context: context}, callback);\r\n      }\r\n\r\n      function getAvailableDecoratorNames() {\r\n        return AllDecorators;\r\n      }\r\n\r\n      function getFullProjectsInfoAsync(callback) {\r\n        _database.simpleRequest({command: 'getAllProjectsInfo'}, function (err, id) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(id, callback);\r\n        });\r\n      }\r\n\r\n      function setProjectInfoAsync(projectId,info,callback){\r\n        _database.simpleRequest({command:'setProjectInfo',projectId:projectId,info:info},function(err,rId){\r\n          if(err){\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(rId,callback);\r\n        })\r\n      }\r\n\r\n      function getProjectInfoAsync(projectId,callback){\r\n        _database.simpleRequest({command:'getProjectInfo',projectId:projectId},function(err,rId){\r\n          if(err){\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(rId,callback);\r\n        })\r\n      }\r\n\r\n      function getAllInfoTagsAsync(callback){\r\n        _database.simpleRequest({command:'getAllInfoTags'},function(err,rId){\r\n          if(err){\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(rId,callback);\r\n        })\r\n      }\r\n\r\n      function createGenericBranchAsync(project, branch, commit, callback) {\r\n        _database.simpleRequest({command: 'setBranch', project: project, branch: branch, old: '', new: commit}, function (err, id) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(id, callback);\r\n        });\r\n      }\r\n\r\n      function deleteGenericBranchAsync(project, branch, commit, callback) {\r\n        _database.simpleRequest({command: 'setBranch', project: project, branch: branch, old: commit, new: ''}, function (err, id) {\r\n          if (err) {\r\n            return callback(err);\r\n          }\r\n          _database.simpleResult(id, callback);\r\n        });\r\n      }\r\n\r\n      //TODO probably it would be a good idea to put this functionality to server\r\n      function getBaseOfCommits(one,other,callback){\r\n        _project.getCommonAncestorCommit(one,other,callback);\r\n      }\r\n      //TODO probably this would also beneficial if this would work on server as well\r\n      function getDiffTree(from,to,callback){\r\n        var needed = 2,error = null,\r\n          core = getNewCore(_project),\r\n          fromRoot={root:{},commit:from},\r\n          toRoot={root:{},commit:to},\r\n          rootsLoaded = function(){\r\n            if(error){\r\n              return callback(error,{});\r\n            }\r\n            _core.generateTreeDiff(fromRoot.root,toRoot.root,callback);\r\n          },\r\n          loadRoot = function(root){\r\n            _project.loadObject(root.commit,function(err,c){\r\n              error = error || ( err || c ? null : new Error('no commit object was found'));\r\n              if(!err && c){\r\n                core.loadRoot(c.root,function(err,r){\r\n                  error = error || ( err || r ? null : new Error('no root was found'));\r\n                  root.root = r;\r\n                  if(--needed === 0){\r\n                    rootsLoaded();\r\n                  }\r\n                });\r\n              } else {\r\n                if(--needed === 0){\r\n                  rootsLoaded();\r\n                }\r\n              }\r\n            });\r\n          };\r\n        loadRoot(fromRoot);\r\n        loadRoot(toRoot);\r\n\r\n      }\r\n\r\n      function getConflictOfDiffs(base,extension){\r\n        return _core.tryToConcatChanges(base,extension);\r\n      }\r\n      function getResolve(resolveObject){\r\n        return _core.applyResolution(resolveObject);\r\n      }\r\n      //TODO move to server\r\n      function applyDiff(branch,baseCommitHash,branchCommitHash,parents,diff,callback){\r\n        _project.loadObject(baseCommitHash,function(err,cObject){\r\n          var core = getNewCore(_project);\r\n          if(!err && cObject){\r\n            core.loadRoot(cObject.root,function(err,root){\r\n              if(!err && root){\r\n                core.applyTreeDiff(root,diff,function(err){\r\n                  if(err){\r\n                    return callback(err);\r\n                  }\r\n\r\n                  core.persist(root,function(err){\r\n                    if(err){\r\n                      return callback(err);\r\n                    }\r\n\r\n                    var newHash = _project.makeCommit(parents,core.getHash(root),\"merging\",function(err){\r\n                      if(err){\r\n                        return callback(err);\r\n                      }\r\n                      _project.setBranchHash(branch,branchCommitHash,newHash,callback);\r\n                    });\r\n                  });\r\n                });\r\n              } else {\r\n                callback(err || new Error('no root was found'));\r\n              }\r\n            });\r\n          } else {\r\n            callback(err || new Error('no commit object was found'));\r\n          }\r\n        });\r\n      }\r\n\r\n      function merge(whereBranch,whatCommit,whereCommit,callback){\r\n        ASSERT(_project && typeof whatCommit === 'string' && typeof whereCommit === 'string' && typeof callback === 'function');\r\n        _project.getCommonAncestorCommit(whatCommit,whereCommit,function(err,baseCommit){\r\n          if(!err && baseCommit){\r\n            var base,what,where,baseToWhat,baseToWhere,rootNeeds = 3,error = null,\r\n            rootsLoaded = function(){\r\n                var needed = 2,error = null;\r\n                _core.generateTreeDiff(base,what,function(err,diff){\r\n                  error = error || err;\r\n                  baseToWhat = diff;\r\n                  if(--needed===0){\r\n                    if(!error){\r\n                      diffsGenerated();\r\n                    } else {\r\n                      callback(error);\r\n                    }\r\n                  }\r\n                });\r\n                _core.generateTreeDiff(base,where,function(err,diff){\r\n                  error = error || err;\r\n                  baseToWhere = diff;\r\n                  if(--needed===0){\r\n                    if(!error){\r\n                      diffsGenerated();\r\n                    } else {\r\n                      callback(error);\r\n                    }\r\n                  }\r\n                });\r\n              },\r\n              diffsGenerated = function(){\r\n                var conflict = _core.tryToConcatChanges(baseToWhere,baseToWhat);\r\n                console.log('conflict object',conflict);\r\n                if(conflict.items.length === 0){\r\n                  //no conflict\r\n                  callback(null,conflict);\r\n                  /*\r\n                  _core.applyTreeDiff(base,conflict.merge,function(err){\r\n                    if(err){\r\n                      return callback(err);\r\n                    }\r\n                    _core.persist(base,function(err){\r\n                      if(err){\r\n                        callback(err);\r\n                      } else {\r\n                        var newHash = _project.makeCommit([whatCommit,whereCommit],_core.getHash(base), \"merging\", function(err){\r\n                          if(err){\r\n                            callback(err);\r\n                          } else {\r\n                            _project.setBranchHash(whereBranch,whereCommit,newHash,callback);\r\n                          }\r\n                        });\r\n                      }\r\n                    });\r\n                  });*/\r\n                } else {\r\n                  callback(null,conflict);\r\n                }\r\n                /*var endingWhatDiff = _core.concatTreeDiff(baseToWhere,baseToWhat),\r\n                  endingWhereDiff = _core.concatTreeDiff(baseToWhat,baseToWhere);\r\n                console.log('kecso endingwhatdiff',endingWhatDiff);\r\n                console.log('kecso endingwherediff',endingWhereDiff);\r\n                if(_core.isEqualDifferences(endingWhereDiff,endingWhatDiff)){\r\n                  _core.applyTreeDiff(base,endingWhatDiff,function(err){\r\n                    if(err){\r\n                      callback(err);\r\n                    } else {\r\n                      _core.persist(base,function(err){\r\n                        if(err){\r\n                          callback(err);\r\n                        } else {\r\n                          var newHash = _project.makeCommit([whatCommit,whereCommit],_core.getHash(base), \"merging\", function(err){\r\n                            if(err){\r\n                              callback(err);\r\n                            } else {\r\n                              console.log('setting branch hash after merge');\r\n                              _project.setBranchHash(whereBranch,whereCommit,newHash,callback);\r\n                            }\r\n                          });\r\n                        }\r\n                      });\r\n                    }\r\n\r\n                  });\r\n                } else {\r\n                  callback(new Error('there is a conflict...'),{\r\n                    baseObject:base,\r\n                    baseCommit:baseCommit,\r\n                    branch: whereBranch,\r\n                    mine:endingWhereDiff,\r\n                    mineCommit: whereCommit,\r\n                    theirs:endingWhatDiff,\r\n                    theirsCommit:whatCommit,\r\n                    conflictItems:_core.getConflictItems(endingWhereDiff,endingWhatDiff)});\r\n                }*/\r\n              };\r\n\r\n              _project.loadObject(baseCommit,function(err,baseCommitObject){\r\n                error = error || err;\r\n                if(!error && baseCommitObject){\r\n                  _core.loadRoot(baseCommitObject.root,function(err,r){\r\n                    error = error || err;\r\n                    base = r;\r\n                    if(--rootNeeds === 0){\r\n                      if(!error){\r\n                        rootsLoaded();\r\n                      } else {\r\n                        callback(error);\r\n                      }\r\n                    }\r\n                  });\r\n                } else {\r\n                  error = error || new Error('cannot load common ancestor commit');\r\n                  if(--rootNeeds === 0){\r\n                    callback(error);\r\n                  }\r\n                }\r\n              });\r\n              _project.loadObject(whatCommit,function(err,whatCommitObject){\r\n                error = error || err;\r\n                if(!error && whatCommitObject){\r\n                  _core.loadRoot(whatCommitObject.root,function(err,r){\r\n                    error = error || err;\r\n                    what = r;\r\n                    if(--rootNeeds === 0){\r\n                      if(!error){\r\n                        rootsLoaded();\r\n                      } else {\r\n                        callback(error);\r\n                      }\r\n                    }\r\n                  });\r\n                } else {\r\n                  error = error || new Error('cannot load the commit to merge');\r\n                  if(--rootNeeds === 0){\r\n                    callback(error);\r\n                  }\r\n                }\r\n              });\r\n              _project.loadObject(whereCommit,function(err,whereCommitObject){\r\n                error = error || err;\r\n                if(!error && whereCommitObject){\r\n                  _core.loadRoot(whereCommitObject.root,function(err,r){\r\n                    error = error || err;\r\n                    where = r;\r\n                    if(--rootNeeds === 0){\r\n                      if(!error){\r\n                        rootsLoaded();\r\n                      } else {\r\n                        callback(error);\r\n                      }\r\n                    }\r\n                  });\r\n                } else {\r\n                  error = error || new Error('cannot load the commit to merge into');\r\n                  if(--rootNeeds === 0){\r\n                    callback(error);\r\n                  }\r\n                }\r\n              });\r\n          } else {\r\n            callback(err || new Error('we cannot locate common ancestor commit!!!'));\r\n          }\r\n        });\r\n      }\r\n\r\n      function resolve(baseObject,mineDiff,branch,mineCommit,theirsCommit,resolvedConflictItems,callback){\r\n        mineDiff = _core.applyResolution(mineDiff,resolvedConflictItems);\r\n        _core.applyTreeDiff(baseObject,mineDiff,function(err){\r\n          if(err){\r\n            callback(err);\r\n          } else {\r\n            _core.persist(baseObject,function(err){\r\n              if(err){\r\n                callback(err);\r\n              } else {\r\n                var newHash = _project.makeCommit([theirsCommit,mineCommit],_core.getHash(baseObject), \"merging\", function(err){\r\n                  if(err){\r\n                    callback(err);\r\n                  } else {\r\n                    console.log('setting branch hash after merge');\r\n                    _project.setBranchHash(branch,mineCommit,newHash,callback);\r\n                  }\r\n                });\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n      //initialization\r\n      function initialize() {\r\n        _database = newDatabase();\r\n        _database.openDatabase(function (err) {\r\n          if (!err) {\r\n            _networkWatcher = networkWatcher();\r\n            serverEventer();\r\n            _database.getProjectNames(function (err, names) {\r\n              if (!err && names && names.length > 0) {\r\n                var projectName = null;\r\n                if (_configuration.project && names.indexOf(_configuration.project) !== -1) {\r\n                  projectName = _configuration.project;\r\n                } else {\r\n                  projectName = names[0];\r\n                }\r\n                openProject(projectName, function (err) {\r\n                  if (err) {\r\n                    logger.error('Problem during project opening:' + JSON.stringify(err));\r\n                  }\r\n                });\r\n              } else {\r\n                logger.error('Cannot get project names / There is no project on the server');\r\n              }\r\n            });\r\n          } else {\r\n            logger.error('Cannot open database');\r\n          }\r\n        });\r\n      }\r\n\r\n      if (_configuration.autostart) {\r\n        initialize();\r\n      }\r\n      _redoer = new UndoRedo({\r\n        //eventer\r\n        events: _self.events,\r\n        networkStates: _self.networkStates,\r\n        branchStates: _self.branchStates,\r\n        _eventList: _self._eventList,\r\n        _getEvent: _self._getEvent,\r\n        addEventListener: _self.addEventListener,\r\n        removeEventListener: _self.removeEventListener,\r\n        removeAllEventListeners: _self.removeAllEventListeners,\r\n        dispatchEvent: _self.dispatchEvent,\r\n        getProjectObject: getProjectObject});\r\n\r\n      return {\r\n        //eventer\r\n        events: _self.events,\r\n        networkStates: _self.networkStates,\r\n        branchStates: _self.branchStates,\r\n        _eventList: _self._eventList,\r\n        _getEvent: _self._getEvent,\r\n        addEventListener: _self.addEventListener,\r\n        removeEventListener: _self.removeEventListener,\r\n        removeAllEventListeners: _self.removeAllEventListeners,\r\n        dispatchEvent: _self.dispatchEvent,\r\n        connect: connect,\r\n\r\n        getUserId: getUserId,\r\n\r\n        //projects, branch, etc.\r\n        getActiveProjectName: getActiveProject,\r\n        getAvailableProjectsAsync: getAvailableProjectsAsync,\r\n        getViewableProjectsAsync: getViewableProjectsAsync,\r\n        getFullProjectListAsync: getFullProjectListAsync,\r\n        getProjectAuthInfoAsync: getProjectAuthInfoAsync,\r\n        connectToDatabaseAsync: connectToDatabaseAsync,\r\n        selectProjectAsync: selectProjectAsync,\r\n        createProjectAsync: createProjectAsync,\r\n        deleteProjectAsync: deleteProjectAsync,\r\n        getBranchesAsync: getBranchesAsync,\r\n        selectCommitAsync: selectCommitAsync,\r\n        getCommitsAsync: getCommitsAsync,\r\n        getActualCommit: getActualCommit,\r\n        getActualBranch: getActualBranch,\r\n        getActualNetworkStatus: getActualNetworkStatus,\r\n        getActualBranchStatus: getActualBranchStatus,\r\n        createBranchAsync: createBranchAsync,\r\n        deleteBranchAsync: deleteBranchAsync,\r\n        selectBranchAsync: selectBranchAsync,\r\n        commitAsync: commitAsync,\r\n        goOffline: goOffline,\r\n        goOnline: goOnline,\r\n        isProjectReadOnly: function () {\r\n          return _readOnlyProject;\r\n        },\r\n        isCommitReadOnly: function () {\r\n          return _viewer;\r\n        },\r\n\r\n        //MGA\r\n        startTransaction: startTransaction,\r\n        completeTransaction: completeTransaction,\r\n        setAttributes: setAttributes,\r\n        delAttributes: delAttributes,\r\n        setRegistry: setRegistry,\r\n        delRegistry: delRegistry,\r\n        copyMoreNodes: copyMoreNodes,\r\n        moveMoreNodes: moveMoreNodes,\r\n        delMoreNodes: delMoreNodes,\r\n        createChild: createChild,\r\n        createChildren: createChildren,\r\n        makePointer: makePointer,\r\n        delPointer: delPointer,\r\n        addMember: addMember,\r\n        removeMember: removeMember,\r\n        setMemberAttribute: setMemberAttribute,\r\n        delMemberAttribute: delMemberAttribute,\r\n        setMemberRegistry: setMemberRegistry,\r\n        delMemberRegistry: delMemberRegistry,\r\n        createSet: createSet,\r\n        deleteSet: deleteSet,\r\n\r\n        //desc and META\r\n        setAttributeDescriptor: setAttributeDescriptor,\r\n        delAttributeDescriptor: delAttributeDescriptor,\r\n        setPointerDescriptor: setPointerDescriptor,\r\n        delPointerDescriptor: delPointerDescriptor,\r\n        setChildrenMetaDescriptor: setChildrenMetaDescriptor,\r\n        delChildrenMetaDescriptor: delChildrenMetaDescriptor,\r\n        setBase: setBase,\r\n        delBase: delBase,\r\n\r\n        //we simply propagate the functions of META\r\n        getMeta: META.getMeta,\r\n        setMeta: META.setMeta,\r\n        getChildrenMeta: META.getChildrenMeta,\r\n        setChildrenMeta: META.setChildrenMeta,\r\n        getChildrenMetaAttribute: META.getChildrenMetaAttribute,\r\n        setChildrenMetaAttribute: META.setChildrenMetaAttribute,\r\n        getValidChildrenItems: META.getValidChildrenItems,\r\n        updateValidChildrenItem: META.updateValidChildrenItem,\r\n        removeValidChildrenItem: META.removeValidChildrenItem,\r\n        getAttributeSchema: META.getAttributeSchema,\r\n        setAttributeSchema: META.setAttributeSchema,\r\n        removeAttributeSchema: META.removeAttributeSchema,\r\n        getPointerMeta: META.getPointerMeta,\r\n        setPointerMeta: META.setPointerMeta,\r\n        getValidTargetItems: META.getValidTargetItems,\r\n        updateValidTargetItem: META.updateValidTargetItem,\r\n        removeValidTargetItem: META.removeValidTargetItem,\r\n        deleteMetaPointer: META.deleteMetaPointer,\r\n        getOwnValidChildrenTypes: META.getOwnValidChildrenTypes,\r\n        getOwnValidTargetTypes: META.getOwnValidTargetTypes,\r\n        isValidChild: META.isValidChild,\r\n        isValidTarget: META.isValidTarget,\r\n        isValidAttribute: META.isValidAttribute,\r\n        getValidChildrenTypes: META.getValidChildrenTypes,\r\n        getValidTargetTypes: META.getValidTargetTypes,\r\n        hasOwnMetaRules: META.hasOwnMetaRules,\r\n        filterValidTarget: META.filterValidTarget,\r\n        isTypeOf: META.isTypeOf,\r\n        getValidAttributeNames: META.getValidAttributeNames,\r\n        getOwnValidAttributeNames: META.getOwnValidAttributeNames,\r\n        getMetaAspectNames: META.getMetaAspectNames,\r\n        getOwnMetaAspectNames: META.getOwnMetaAspectNames,\r\n        getMetaAspect: META.getMetaAspect,\r\n        setMetaAspect: META.setMetaAspect,\r\n        deleteMetaAspect: META.deleteMetaAspect,\r\n        getAspectTerritoryPattern: META.getAspectTerritoryPattern,\r\n\r\n        //end of META functions\r\n\r\n        //decorators\r\n        getAvailableDecoratorNames: getAvailableDecoratorNames,\r\n        //interpreters\r\n        getAvailableInterpreterNames: getAvailableInterpreterNames,\r\n        getProjectObject: getProjectObject,\r\n        runServerPlugin: runServerPlugin,\r\n\r\n        //JSON functions\r\n        exportItems: exportItems,\r\n        getExportItemsUrlAsync: getExportItemsUrlAsync,\r\n        getExternalInterpreterConfigUrlAsync: getExternalInterpreterConfigUrlAsync,\r\n        dumpNodeAsync: dumpNodeAsync,\r\n        importNodeAsync: importNodeAsync,\r\n        mergeNodeAsync: mergeNodeAsync,\r\n        createProjectFromFileAsync: createProjectFromFileAsync,\r\n        getDumpURL: getDumpURL,\r\n        getExportLibraryUrlAsync: getExportLibraryUrlAsync,\r\n        updateLibraryAsync: updateLibraryAsync,\r\n        addLibraryAsync: addLibraryAsync,\r\n        getFullProjectsInfoAsync: getFullProjectsInfoAsync,\r\n        createGenericBranchAsync: createGenericBranchAsync,\r\n        deleteGenericBranchAsync: deleteGenericBranchAsync,\r\n        setProjectInfoAsync: setProjectInfoAsync,\r\n        getProjectInfoAsync: getProjectInfoAsync,\r\n        getAllInfoTagsAsync: getAllInfoTagsAsync,\r\n\r\n        //constraint\r\n        setConstraint: setConstraint,\r\n        delConstraint: delConstraint,\r\n\r\n        //coreAddOn functions\r\n        validateProjectAsync: validateProjectAsync,\r\n        validateModelAsync: validateModelAsync,\r\n        validateNodeAsync: validateNodeAsync,\r\n        setValidationCallback: setValidationCallback,\r\n        getDetailedHistoryAsync: getDetailedHistoryAsync,\r\n        getRunningAddOnNames: getRunningAddOnNames,\r\n\r\n        //territory functions for the UI\r\n        addUI: addUI,\r\n        removeUI: removeUI,\r\n        updateTerritory: updateTerritory,\r\n        getNode: getNode,\r\n\r\n        //undo - redo\r\n        undo: _redoer.undo,\r\n        redo: _redoer.redo,\r\n\r\n        //merge\r\n        getBaseOfCommits: getBaseOfCommits,\r\n        getDiffTree: getDiffTree,\r\n        getConflictOfDiffs: getConflictOfDiffs,\r\n        applyDiff: applyDiff,\r\n        merge: merge,\r\n        getResolve: getResolve,\r\n        resolve: resolve,\r\n\r\n        //testing\r\n        testMethod: testMethod\r\n\r\n      };\r\n    }\r\n\r\n    return Client;\r\n  });\n",
    "define('blob/BlobConfig',[], function(){\r\n\r\n    var BlobConfig = {\r\n        hashMethod: 'sha1', // TODO: in the future we may switch to sha512\r\n        hashRegex: new RegExp('^[0-9a-f]{40}$')\r\n    };\r\n    return BlobConfig;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\ndefine('blob/BlobMetadata',['blob/BlobConfig'], function(BlobConfig){\r\n\r\n    /**\r\n     * Initializes a new instance of BlobMetadata\r\n     * @param {Object<string, string|number|Object>} metadata A serialized metadata object. Name and content must be defined.\r\n     * @constructor\r\n     */\r\n    var BlobMetadata = function(metadata) {\r\n        var key;\r\n        if (metadata) {\r\n            this.name = metadata.name;\r\n            this.size = metadata.size || 0;\r\n            this.mime = metadata.mime || '';\r\n            this.isPublic = metadata.isPublic || false;\r\n            this.tags = metadata.tags || [];\r\n            this.content = metadata.content;\r\n            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;\r\n            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\r\n                for (key in this.content) {\r\n                    if (this.content.hasOwnProperty(key)) {\r\n                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {\r\n                            throw Error(\"BlobMetadata is malformed: hash is invalid\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new Error('metadata parameter is not defined');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Type of the metadata\r\n     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}\r\n     */\r\n    BlobMetadata.CONTENT_TYPES = {\r\n        OBJECT: 'object',\r\n        COMPLEX: 'complex',\r\n        SOFT_LINK: 'softLink'\r\n    };\r\n\r\n    /**\r\n     * Serializes the metadata to a JSON object.\r\n     * @returns {{name: string, size: number, mime: string, tags: Array.<string>, content: (string|Object}, contentType: string}}\r\n     */\r\n    BlobMetadata.prototype.serialize = function () {\r\n        var metadata = {\r\n            name: this.name,\r\n            size: this.size,\r\n            mime: this.mime,\r\n            isPublic: this.isPublic,\r\n            tags: this.tags,\r\n            content: this.content,\r\n            contentType: this.contentType\r\n        };\r\n\r\n        metadata.tags.sort();\r\n\r\n        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\r\n            // override on  purpose to normalize content\r\n            metadata.content = {};\r\n            var fnames = Object.keys(this.content);\r\n            fnames.sort();\r\n\r\n            for (var j = 0; j < fnames.length; j += 1) {\r\n                metadata.content[fnames[j]] = this.content[fnames[j]];\r\n            }\r\n        }\r\n\r\n        return metadata;\r\n    };\r\n\r\n    return BlobMetadata\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\ndefine('blob/Artifact',['blob/BlobMetadata', 'blob/BlobConfig', 'core/tasync'], function (BlobMetadata, BlobConfig, tasync) {\r\n\r\n    /**\r\n     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the storage.\r\n     * @param {string} name Artifact's name without extension\r\n     * @param {blob.BlobClient} blobClient\r\n     * @param {blob.BlobMetadata} descriptor\r\n     * @constructor\r\n     */\r\n    var Artifact = function (name, blobClient, descriptor) {\r\n        this.name = name;\r\n        this.blobClient = blobClient;\r\n        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));\r\n        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));\r\n        // TODO: use BlobMetadata class here\r\n        this.descriptor = descriptor || {\r\n            name: name + '.zip',\r\n            size: 0,\r\n            mime: 'application/zip',\r\n            content: {},\r\n            contentType: 'complex'\r\n        }; // name and hash pairs\r\n    };\r\n\r\n    /**\r\n     * Adds content to the artifact as a file.\r\n     * @param {string} name filename\r\n     * @param {Blob} content File object or Blob\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addFile = function (name, content, callback) {\r\n        var self = this;\r\n        var filename = name.substring(name.lastIndexOf('/') + 1);\r\n\r\n        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, hash) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            self.addObjectHash(name, hash, function (err, hash) {\r\n                callback(err, hash);\r\n            });\r\n        });\r\n    };\r\n\r\n    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {\r\n        var self = this;\r\n        var filename = name.substring(name.lastIndexOf('/') + 1);\r\n\r\n        self.blobClientPutFile.call(self.blobClient, filename, content,\r\n            function (err, hash) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n\r\n                self.addMetadataHash(name, hash, function (err, hash) {\r\n                    callback(err, hash);\r\n                });\r\n            });\r\n    };\r\n\r\n    /**\r\n     * Adds multiple files.\r\n     * @param {Object.<string, Blob>} files files to add\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addFiles = function (files, callback) {\r\n        var self = this,\r\n            fileNames = Object.keys(files),\r\n            nbrOfFiles = fileNames.length,\r\n            hashes = [],\r\n            error = '',\r\n            i,\r\n            counterCallback = function (err, hash) {\r\n                error = err ? error + err : error;\r\n                nbrOfFiles -= 1;\r\n                hashes.push(hash);\r\n                if (nbrOfFiles === 0) {\r\n                    if (error) {\r\n                        return callback('Failed adding files: ' + error, hashes);\r\n                    }\r\n                    callback(null, hashes);\r\n                }\r\n            };\r\n\r\n        if (nbrOfFiles === 0) {\r\n            callback(null, hashes);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < fileNames.length; i += 1) {\r\n            self.addFile(fileNames[i], files[fileNames[i]], counterCallback);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Adds multiple files as soft-links.\r\n     * @param {Object.<string, Blob>} files files to add\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {\r\n        var self = this,\r\n            fileNames = Object.keys(files),\r\n            nbrOfFiles = fileNames.length,\r\n            hashes = [],\r\n            error = '',\r\n            i,\r\n            counterCallback = function (err, hash) {\r\n                error = err ? error + err : error;\r\n                nbrOfFiles -= 1;\r\n                hashes.push(hash);\r\n                if (nbrOfFiles === 0) {\r\n                    if (error) {\r\n                        return callback('Failed adding files as soft-links: ' + error, hashes);\r\n                    }\r\n                    callback(null, hashes);\r\n                }\r\n            };\r\n\r\n        if (nbrOfFiles === 0) {\r\n            callback(null, hashes);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < fileNames.length; i += 1) {\r\n            self.addFileAsSoftLink(fileNames[i], files[fileNames[i]], counterCallback);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds a hash to the artifact using the given file path.\r\n     * @param {string} name Path to the file in the artifact. Note: 'a/b/c.txt'\r\n     * @param {string} hash Metadata hash that has to be added.\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addObjectHash = function (name, hash, callback) {\r\n        var self = this;\r\n\r\n        self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            if (self.descriptor.content.hasOwnProperty(name)) {\r\n                callback('Another content with the same name was already added. ' + JSON.stringify(self.descriptor.content[name]));\r\n\r\n            } else {\r\n                self.descriptor.size += metadata.size;\r\n\r\n                self.descriptor.content[name] = {\r\n                    content: metadata.content,\r\n                    contentType: BlobMetadata.CONTENT_TYPES.OBJECT\r\n                };\r\n                callback(null, hash);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Adds hashes to the artifact using the given file paths.\r\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addObjectHashes = function (objectHashes, callback) {\r\n        var self = this,\r\n            fileNames = Object.keys(objectHashes),\r\n            nbrOfFiles = fileNames.length,\r\n            hashes = [],\r\n            error = '',\r\n            i,\r\n            counterCallback = function (err, hash) {\r\n                error = err ? error + err : error;\r\n                nbrOfFiles -= 1;\r\n                hashes.push(hash);\r\n                if (nbrOfFiles === 0) {\r\n                    if (error) {\r\n                        return callback('Failed adding objectHashes: ' + error, hashes);\r\n                    }\r\n                    callback(null, hashes);\r\n                }\r\n            };\r\n\r\n        if (nbrOfFiles === 0) {\r\n            callback(null, hashes);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < fileNames.length; i += 1) {\r\n            self.addObjectHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\r\n        }\r\n    };\r\n\r\n    Artifact.prototype.addMetadataHash = function (name, hash, callback) {\r\n        var self = this;\r\n\r\n        if (BlobConfig.hashRegex.test(hash) === false) {\r\n            callback(\"Blob hash is invalid\");\r\n            return;\r\n        }\r\n        self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            if (self.descriptor.content.hasOwnProperty(name)) {\r\n                callback('Another content with the same name was already added. ' + JSON.stringify(self.descriptor.content[name]));\r\n\r\n            } else {\r\n                self.descriptor.size += metadata.size;\r\n\r\n                self.descriptor.content[name] = {\r\n                    content: hash,\r\n                    contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK\r\n                };\r\n                callback(null, hash);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Adds hashes to the artifact using the given file paths.\r\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.addMetadataHashes = function (objectHashes, callback) {\r\n        var self = this,\r\n            fileNames = Object.keys(objectHashes),\r\n            nbrOfFiles = fileNames.length,\r\n            hashes = [],\r\n            error = '',\r\n            i,\r\n            counterCallback = function (err, hash) {\r\n                error = err ? error + err : error;\r\n                nbrOfFiles -= 1;\r\n                hashes.push(hash);\r\n                if (nbrOfFiles === 0) {\r\n                    if (error) {\r\n                        return callback('Failed adding objectHashes: ' + error, hashes);\r\n                    }\r\n                    callback(null, hashes);\r\n                }\r\n            };\r\n\r\n        if (nbrOfFiles === 0) {\r\n            callback(null, hashes);\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < fileNames.length; i += 1) {\r\n            self.addMetadataHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Saves this artifact and uploads the metadata to the server's storage.\r\n     * @param callback\r\n     */\r\n    Artifact.prototype.save = function (callback) {\r\n        this.blobClient.putMetadata(this.descriptor, callback);\r\n    };\r\n\r\n    return Artifact;\r\n});\r\n\n",
    ";(function(){\n\n/**\n * Require the given path.\n *\n * @param {String} path\n * @return {Object} exports\n * @api public\n */\n\nfunction require(path, parent, orig) {\n  var resolved = require.resolve(path);\n\n  // lookup failed\n  if (null == resolved) {\n    orig = orig || path;\n    parent = parent || 'root';\n    var err = new Error('Failed to require \"' + orig + '\" from \"' + parent + '\"');\n    err.path = orig;\n    err.parent = parent;\n    err.require = true;\n    throw err;\n  }\n\n  var module = require.modules[resolved];\n\n  // perform real require()\n  // by invoking the module's\n  // registered function\n  if (!module._resolving && !module.exports) {\n    var mod = {};\n    mod.exports = {};\n    mod.client = mod.component = true;\n    module._resolving = true;\n    module.call(this, mod.exports, require.relative(resolved), mod);\n    delete module._resolving;\n    module.exports = mod.exports;\n  }\n\n  return module.exports;\n}\n\n/**\n * Registered modules.\n */\n\nrequire.modules = {};\n\n/**\n * Registered aliases.\n */\n\nrequire.aliases = {};\n\n/**\n * Resolve `path`.\n *\n * Lookup:\n *\n *   - PATH/index.js\n *   - PATH.js\n *   - PATH\n *\n * @param {String} path\n * @return {String} path or null\n * @api private\n */\n\nrequire.resolve = function(path) {\n  if (path.charAt(0) === '/') path = path.slice(1);\n\n  var paths = [\n    path,\n    path + '.js',\n    path + '.json',\n    path + '/index.js',\n    path + '/index.json'\n  ];\n\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    if (require.modules.hasOwnProperty(path)) return path;\n    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];\n  }\n};\n\n/**\n * Normalize `path` relative to the current path.\n *\n * @param {String} curr\n * @param {String} path\n * @return {String}\n * @api private\n */\n\nrequire.normalize = function(curr, path) {\n  var segs = [];\n\n  if ('.' != path.charAt(0)) return path;\n\n  curr = curr.split('/');\n  path = path.split('/');\n\n  for (var i = 0; i < path.length; ++i) {\n    if ('..' == path[i]) {\n      curr.pop();\n    } else if ('.' != path[i] && '' != path[i]) {\n      segs.push(path[i]);\n    }\n  }\n\n  return curr.concat(segs).join('/');\n};\n\n/**\n * Register module at `path` with callback `definition`.\n *\n * @param {String} path\n * @param {Function} definition\n * @api private\n */\n\nrequire.register = function(path, definition) {\n  require.modules[path] = definition;\n};\n\n/**\n * Alias a module definition.\n *\n * @param {String} from\n * @param {String} to\n * @api private\n */\n\nrequire.alias = function(from, to) {\n  if (!require.modules.hasOwnProperty(from)) {\n    throw new Error('Failed to alias \"' + from + '\", it does not exist');\n  }\n  require.aliases[to] = from;\n};\n\n/**\n * Return a require function relative to the `parent` path.\n *\n * @param {String} parent\n * @return {Function}\n * @api private\n */\n\nrequire.relative = function(parent) {\n  var p = require.normalize(parent, '..');\n\n  /**\n   * lastIndexOf helper.\n   */\n\n  function lastIndexOf(arr, obj) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === obj) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * The relative require() itself.\n   */\n\n  function localRequire(path) {\n    var resolved = localRequire.resolve(path);\n    return require(resolved, parent, path);\n  }\n\n  /**\n   * Resolve relative to the parent.\n   */\n\n  localRequire.resolve = function(path) {\n    var c = path.charAt(0);\n    if ('/' == c) return path.slice(1);\n    if ('.' == c) return require.normalize(p, path);\n\n    // resolve deps by returning\n    // the dep in the nearest \"deps\"\n    // directory\n    var segs = parent.split('/');\n    var i = lastIndexOf(segs, 'deps') + 1;\n    if (!i) i = 0;\n    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;\n    return path;\n  };\n\n  /**\n   * Check if module is defined at `path`.\n   */\n\n  localRequire.exists = function(path) {\n    return require.modules.hasOwnProperty(localRequire.resolve(path));\n  };\n\n  return localRequire;\n};\nrequire.register(\"component-emitter/index.js\", function(exports, require, module){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n});\nrequire.register(\"component-reduce/index.js\", function(exports, require, module){\n\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n});\nrequire.register(\"superagent/lib/client.js\", function(exports, require, module){\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root = 'undefined' == typeof window\n  ? this\n  : window;\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nfunction getXHR() {\n  if (root.XMLHttpRequest\n    && ('file:' != root.location.protocol || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n}\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  this.text = this.xhr.responseText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status || 1223 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var res = new Response(self);\n    if ('HEAD' == method) res.text = null;\n    self.callback(null, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  if (2 == fn.length) return fn(err, res);\n  if (err) return this.emit('error', err);\n  fn(res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n    if (0 == xhr.status) {\n      if (self.aborted) return self.timeoutError();\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  if (xhr.upload) {\n    xhr.upload.onprogress = function(e){\n      e.percent = e.loaded / e.total * 100;\n      self.emit('progress', e);\n    };\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var serialize = request.serialize[this.getHeader('Content-Type')];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n});\n\n\n\n\nrequire.alias(\"component-emitter/index.js\", \"superagent/deps/emitter/index.js\");\nrequire.alias(\"component-emitter/index.js\", \"emitter/index.js\");\n\nrequire.alias(\"component-reduce/index.js\", \"superagent/deps/reduce/index.js\");\nrequire.alias(\"component-reduce/index.js\", \"reduce/index.js\");\n\nrequire.alias(\"superagent/lib/client.js\", \"superagent/index.js\");if (typeof exports == \"object\") {\n  module.exports = require(\"superagent\");\n} else if (typeof define == \"function\" && define.amd) {\n  define('superagent',[], function(){ return require(\"superagent\"); });\n} else {\n  this[\"superagent\"] = require(\"superagent\");\n}})();\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\ndefine('blob/BlobClient',['./Artifact', 'blob/BlobMetadata', 'superagent'], function (Artifact, BlobMetadata, superagent) {\r\n\r\n    var BlobClient = function (parameters) {\r\n        this.artifacts = [];\r\n\r\n        if (parameters) {\r\n            this.server = parameters.server || this.server;\r\n            this.serverPort = parameters.serverPort || this.serverPort;\r\n            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\r\n        }\r\n        this.blobUrl = '';\r\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\r\n            this.blobUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\r\n        }\r\n\r\n        // TODO: TOKEN???\r\n        this.blobUrl = this.blobUrl + '/rest/blob/'; // TODO: any ways to ask for this or get it from the configuration?\r\n    };\r\n\r\n    BlobClient.prototype.getMetadataURL = function (hash) {\r\n        var metadataBase = this.blobUrl + 'metadata';\r\n        if (hash) {\r\n            return metadataBase + '/' + hash;\r\n        } else {\r\n            return metadataBase;\r\n        }\r\n    };\r\n\r\n    BlobClient.prototype._getURL = function (base, hash, subpath) {\r\n        var subpathURL = '';\r\n        if (subpath) {\r\n            subpathURL = subpath;\r\n        }\r\n        return this.blobUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);\r\n    };\r\n\r\n    BlobClient.prototype.getViewURL = function (hash, subpath) {\r\n        return this._getURL('view', hash, subpath);\r\n    };\r\n\r\n    BlobClient.prototype.getDownloadURL = function (hash, subpath) {\r\n        return this._getURL('download', hash, subpath);\r\n    };\r\n\r\n    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {\r\n        if (isMetadata) {\r\n            return this.blobUrl + 'createMetadata/';\r\n        } else {\r\n            return this.blobUrl + 'createFile/' + encodeURIComponent(filename);\r\n        }\r\n    };\r\n\r\n\r\n    BlobClient.prototype.putFile = function (name, data, callback) {\r\n        function toArrayBuffer(buffer) {\r\n            var ab = new ArrayBuffer(buffer.length);\r\n            var view = new Uint8Array(ab);\r\n            for (var i = 0; i < buffer.length; ++i) {\r\n                view[i] = buffer[i];\r\n            }\r\n            return ab;\r\n        }\r\n        // on node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8. Send an ArrayBuffer instead\r\n        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\r\n            data = toArrayBuffer(data); // FIXME will this have performance problems\r\n        }\r\n        // on node, empty Buffers will cause a crash in superagent\r\n        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\r\n            if (data.length === 0) {\r\n                data = '';\r\n            }\r\n        }\r\n        superagent.post(this.getCreateURL(name))\r\n            .set('Content-Type', 'application/octet-stream')\r\n            .set('Content-Length', data.length)\r\n            .send(data)\r\n            .end(function (err, res) {\r\n                if (err || res.status > 399) {\r\n                    callback(err || res.status);\r\n                    return;\r\n                }\r\n                var response = res.body;\r\n                // Get the first one\r\n                var hash = Object.keys(response)[0];\r\n                callback(null, hash);\r\n            });\r\n    };\r\n\r\n    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {\r\n        var self = this;\r\n        var metadata = new BlobMetadata(metadataDescriptor);\r\n\r\n        // FIXME: in production mode do not indent the json file.\r\n        var blob;\r\n        var contentLength;\r\n        if (typeof Blob !== 'undefined') {\r\n            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});\r\n            contentLength = blob.size;\r\n        } else {\r\n            blob = new Buffer(JSON.stringify(metadata.serialize(), null, 4), 'utf8');\r\n            contentLength = blob.length;\r\n        }\r\n\r\n        superagent.post(this.getCreateURL(metadataDescriptor.name, true))\r\n            .set('Content-Type', 'application/octet-stream')\r\n            .set('Content-Length', contentLength)\r\n            .send(blob)\r\n            .end(function (err, res) {\r\n                if (err || res.status > 399) {\r\n                    callback(err || res.status);\r\n                    return;\r\n                }\r\n                // Uploaded.\r\n                var response = JSON.parse(res.text);\r\n                // Get the first one\r\n                var hash = Object.keys(response)[0];\r\n                callback(null, hash);\r\n            });\r\n    };\r\n\r\n    BlobClient.prototype.putFiles = function (o, callback) {\r\n        var self = this;\r\n\r\n        var filenames = Object.keys(o);\r\n        var remaining = filenames.length;\r\n\r\n        var hashes = {};\r\n\r\n        for (var j = 0; j < filenames.length; j += 1) {\r\n            (function(filename, data) {\r\n\r\n                self.putFile(filename, data, function (err, hash) {\r\n                    remaining -= 1;\r\n\r\n                    hashes[filename] = hash;\r\n\r\n                    if (err) {\r\n                        // TODO: log/handle error\r\n                        return;\r\n                    }\r\n\r\n                    if (remaining === 0) {\r\n                        callback(null, hashes);\r\n                    }\r\n                });\r\n\r\n            })(filenames[j], o[filenames[j]]);\r\n        }\r\n    };\r\n\r\n    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {\r\n        return this.getObject(hash, callback, subpath);\r\n    }\r\n\r\n    BlobClient.prototype.getObject = function (hash, callback, subpath) {\r\n        superagent.parse['application/zip'] = function (obj, parseCallback) {\r\n            if (parseCallback) {\r\n                // Running on node; this should be unreachable due to req.pipe() below\r\n            } else {\r\n                return obj;\r\n            }\r\n        }\r\n        //superagent.parse['application/json'] = superagent.parse['application/zip'];\r\n\r\n        var req = superagent.get(this.getViewURL(hash, subpath));\r\n        if (req.pipe) {\r\n            // running on node\r\n            var Writable = require('stream').Writable;\r\n            require('util').inherits(BuffersWritable, Writable);\r\n\r\n            function BuffersWritable(options) {\r\n                Writable.call(this, options);\r\n\r\n                var self = this;\r\n                self.buffers = [];\r\n            }\r\n            BuffersWritable.prototype._write = function(chunk, encoding, callback) {\r\n                this.buffers.push(chunk);\r\n                callback();\r\n            };\r\n\r\n            var buffers = new BuffersWritable();\r\n            buffers.on('finish', function () {\r\n                callback(null, Buffer.concat(buffers.buffers));\r\n            });\r\n            buffers.on('error', function (err) {\r\n                callback(err);\r\n            });\r\n            req.pipe(buffers);\r\n        } else {\r\n            req.removeAllListeners('end');\r\n            req.on('request', function () {\r\n                if (typeof this.xhr !== 'undefined') {\r\n                    this.xhr.responseType = 'arraybuffer';\r\n                }\r\n            });\r\n            // req.on('error', callback);\r\n            req.on('end', function() {\r\n                if (req.xhr.status > 399) {\r\n                    callback(req.xhr.status);\r\n                } else {\r\n                    var contentType = req.xhr.getResponseHeader('content-type');\r\n                    var response = req.xhr.response; // response is an arraybuffer\r\n                    if (contentType == 'application/json') {\r\n                        function utf8ArrayToString(uintArray) {\r\n                            return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));\r\n                        }\r\n                        response = JSON.parse(utf8ArrayToString(new Uint8Array(response)));\r\n                    }\r\n                    callback(null, response);\r\n                }\r\n            });\r\n            req.end(callback);\r\n        }\r\n    };\r\n\r\n    BlobClient.prototype.getMetadata = function (hash, callback) {\r\n        superagent.get(this.getMetadataURL(hash))\r\n            .end(function (err, res) {\r\n                if (err || res.status > 399) {\r\n                    callback(err || res.status);\r\n                } else {\r\n                    callback(null, JSON.parse(res.text));\r\n                }\r\n            });\r\n    };\r\n\r\n    BlobClient.prototype.createArtifact = function (name) {\r\n        var artifact = new Artifact(name, this);\r\n        this.artifacts.push(artifact);\r\n        return artifact;\r\n    };\r\n\r\n    BlobClient.prototype.getArtifact = function (metadataHash, callback) {\r\n        // TODO: get info check if complex flag is set to true.\r\n        // TODO: get info get name.\r\n        var self = this;\r\n        this.getMetadata(metadataHash, function (err, info) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\r\n                var artifact = new Artifact(info.name, self, info);\r\n                self.artifacts.push(artifact);\r\n                callback(null, artifact);\r\n            } else {\r\n                callback('not supported contentType ' + JSON.stringify(info, null, 4));\r\n            }\r\n\r\n        });\r\n    };\r\n\r\n    BlobClient.prototype.saveAllArtifacts = function (callback) {\r\n        var remaining = this.artifacts.length;\r\n        var hashes = [];\r\n\r\n        if (remaining === 0) {\r\n            callback(null, hashes);\r\n        }\r\n\r\n        for (var i = 0; i < this.artifacts.length; i += 1) {\r\n\r\n            this.artifacts[i].save(function(err, hash) {\r\n                remaining -= 1;\r\n\r\n                hashes.push(hash);\r\n\r\n                if (err) {\r\n                    // TODO: log/handle errors\r\n                    return;\r\n                }\r\n                if (remaining === 0) {\r\n                    callback(null, hashes);\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    return BlobClient;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginConfig',[], function () {\r\n\r\n    /**\r\n     * Initializes a new instance of plugin configuration.\r\n     *\r\n     * Note: this object is JSON serializable see serialize method.\r\n     *\r\n     * @param config - deserializes an existing configuration to this object.\r\n     * @constructor\r\n     */\r\n    var PluginConfig = function (config) {\r\n        if (config) {\r\n            var keys = Object.keys(config);\r\n            for (var i = 0; i < keys.length; i += 1) {\r\n                // TODO: check for type on deserialization\r\n                this[keys[i]] = config[keys[i]];\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serializes this object to a JSON representation.\r\n     *\r\n     * @returns {{}}\r\n     */\r\n    PluginConfig.prototype.serialize = function () {\r\n        var keys = Object.keys(this);\r\n        var result = {};\r\n\r\n        for (var i = 0; i < keys.length; i += 1) {\r\n            // TODO: check for type on serialization\r\n            result[keys[i]] = this[keys[i]];\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n\r\n    return PluginConfig;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginNodeDescription',[], function () {\r\n\r\n    /**\r\n     * Initializes a new instance of plugin node description object.\r\n     *\r\n     * Note: this object is JSON serializable see serialize method.\r\n     *\r\n     * @param config - deserializes an existing configuration to this object.\r\n     * @constructor\r\n     */\r\n    var PluginNodeDescription = function (config) {\r\n        if (config) {\r\n            this.name = config.name;\r\n            this.id = config.id;\r\n        } else {\r\n            this.name = '';\r\n            this.id = '';\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serializes this object to a JSON representation.\r\n     *\r\n     * @returns {{}}\r\n     */\r\n    PluginNodeDescription.prototype.serialize = function() {\r\n        var keys = Object.keys(this);\r\n        var result = {};\r\n\r\n        for (var i = 0; i < keys.length; i += 1) {\r\n            // TODO: check for type on serialization\r\n            result[keys[i]] = this[keys[i]];\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    return PluginNodeDescription;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginMessage',['plugin/PluginNodeDescription'], function (PluginNodeDescription) {\r\n\r\n    /**\r\n     * Initializes a new instance of plugin message.\r\n     *\r\n     * Note: this object is JSON serializable see serialize method.\r\n     *\r\n     * @param config - deserializes an existing configuration to this object.\r\n     * @constructor\r\n     */\r\n    var PluginMessage = function (config) {\r\n        if (config) {\r\n            this.commitHash = config.commitHash;\r\n            if (config.activeNode instanceof PluginNodeDescription) {\r\n                this.activeNode = config.activeNode;\r\n            } else {\r\n                this.activeNode = new PluginNodeDescription(config.activeNode);\r\n            }\r\n\r\n            this.message = config.message;\r\n            if (config.severity) {\r\n                this.severity = config.severity;\r\n            } else {\r\n                this.severity = 'info';\r\n            }\r\n        } else {\r\n            this.commitHash = '';\r\n            this.activeNode = new PluginNodeDescription();\r\n            this.message = '';\r\n            this.severity = 'info';\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serializes this object to a JSON representation.\r\n     *\r\n     * @returns {{}}\r\n     */\r\n    PluginMessage.prototype.serialize = function () {\r\n        var result = {\r\n            commitHash: this.commitHash,\r\n            activeNode: this.activeNode.serialize(),\r\n            message: this.message,\r\n            severity: this.severity\r\n        };\r\n\r\n        return result;\r\n    };\r\n\r\n    return PluginMessage;\r\n});\n",
    "/**\r\n * Created by zsolt on 3/20/14.\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginResult',['plugin/PluginMessage'], function (PluginMessage) {\r\n\r\n    /**\r\n     * Initializes a new instance of a plugin result object.\r\n     *\r\n     * Note: this object is JSON serializable see serialize method.\r\n     *\r\n     * @param config - deserializes an existing configuration to this object.\r\n     * @constructor\r\n     */\r\n    var PluginResult = function (config) {\r\n        if (config) {\r\n            this.success = config.success;\r\n            this.pluginName = config.pluginName;\r\n            this.startTime = config.startTime;\r\n            this.finishTime = config.finishTime;\r\n            this.messages = [];\r\n            this.artifacts = config.artifacts;\r\n            this.error = config.error;\r\n\r\n            for (var i = 0; i < config.messages.length; i += 1) {\r\n                var pluginMessage;\r\n                if (config.messages[i] instanceof PluginMessage) {\r\n                    pluginMessage = config.messages[i];\r\n                } else {\r\n                    pluginMessage = new PluginMessage(config.messages[i]);\r\n                }\r\n                this.messages.push(pluginMessage);\r\n            }\r\n        } else {\r\n            this.success = false;\r\n            this.messages = []; // array of PluginMessages\r\n            this.artifacts = []; // array of hashes\r\n            this.pluginName = 'PluginName N/A';\r\n            this.startTime = null;\r\n            this.finishTime = null;\r\n            this.error = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the success flag of this result object\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    PluginResult.prototype.getSuccess = function () {\r\n        return this.success;\r\n    };\r\n\r\n    /**\r\n     * Sets the success flag of this result.\r\n     *\r\n     * @param {boolean} value\r\n     */\r\n    PluginResult.prototype.setSuccess = function (value) {\r\n        this.success = value;\r\n    };\r\n\r\n    /**\r\n     * Returns with the plugin messages.\r\n     *\r\n     * @returns {plugin.PluginMessage[]}\r\n     */\r\n    PluginResult.prototype.getMessages = function () {\r\n        return this.messages;\r\n    };\r\n\r\n    /**\r\n     * Adds a new plugin message to the messages list.\r\n     *\r\n     * @param {plugin.PluginMessage} pluginMessage\r\n     */\r\n    PluginResult.prototype.addMessage = function (pluginMessage) {\r\n        this.messages.push(pluginMessage);\r\n    };\r\n\r\n    PluginResult.prototype.getArtifacts = function () {\r\n        return this.artifacts;\r\n    };\r\n\r\n    PluginResult.prototype.addArtifact = function (hash) {\r\n        this.artifacts.push(hash);\r\n    };\r\n\r\n    /**\r\n     * Gets the name of the plugin to which the result object belongs to.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    PluginResult.prototype.getPluginName = function () {\r\n        return this.pluginName;\r\n    };\r\n\r\n    //------------------------------------------------------------------------------------------------------------------\r\n    //--------------- Methods used by the plugin manager\r\n\r\n    /**\r\n     * Sets the name of the plugin to which the result object belongs to.\r\n     *\r\n     * @param pluginName - name of the plugin\r\n     */\r\n    PluginResult.prototype.setPluginName = function (pluginName) {\r\n        this.pluginName = pluginName;\r\n    };\r\n\r\n    /**\r\n     * Gets the ISO 8601 representation of the time when the plugin started its execution.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    PluginResult.prototype.getStartTime = function () {\r\n        return this.startTime;\r\n    };\r\n\r\n    /**\r\n     * Sets the ISO 8601 representation of the time when the plugin started its execution.\r\n     *\r\n     * @param {string} time\r\n     */\r\n    PluginResult.prototype.setStartTime = function (time) {\r\n        this.startTime = time;\r\n    };\r\n\r\n    /**\r\n     * Gets the ISO 8601 representation of the time when the plugin finished its execution.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    PluginResult.prototype.getFinishTime = function () {\r\n        return this.finishTime;\r\n    };\r\n\r\n    /**\r\n     * Sets the ISO 8601 representation of the time when the plugin finished its execution.\r\n     *\r\n     * @param {string} time\r\n     */\r\n    PluginResult.prototype.setFinishTime = function (time) {\r\n        this.finishTime = time;\r\n    };\r\n\r\n    /**\r\n     * Gets error if any error occured during execution.\r\n     * FIXME: should this be an Error object?\r\n     * @returns {string}\r\n     */\r\n    PluginResult.prototype.getError = function () {\r\n        return this.error;\r\n    };\r\n\r\n    /**\r\n     * Sets the error string if any error occured during execution.\r\n     * FIXME: should this be an Error object?\r\n     * @param {string} time\r\n     */\r\n    PluginResult.prototype.setError = function (error) {\r\n        this.error = error;\r\n    };\r\n\r\n    /**\r\n     * Serializes this object to a JSON representation.\r\n     *\r\n     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}\r\n     */\r\n    PluginResult.prototype.serialize = function () {\r\n        var result = {\r\n            success: this.success,\r\n            messages: [],\r\n            artifacts: this.artifacts,\r\n            pluginName: this.pluginName,\r\n            startTime: this.startTime,\r\n            finishTime: this.finishTime,\r\n            error: this.error\r\n        };\r\n\r\n        for (var i = 0; i < this.messages.length; i += 1) {\r\n            result.messages.push(this.messages[i].serialize());\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    return PluginResult;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginBase',['plugin/PluginConfig',\r\n    'plugin/PluginResult',\r\n    'plugin/PluginMessage',\r\n    'plugin/PluginNodeDescription'],\r\n    function (PluginConfig, PluginResult, PluginMessage, PluginNodeDescription) {\r\n\r\n\r\n        /**\r\n         * Initializes a new instance of a plugin object, which should be a derived class.\r\n         *\r\n         * @constructor\r\n         */\r\n        var PluginBase = function () {\r\n            // set by initialize\r\n            this.logger = null;\r\n            this.blobClient = null;\r\n            this._currentConfig = null;\r\n\r\n            // set by configure\r\n            this.core = null;\r\n            this.project = null;\r\n            this.projectName = null;\r\n            this.branchName = null;\r\n            this.branchHash = null;\r\n            this.commitHash = null;\r\n            this.currentHash = null;\r\n            this.rootNode = null;\r\n            this.activeNode = null;\r\n            this.activeSelection = [];\r\n            this.META = null;\r\n\r\n            this.result = null;\r\n            this.isConfigured = false;\r\n        };\r\n\r\n        //--------------------------------------------------------------------------------------------------------------\r\n        //---------- Methods must be overridden by the derived classes\r\n\r\n        /**\r\n         * Main function for the plugin to execute. This will perform the execution.\r\n         * Notes:\r\n         * - do NOT use console.log use this.logger.[error,warning,info,debug] instead\r\n         * - do NOT put any user interaction logic UI, etc. inside this function\r\n         * - callback always have to be called even if error happened\r\n         *\r\n         * @param {function(string, plugin.PluginResult)} callback - the result callback\r\n         */\r\n        PluginBase.prototype.main = function (callback) {\r\n            throw new Error('implement this function in the derived class');\r\n        };\r\n\r\n        /**\r\n         * Readable name of this plugin that can contain spaces.\r\n         *\r\n         * @returns {string}\r\n         */\r\n        PluginBase.prototype.getName = function () {\r\n            throw new Error('implement this function in the derived class - getting type automatically is a bad idea,' +\r\n                'when the js scripts are minified names are useless.');\r\n        };\r\n\r\n        //--------------------------------------------------------------------------------------------------------------\r\n        //---------- Methods could be overridden by the derived classes\r\n\r\n        /**\r\n         * Current version of this plugin using semantic versioning.\r\n         * @returns {string}\r\n         */\r\n        PluginBase.prototype.getVersion = function () {\r\n            return '0.1.0';\r\n        };\r\n\r\n        /**\r\n         * A detailed description of this plugin and its purpose. It can be one or more sentences.\r\n         *\r\n         * @returns {string}\r\n         */\r\n        PluginBase.prototype.getDescription = function () {\r\n            return '';\r\n        };\r\n\r\n        /**\r\n         * Configuration structure with names, descriptions, minimum, maximum values, default values and\r\n         * type definitions.\r\n         *\r\n         * Example:\r\n         *\r\n         * [{\r\n         *    \"name\": \"logChildrenNames\",\r\n         *    \"displayName\": \"Log Children Names\",\r\n         *    \"description\": '',\r\n         *    \"value\": true, // this is the 'default config'\r\n         *    \"valueType\": \"boolean\",\r\n         *    \"readOnly\": false\r\n         * },{\r\n         *    \"name\": \"logLevel\",\r\n         *    \"displayName\": \"Logger level\",\r\n         *    \"description\": '',\r\n         *    \"value\": \"info\",\r\n         *    \"valueType\": \"string\",\r\n         *    \"valueItems\": [\r\n         *          \"debug\",\r\n         *          \"info\",\r\n         *          \"warn\",\r\n         *          \"error\"\r\n         *      ],\r\n         *    \"readOnly\": false\r\n         * },{\r\n         *    \"name\": \"maxChildrenToLog\",\r\n         *    \"displayName\": \"Maximum children to log\",\r\n         *    \"description\": 'Set this parameter to blabla',\r\n         *    \"value\": 4,\r\n         *    \"minValue\": 1,\r\n         *    \"valueType\": \"number\",\r\n         *    \"readOnly\": false\r\n         * }]\r\n         *\r\n         * @returns {object[]}\r\n         */\r\n        PluginBase.prototype.getConfigStructure = function () {\r\n            return [];\r\n        };\r\n\r\n        //--------------------------------------------------------------------------------------------------------------\r\n        //---------- Methods that can be used by the derived classes\r\n\r\n        /**\r\n         * Updates the current success flag with a new value.\r\n         *\r\n         * NewValue = OldValue && Value\r\n         *\r\n         * @param {boolean} value - apply this flag on current success value\r\n         * @param {string|null} message - optional detailed message\r\n         */\r\n        PluginBase.prototype.updateSuccess = function (value, message) {\r\n            var prevSuccess = this.result.getSuccess();\r\n            var newSuccessValue = prevSuccess && value;\r\n\r\n            this.result.setSuccess(newSuccessValue);\r\n            var msg = '';\r\n            if (message) {\r\n                msg = ' - ' + message;\r\n            }\r\n\r\n            this.logger.debug('Success was updated from ' + prevSuccess + ' to ' + newSuccessValue + msg);\r\n        };\r\n\r\n        /**\r\n         * WebGME can export the META types as path and this method updates the generated domain specific types with\r\n         * webgme node objects. These can be used to define the base class of new objects created through the webgme API.\r\n         *\r\n         * @param {object} generatedMETA\r\n         */\r\n        PluginBase.prototype.updateMETA = function (generatedMETA) {\r\n            var name;\r\n            for (name in this.META) {\r\n                if (this.META.hasOwnProperty(name)) {\r\n                    generatedMETA[name] = this.META[name];\r\n                }\r\n            }\r\n\r\n            // TODO: check if names are not the same\r\n            // TODO: log if META is out of date\r\n        };\r\n\r\n        /**\r\n         * Checks if the given node is of the given meta-type.\r\n         * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>\r\n         * @param node - Node to be checked for type.\r\n         * @param metaNode - Node object defining the meta type.\r\n         * @returns {boolean} - True if the given object was of the META type.\r\n         */\r\n        PluginBase.prototype.isMetaTypeOf = function (node, metaNode) {\r\n            var self = this;\r\n            while (node) {\r\n                if (self.core.getGuid(node) === self.core.getGuid(metaNode)) {\r\n                    return true;\r\n                }\r\n                node = self.core.getBase(node);\r\n            }\r\n            return false;\r\n        };\r\n\r\n        /**\r\n         * Finds and returns the node object defining the meta type for the given node.\r\n         * @param node - Node to be checked for type.\r\n         * @returns {Object} - Node object defining the meta type of node.\r\n         */\r\n        PluginBase.prototype.getMetaType = function (node) {\r\n            var self = this,\r\n                name;\r\n            while (node) {\r\n                name = self.core.getAttribute(node, 'name');\r\n                if (self.META.hasOwnProperty(name) && self.core.getGuid(node) === self.core.getGuid(self.META[name])) {\r\n                    break;\r\n                }\r\n                node = self.core.getBase(node);\r\n            }\r\n            return node;\r\n        };\r\n\r\n        /**\r\n         * Returns true if node is a direct instance of a meta-type node (or a meta-type node itself).\r\n         * @param node - Node to be checked.\r\n         * @returns {boolean}\r\n         */\r\n        PluginBase.prototype.baseIsMeta = function (node) {\r\n            var self = this,\r\n                baseName,\r\n                baseNode = self.core.getBase(node);\r\n            if (!baseNode) {\r\n                // FCO does not have a base node, by definition function returns true.\r\n                return true;\r\n            }\r\n            baseName = self.core.getAttribute(baseNode, 'name');\r\n            return self.META.hasOwnProperty(baseName) && self.core.getGuid(self.META[baseName]) === self.core.getGuid(baseNode);\r\n        };\r\n\r\n        /**\r\n         * Gets the current configuration of the plugin that was set by the user and plugin manager.\r\n         *\r\n         * @returns {object}\r\n         */\r\n        PluginBase.prototype.getCurrentConfig = function () {\r\n            return this._currentConfig;\r\n        };\r\n\r\n        /**\r\n         * Creates a new message for the user and adds it to the result.\r\n         *\r\n         * @param {object} node - webgme object which is related to the message\r\n         * @param {string} message - feedback to the user\r\n         * @param {string} severity - severity level of the message: 'debug', 'info' (default), 'warning', 'error'.\r\n         */\r\n        PluginBase.prototype.createMessage = function (node, message, severity) {\r\n            var severityLevel = severity || 'info';\r\n            //this occurence of the function will always handle a single node\r\n\r\n            var descriptor = new PluginNodeDescription({\r\n                    name: node ? this.core.getAttribute(node, 'name') : \"\",\r\n                    id: node ? this.core.getPath(node) : \"\"\r\n                });\r\n            var pluginMessage = new PluginMessage({\r\n                    commitHash: this.currentHash,\r\n                    activeNode: descriptor,\r\n                    message: message,\r\n                    severity: severityLevel\r\n                });\r\n\r\n            this.result.addMessage(pluginMessage);\r\n        };\r\n\r\n        /**\r\n         * Saves all current changes if there is any to a new commit.\r\n         * If the changes were started from a branch, then tries to fast forward the branch to the new commit.\r\n         * Note: Does NOT handle any merges at this point.\r\n         *\r\n         * @param {string|null} message - commit message\r\n         * @param callback\r\n         */\r\n        PluginBase.prototype.save = function (message, callback) {\r\n            var self = this;\r\n\r\n            this.logger.debug('Saving project');\r\n\r\n            this.core.persist(this.rootNode,function(err){if (err) {self.logger.error(err);}});\r\n            var newRootHash = self.core.getHash(self.rootNode);\r\n\r\n            var commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\r\n            if (message) {\r\n                commitMessage += ' - ' + message;\r\n            }\r\n            self.currentHash = self.project.makeCommit([self.currentHash], newRootHash, commitMessage, function (err) {if (err) {self.logger.error(err);}});\r\n\r\n            if (self.branchName) {\r\n                // try to fast forward branch if there was a branch name defined\r\n\r\n                // FIXME: what if master branch is already in a different state?\r\n\r\n                self.project.getBranchNames(function (err, branchNames) {\r\n                    if (branchNames.hasOwnProperty(self.branchName)) {\r\n                        var branchHash = branchNames[self.branchName];\r\n                        if (branchHash === self.branchHash) {\r\n                            // the branch does not have any new commits\r\n                            // try to fast forward branch to the current commit\r\n                            self.project.setBranchHash(self.branchName, self.branchHash, self.currentHash, function (err) {\r\n                                if (err) {\r\n                                    // fast forward failed\r\n                                    self.logger.error(err);\r\n                                    self.logger.info('\"' + self.branchName + '\" was NOT updated');\r\n                                    self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                                } else {\r\n                                    // successful fast forward of branch to the new commit\r\n                                    self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\r\n                                    // roll starting point on success\r\n                                    self.branchHash = self.currentHash;\r\n                                }\r\n                                callback(err);\r\n                            });\r\n                        } else {\r\n                            // branch has changes a merge is required\r\n                            // TODO: try auto-merge, if fails ...\r\n                            self.logger.warn('Cannot fast forward \"' + self.branchName + '\" branch. Merge is required but not supported yet.');\r\n                            self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                            callback(null);\r\n                        }\r\n                    } else {\r\n                        // branch was deleted or not found, do nothing\r\n                        self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                        callback(null);\r\n                    }\r\n                });\r\n                // FIXME: is this call async??\r\n                // FIXME: we are not tracking all commits that we make\r\n\r\n            } else {\r\n                // making commits, we have not started from a branch\r\n                self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                callback(null);\r\n            }\r\n\r\n            // Commit changes.\r\n/*            this.core.persist(this.rootNode, function (err) {\r\n                // TODO: any error here?\r\n                if (err) {\r\n                    self.logger.error(err);\r\n                }\r\n\r\n                var newRootHash = self.core.getHash(self.rootNode);\r\n\r\n                var commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\r\n                if (message) {\r\n                    commitMessage += ' - ' + message;\r\n                }\r\n\r\n                self.currentHash = self.project.makeCommit([self.currentHash], newRootHash, commitMessage, function (err) {\r\n                    // TODO: any error handling here?\r\n                    if (err) {\r\n                        self.logger.error(err);\r\n                    }\r\n\r\n                    if (self.branchName) {\r\n                        // try to fast forward branch if there was a branch name defined\r\n\r\n                        // FIXME: what if master branch is already in a different state?\r\n\r\n                        self.project.getBranchNames(function (err, branchNames) {\r\n                            if (branchNames.hasOwnProperty(self.branchName)) {\r\n                                var branchHash = branchNames[self.branchName];\r\n                                if (branchHash === self.branchHash) {\r\n                                    // the branch does not have any new commits\r\n                                    // try to fast forward branch to the current commit\r\n                                    self.project.setBranchHash(self.branchName, self.branchHash, self.currentHash, function (err) {\r\n                                        if (err) {\r\n                                            // fast forward failed\r\n                                            self.logger.error(err);\r\n                                            self.logger.info('\"' + self.branchName + '\" was NOT updated');\r\n                                            self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                                        } else {\r\n                                            // successful fast forward of branch to the new commit\r\n                                            self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\r\n                                            // roll starting point on success\r\n                                            self.branchHash = self.currentHash;\r\n                                        }\r\n                                        callback(err);\r\n                                    });\r\n                                } else {\r\n                                    // branch has changes a merge is required\r\n                                    // TODO: try auto-merge, if fails ...\r\n                                    self.logger.warn('Cannot fast forward \"' + self.branchName + '\" branch. Merge is required but not supported yet.');\r\n                                    self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                                    callback(null);\r\n                                }\r\n                            } else {\r\n                                // branch was deleted or not found, do nothing\r\n                                self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                                callback(null);\r\n                            }\r\n                        });\r\n                        // FIXME: is this call async??\r\n                        // FIXME: we are not tracking all commits that we make\r\n\r\n                    } else {\r\n                        // making commits, we have not started from a branch\r\n                        self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\r\n                        callback(null);\r\n                    }\r\n                });\r\n\r\n            });*/\r\n        };\r\n\r\n        //--------------------------------------------------------------------------------------------------------------\r\n        //---------- Methods that are used by the Plugin Manager. Derived classes should not use these methods\r\n\r\n        /**\r\n         * Initializes the plugin with objects that can be reused within the same plugin instance.\r\n         *\r\n         * @param {logManager} logger - logging capability to console (or file) based on PluginManager configuration\r\n         * @param {blob.BlobClient} blobClient - virtual file system where files can be generated then saved as a zip file.\r\n         */\r\n        PluginBase.prototype.initialize = function (logger, blobClient) {\r\n            if (logger) {\r\n                this.logger = logger;\r\n            } else {\r\n                this.logger = console;\r\n            }\r\n\r\n            this.blobClient = blobClient;\r\n\r\n            this._currentConfig = null;\r\n            // initialize default configuration\r\n            this.setCurrentConfig(this.getDefaultConfig());\r\n\r\n            this.isConfigured = false;\r\n        };\r\n\r\n        /**\r\n         * Configures this instance of the plugin for a specific execution. This function is called before the main by\r\n         * the PluginManager.\r\n         * Initializes the result with a new object.\r\n         *\r\n         * @param {PluginContext} config - specific context: project, branch, core, active object and active selection.\r\n         */\r\n        PluginBase.prototype.configure = function (config) {\r\n            this.core = config.core;\r\n            this.project = config.project;\r\n            this.projectName = config.projectName;\r\n            this.branchName = config.branchName;\r\n            this.branchHash = config.branchName ? config.commitHash : null;\r\n            this.commitHash = config.commitHash;\r\n            this.currentHash = config.commitHash;\r\n            this.rootNode = config.rootNode;\r\n            this.activeNode = config.activeNode;\r\n            this.activeSelection = config.activeSelection;\r\n            this.META = config.META;\r\n\r\n            this.result = new PluginResult();\r\n\r\n\r\n            this.isConfigured = true;\r\n        };\r\n\r\n        /**\r\n         * Gets the default configuration based on the configuration structure for this plugin.\r\n         *\r\n         * @returns {plugin.PluginConfig}\r\n         */\r\n        PluginBase.prototype.getDefaultConfig = function () {\r\n            var configStructure = this.getConfigStructure();\r\n\r\n            var defaultConfig = new PluginConfig();\r\n\r\n            for (var i = 0; i < configStructure.length; i += 1) {\r\n                defaultConfig[configStructure[i].name] = configStructure[i].value;\r\n            }\r\n\r\n            return defaultConfig;\r\n        };\r\n\r\n        /**\r\n         * Sets the current configuration of the plugin.\r\n         *\r\n         * @param {object} newConfig - this is the actual configuration and NOT the configuration structure.\r\n         */\r\n        PluginBase.prototype.setCurrentConfig = function (newConfig) {\r\n            this._currentConfig = newConfig;\r\n        };\r\n\r\n        return PluginBase;\r\n    });\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n'use strict';\r\ndefine('plugin/PluginContext',[], function () {\r\n\r\n    /**\r\n     * Initializes a new instance of PluginContext. This context is set through PluginBase.configure method for a given\r\n     * plugin instance and execution.\r\n     *\r\n     * @constructor\r\n     */\r\n    var PluginContext = function () {\r\n\r\n        // TODO: something like this\r\n//        context.project = project;\r\n//        context.projectName = config.project;\r\n//        context.core = new Core(context.project);\r\n//        context.commitHash = config.commit;\r\n//        context.selected = config.selected;\r\n//        context.storage = null;\r\n\r\n    };\r\n\r\n\r\n    return PluginContext;\r\n});\n",
    "/*\r\n * Copyright (C) 2014 Vanderbilt University, All rights reserved.\r\n *\r\n * Author: Zsolt Lattmann\r\n */\r\n\r\n// TODO: Use PluginManagerConfiguration\r\n// TODO: Load ActiveSelection objects and pass it correctly\r\n// TODO: Add more statistics to the result object\r\n// TODO: Result object rename name -> pluginName, time -> finishTime)\r\n// TODO: Make this class testable\r\n// TODO: PluginManager should download the plugins\r\n\r\n'use strict';\r\ndefine('plugin/PluginManagerBase',[\r\n        './PluginBase',\r\n        './PluginContext',\r\n        'logManager'],\r\n    function (PluginBase, PluginContext, LogManager) {\r\n\r\n        var PluginManagerBase = function (storage, Core, plugins) {\r\n            this.logger = LogManager.create(\"PluginManager\");\r\n            this._Core = Core;       // webgme core class is used to operate on objects\r\n            this._storage = storage; // webgme storage\r\n            this._plugins = plugins; // key value pair of pluginName: pluginType - plugins are already loaded/downloaded\r\n            this._pluginConfigs = {}; // keeps track of the current configuration for each plugins by name\r\n\r\n            var pluginNames = Object.keys(this._plugins);\r\n            for (var i = 0; i < pluginNames.length; i += 1) {\r\n                var p = new this._plugins[pluginNames[i]]();\r\n                this._pluginConfigs[pluginNames[i]] = p.getDefaultConfig();\r\n            }\r\n        };\r\n\r\n        PluginManagerBase.prototype.initialize = function (managerConfiguration, configCallback, callbackContext) {\r\n            var self = this,\r\n                plugins = this._plugins;\r\n\r\n            //#1: PluginManagerBase should load the plugins\r\n\r\n            //#2: PluginManagerBase iterates through each plugin and collects the config data\r\n            var pluginConfigs = {};\r\n\r\n            for (var p in plugins) {\r\n                if (plugins.hasOwnProperty(p)) {\r\n                    var plugin = new plugins[p]();\r\n                    pluginConfigs[p] = plugin.getConfigStructure();\r\n                }\r\n            }\r\n\r\n            if (configCallback) {\r\n                configCallback.call(callbackContext, pluginConfigs, function (updatedPluginConfig) {\r\n                    for (var p in updatedPluginConfig) {\r\n                        if (updatedPluginConfig.hasOwnProperty(p)) {\r\n                            //save it back to the plugin\r\n                            self._pluginConfigs[p] = updatedPluginConfig[p];\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Gets a new instance of a plugin by name.\r\n         *\r\n         * @param {string} name\r\n         * @returns {plugin.PluginBase}\r\n         */\r\n        PluginManagerBase.prototype.getPluginByName = function (name) {\r\n            return this._plugins[name];\r\n        };\r\n\r\n        PluginManagerBase.prototype.loadMetaNodes = function (pluginContext, callback) {\r\n            var self = this;\r\n\r\n            this.logger.debug('Loading meta nodes');\r\n\r\n            // get meta members\r\n            var metaIDs = pluginContext.core.getMemberPaths(pluginContext.rootNode, 'MetaAspectSet');\r\n\r\n            var len = metaIDs.length;\r\n\r\n            var nodeObjs = [];\r\n\r\n\r\n            var allObjectsLoadedHandler = function () {\r\n                var len2 = nodeObjs.length;\r\n\r\n                var nameObjMap = {};\r\n\r\n                while (len2--) {\r\n                    var nodeObj = nodeObjs[len2];\r\n\r\n                    nameObjMap[pluginContext.core.getAttribute(nodeObj, 'name')] = nodeObj;\r\n                }\r\n\r\n                pluginContext.META = nameObjMap;\r\n\r\n                self.logger.debug('Meta nodes are loaded');\r\n\r\n                callback(null, pluginContext);\r\n            };\r\n\r\n            var loadedMetaObjectHandler = function (err, nodeObj) {\r\n                nodeObjs.push(nodeObj);\r\n\r\n                if (nodeObjs.length === metaIDs.length) {\r\n                    allObjectsLoadedHandler();\r\n                }\r\n            };\r\n\r\n            while (len--) {\r\n                pluginContext.core.loadByPath(pluginContext.rootNode, metaIDs[len], loadedMetaObjectHandler);\r\n            }\r\n        };\r\n\r\n        /**\r\n         *\r\n         * @param {plugin.PluginManagerConfiguration} managerConfiguration\r\n         * @param {function} callback\r\n         */\r\n        PluginManagerBase.prototype.getPluginContext = function (managerConfiguration, callback) {\r\n\r\n            // TODO: check if callback is a function\r\n\r\n            var self = this;\r\n\r\n            var pluginContext = new PluginContext();\r\n\r\n            // based on the string values get the node objects\r\n            // 1) Open project\r\n            // 2) Load branch OR commit hash\r\n            // 3) Load rootNode\r\n            // 4) Load active object\r\n            // 5) Load active selection\r\n            // 6) Update context\r\n            // 7) return\r\n\r\n            pluginContext.project = this._storage;\r\n            pluginContext.projectName = managerConfiguration.project;\r\n            pluginContext.core = new self._Core(pluginContext.project);\r\n            pluginContext.commitHash = managerConfiguration.commit;\r\n            pluginContext.activeNode = null;    // active object\r\n            pluginContext.activeSelection = []; // selected objects\r\n\r\n            // add activeSelection\r\n            var loadActiveSelectionAndMetaNodes = function () {\r\n                if (managerConfiguration.activeSelection.length === 0) {\r\n                    self.loadMetaNodes(pluginContext, callback);\r\n                } else {\r\n                    var remaining = managerConfiguration.activeSelection.length;\r\n\r\n                    for (var i = 0; i < managerConfiguration.activeSelection.length; i += 1) {\r\n                        (function (activeNodePath) {\r\n                            pluginContext.core.loadByPath(pluginContext.rootNode, activeNodePath, function (err, activeNode) {\r\n                                remaining -= 1;\r\n\r\n                                if (err) {\r\n                                    self.logger.error('unable to load active selection: ' + activeNodePath);\r\n                                    return;\r\n                                }\r\n\r\n                                pluginContext.activeSelection.push(activeNode);\r\n\r\n                                if (remaining === 0) {\r\n                                    // all nodes from active selection are loaded\r\n                                    self.loadMetaNodes(pluginContext, callback);\r\n                                }\r\n                            });\r\n                        })(managerConfiguration.activeSelection[i]);\r\n                    }\r\n                }\r\n            };\r\n\r\n            // add activeNode\r\n            var loadCommitHashAndRun = function (commitHash) {\r\n                self.logger.info('Loading commit ' + commitHash);\r\n                pluginContext.project.loadObject(commitHash, function (err, commitObj) {\r\n                    if (err) {\r\n                        callback(err, pluginContext);\r\n                        return;\r\n                    }\r\n\r\n                    if (typeof commitObj === 'undefined' || commitObj === null) {\r\n                        callback('cannot find commit', pluginContext);\r\n                        return;\r\n                    }\r\n\r\n                    pluginContext.core.loadRoot(commitObj.root, function (err, rootNode) {\r\n                        if (err) {\r\n                            callback(\"unable to load root\", pluginContext);\r\n                            return;\r\n                        }\r\n\r\n                        pluginContext.rootNode = rootNode;\r\n                        if (typeof managerConfiguration.activeNode === 'string') {\r\n                            pluginContext.core.loadByPath(pluginContext.rootNode, managerConfiguration.activeNode, function (err, activeNode) {\r\n                                if (err) {\r\n                                    callback(\"unable to load selected object\", pluginContext);\r\n                                    return;\r\n                                }\r\n\r\n                                pluginContext.activeNode = activeNode;\r\n                                loadActiveSelectionAndMetaNodes();\r\n                            });\r\n                        } else {\r\n                            pluginContext.activeNode = null;\r\n                            loadActiveSelectionAndMetaNodes();\r\n                        }\r\n                    });\r\n                });\r\n            };\r\n\r\n            // load commit hash and run based on branch name or commit hash\r\n            if (managerConfiguration.branchName) {\r\n                pluginContext.project.getBranchNames(function (err, branchNames) {\r\n                    self.logger.debug(branchNames);\r\n\r\n                    if (branchNames.hasOwnProperty(managerConfiguration.branchName)) {\r\n                        pluginContext.commitHash = branchNames[managerConfiguration.branchName];\r\n                        pluginContext.branchName = managerConfiguration.branchName;\r\n                        loadCommitHashAndRun(pluginContext.commitHash);\r\n                    } else {\r\n                        callback('cannot find branch \\'' + managerConfiguration.branchName + '\\'', pluginContext);\r\n                    }\r\n                });\r\n            } else {\r\n                loadCommitHashAndRun(pluginContext.commitHash);\r\n            }\r\n\r\n        };\r\n\r\n        PluginManagerBase.prototype.executePlugin = function (name, managerConfiguration, callback) {\r\n            // TODO: check if name is a string\r\n            // TODO: check if managerConfiguration is an instance of PluginManagerConfiguration\r\n            // TODO: check if callback is a function\r\n            var self = this;\r\n\r\n            var PluginClass = this.getPluginByName(name);\r\n\r\n            var plugin = new PluginClass();\r\n\r\n            var pluginLogger = LogManager.create('Plugin.' + name);\r\n\r\n            plugin.initialize(pluginLogger, managerConfiguration.blobClient);\r\n\r\n            plugin.setCurrentConfig(this._pluginConfigs[name]);\r\n            for (var key in managerConfiguration.pluginConfig) {\r\n                if (managerConfiguration.pluginConfig.hasOwnProperty(key) && plugin._currentConfig.hasOwnProperty(key)) {\r\n                    plugin._currentConfig[key] = managerConfiguration.pluginConfig[key];\r\n                }\r\n            }\r\n            self.getPluginContext(managerConfiguration, function (err, pluginContext) {\r\n                if (err) {\r\n                    // TODO: this has to return with an empty PluginResult object and NOT with null.\r\n                    callback(err, null);\r\n                    return;\r\n\r\n                }\r\n\r\n                //set logging level at least to INFO level since the plugins write messages with INFO level onto the console\r\n                var logLevel = LogManager.getLogLevel();\r\n                if (logLevel < LogManager.logLevels.INFO) {\r\n                    // elevate log level if it is less then info\r\n                    LogManager.setLogLevel(LogManager.logLevels.INFO);\r\n                }\r\n\r\n                // TODO: Would be nice to log to file and to console at the same time.\r\n                //LogManager.setFileLogPath('PluginManager.log');\r\n\r\n                plugin.configure(pluginContext);\r\n\r\n                var startTime = (new Date()).toISOString();\r\n\r\n                plugin.main(function (err, result) {\r\n                    //set logging level back to previous value\r\n                    LogManager.setLogLevel(logLevel);\r\n\r\n                    // set common information (meta info) about the plugin and measured execution times\r\n                    result.setFinishTime((new Date()).toISOString());\r\n                    result.setStartTime(startTime);\r\n\r\n                    result.setPluginName(plugin.getName());\r\n                    result.setError(err);\r\n\r\n                    callback(err, result);\r\n                });\r\n\r\n            });\r\n\r\n        };\r\n\r\n\r\n        return PluginManagerBase;\r\n    });\n",
    "define('js/Dialogs/PluginConfig/PluginConfigDialog',[], function () {\r\n   return;\r\n});\r\n\n",
    "/*globals define, _, requirejs, WebGMEGlobal*/\r\n\r\ndefine('js/Utils/InterpreterManager',['core/core',\r\n        'plugin/PluginManagerBase',\r\n        'plugin/PluginResult',\r\n        'blob/BlobClient',\r\n        'js/Dialogs/PluginConfig/PluginConfigDialog'\r\n                                    ], function (Core,\r\n                                               PluginManagerBase,\r\n                                               PluginResult,\r\n                                               BlobClient,\r\n                                               PluginConfigDialog) {\r\n    \"use strict\";\r\n\r\n    var InterpreterManager = function (client) {\r\n        this._client = client;\r\n        //this._manager = new PluginManagerBase();\r\n        this._savedConfigs = {};\r\n    };\r\n\r\n    var getPlugin = function(name,callback){\r\n        if (WebGMEGlobal && WebGMEGlobal.plugins && WebGMEGlobal.plugins.hasOwnProperty(name)) {\r\n            callback(null, WebGMEGlobal.plugins[name]);\r\n        } else {\r\n            requirejs(['/plugin/' + name + '/' + name + '/' + name],\r\n                function (InterpreterClass) {\r\n                    callback(null, InterpreterClass);\r\n                },\r\n                function (err) {\r\n                    callback(err, null);\r\n                }\r\n            );\r\n        }\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {string} name - name of plugin to be executed.\r\n     * @param {object} silentPluginCfg - if falsy dialog window will be shown.\r\n     * @param {object.string} silentPluginCfg.activeNode - Path to activeNode.\r\n     * @param {object.Array.<string>} silentPluginCfg.activeSelection - Paths to nodes in activeSelection.\r\n     * @param {object.boolean} silentPluginCfg.runOnServer - Whether to run the plugin on the server or not.\r\n     * @param {object.object} silentPluginCfg.pluginConfig - Plugin specific options.\r\n     * @param callback\r\n     */\r\n    InterpreterManager.prototype.run = function (name, silentPluginCfg, callback) {\r\n        var self = this;\r\n        getPlugin(name,function(err,plugin){\r\n            if(!err && plugin) {\r\n                var plugins = {},\r\n                    runWithConfiguration;\r\n                plugins[name] = plugin;\r\n                var pluginManager = new PluginManagerBase(self._client.getProjectObject(), Core, plugins);\r\n                pluginManager.initialize(null, function (pluginConfigs, configSaveCallback) {\r\n                    //#1: display config to user\r\n                    var hackedConfig = {\r\n                        'Global Options': [\r\n                            {\r\n                                \"name\": \"runOnServer\",\r\n                                \"displayName\": \"Execute on Server\",\r\n                                \"description\": '',\r\n                                \"value\": false, // this is the 'default config'\r\n                                \"valueType\": \"boolean\",\r\n                                \"readOnly\": false\r\n                            }\r\n                        ]\r\n                    };\r\n\r\n                    for (var i in pluginConfigs) {\r\n                        if (pluginConfigs.hasOwnProperty(i)) {\r\n                            hackedConfig[i] = pluginConfigs[i];\r\n\r\n                            // retrieve user settings from previous run\r\n                            if (self._savedConfigs.hasOwnProperty(i)) {\r\n                                var iConfig = self._savedConfigs[i];\r\n                                var len = hackedConfig[i].length;\r\n\r\n                                while (len--) {\r\n                                    if (iConfig.hasOwnProperty(hackedConfig[i][len].name)) {\r\n                                        hackedConfig[i][len].value = iConfig[hackedConfig[i][len].name];\r\n                                    }\r\n                                }\r\n\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    runWithConfiguration = function (updatedConfig) {\r\n                        //when Save&Run is clicked in the dialog (or silentPluginCfg was passed)\r\n                        var globalconfig = updatedConfig['Global Options'],\r\n                            activeNode,\r\n                            activeSelection;\r\n                        delete updatedConfig['Global Options'];\r\n\r\n                        activeNode = silentPluginCfg.activeNode;\r\n                        if (!activeNode && WebGMEGlobal && WebGMEGlobal.State) {\r\n                                activeNode = WebGMEGlobal.State.getActiveObject();\r\n                        }\r\n                        activeSelection = silentPluginCfg.activeSelection;\r\n                        if (!activeSelection && WebGMEGlobal && WebGMEGlobal.State) {\r\n                            activeSelection = WebGMEGlobal.State.getActiveSelection();\r\n                        }\r\n                        // save config from user\r\n                        for (var i in updatedConfig) {\r\n                            self._savedConfigs[i] = updatedConfig[i];\r\n                        }\r\n\r\n                        //#2: save it back and run the plugin\r\n                        if (configSaveCallback) {\r\n                            configSaveCallback(updatedConfig);\r\n\r\n                            // TODO: if global config says try to merge branch then we should pass the name of the branch\r\n                            var config = {\r\n                                \"project\": self._client.getActiveProjectName(),\r\n                                \"token\": \"\",\r\n                                \"activeNode\": activeNode, // active object in the editor\r\n                                \"activeSelection\": activeSelection || [],\r\n                                \"commit\": self._client.getActualCommit(), //\"#668b3babcdf2ddcd7ba38b51acb62d63da859d90\",\r\n                                \"branchName\": self._client.getActualBranch() // this has priority over the commit if not null\r\n                            };\r\n\r\n                            if(globalconfig.runOnServer === true || silentPluginCfg.runOnServer === true){\r\n                                var context = {\r\n                                    managerConfig: config,\r\n                                    pluginConfigs:updatedConfig\r\n                                };\r\n                                self._client.runServerPlugin(name,context,function(err,result){\r\n                                    if(err){\r\n                                        console.error(err);\r\n                                        callback(new PluginResult()); //TODO return proper error result\r\n                                    } else {\r\n                                        var resultObject = new PluginResult(result);\r\n                                        callback(resultObject);\r\n                                    }\r\n                                });\r\n                            } else {\r\n                                config.blobClient = new BlobClient();\r\n\r\n                                pluginManager.executePlugin(name, config, function (err, result) {\r\n                                    if (err) {\r\n                                        console.error(err);\r\n                                    }\r\n                                    callback(result);\r\n                                });\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (silentPluginCfg) {\r\n                        var updatedConfig = {};\r\n                        for (var i in hackedConfig) {\r\n                            updatedConfig[i] = {};\r\n                            var len = hackedConfig[i].length;\r\n                            while (len--) {\r\n                                updatedConfig[i][hackedConfig[i][len].name] = hackedConfig[i][len].value;\r\n                            }\r\n\r\n                            if (silentPluginCfg && silentPluginCfg.pluginConfig) {\r\n                                for (var j in silentPluginCfg.pluginConfig) {\r\n                                    updatedConfig[i][j] = silentPluginCfg.pluginConfig[j];\r\n                                }\r\n                            }\r\n                        }\r\n                        runWithConfiguration(updatedConfig);\r\n                    } else {\r\n                        var d = new PluginConfigDialog();\r\n                        silentPluginCfg = {};\r\n                        d.show(hackedConfig, runWithConfiguration);\r\n                    }\r\n                });\r\n            } else {\r\n                console.error(err);\r\n                console.error('unable to load plugin');\r\n                callback(null); //TODO proper result\r\n            }\r\n        });\r\n    };\r\n\r\n    //TODO somehow it would feel more right if we do run in async mode, but if not then we should provide getState and getResult synchronous functions as well\r\n\r\n    return InterpreterManager;\r\n});\r\n\n",
    "define('webgme.classes',\r\n  [\r\n    'client',\r\n    'blob/BlobClient',\r\n    'js/Utils/InterpreterManager'\r\n  ], function (Client, BlobClient, InterpreterManager) {\r\n    GME.classes.Client = Client;\r\n    GME.classes.BlobClient = BlobClient;\r\n    GME.classes.InterpreterManager = InterpreterManager;\r\n  });\r\n\n"
  ]
}